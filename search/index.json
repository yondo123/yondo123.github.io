[{"content":"원시타입과 참조타입 자바스크립트에서는 원시타입과 참조타입이 존재한다. 원시타입 그 자체가 값인 데이터 타입을 말한다.\n변수에 접근할 때 해당 변수에 저장된 실제 값을 조작한다.\n기본 값의 유형을 확인하려면 typeof연산자를 사용해서 확인할 수 있다.\n자바스크립트에서는 배열과 객체 모두 object로 취급한다는 사실을 꼭 잊지말자.\nconst typeNumeric = typeof 1; //number const typeBoolean = typeof true; //boolean const typeString = typeof \u0026#39;hello\u0026#39;; //string const typeFunction = typeof function(){ return;} //function const typeUndefined = typeof undefined; //undefined  const typeObject = typeof {}; //object const typeArray = typeof [\u0026#39;1\u0026#39;]; //object const typeNull = typeof null; //object 참조타입 원시 값과는 달리 해당 객체의 참조에 대해서 작업한다.\n즉, 참조 값을 재할당하면 원래의 변수에 저장된 값도 새 변수의 위치로 복사된다.\nconst fruits = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;]; const newFruits = fruits; newFruits.push(\u0026#39;banana\u0026#39;); console.log(\u0026#39;fruits\u0026gt;\u0026gt;\u0026#39; + fruits); //fruits\u0026gt;\u0026gt; apple,mango,banana console.log(\u0026#39;newFruits\u0026gt;\u0026gt;\u0026#39; + newFruits); //newFruits\u0026gt;\u0026gt; apple,mango,banana 그럼 객체와 배열을 어떻게 판별할 수 있을까?\n배열 판별하기 배열은 isArray()메서드로 배열 타입임을 확인할 수 있다.\nArray.isArray([1, 2, 3]); // true Array.isArray({foo: 123}); // false Array.isArray(\u0026#39;foobar\u0026#39;); // false Array.isArray(undefined); // false 객체 판별하기 자바스크립트에서는 객체를 판별하는것이 까다롭다.\n유사객체 타입이 많기 때문인데.. null타입과 array타입을 걸러내야 한다.\nconsole.log(detectObject({})); //true console.log(detectObject([])); //false console.log(detectObject(null)); //false  function detectObject(value){ if(typeof value === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; value !==null \u0026amp;\u0026amp; !Array.isArray(value)){ return true; }else{ return false; } } 원시타입 자료형 Number 자바스크립트에서는 정수(int)든, 실수(double, float)이든 실수로 처리한다(모든 숫자는 Number 자료형).\n모든 숫자를 64비트 부동 소수점 형태로 저장하기 때문에 typeof 연산자 결과값이 number로 저장된다.\n따라서 숫자 계산시 매우 유연하게 계산할 수 있다.\nlet numberA = 15; let numberB = 15.2; numberA + numberB; //30.2 String 자바스크립트에서는 홀따옴표, 쌍따옴표 상관없이 문자를 표현할 수 있다.\n(웬만하면 일관성있게 사용하자, 나는 주로 홀따옴표를 선호한다 ㅎㅎ)\nconcat 메서드등 문자열도 배열에서 제공하는 여러 메서드들을 몇개 쓸 수는 있지만, 연산시 객체로 변환했다가 다시 문자열로 내부적으로 처리된다.\n사실 concat보단 +연산자를 주로 쓴다..\nconst text = \u0026#39;abcdefg\u0026#39;; const message = \u0026#34;hello\u0026#34;!; text + message; //abcdefghello! text.concat(message); //abcdefghello! null과 undefined 자바스크립트에서 값이 비어있음을 나타내는 자료형이다.\nundefined는 할당되지 않은 변수의 초기값이며 변수 자체의 값 또한 undefined 이다.\nnull을 확인하고자 할 때 typeof의 결과는 object이기 때문에 일치 연산자(===)를 사용해야만 한다.\nvar nullChk = null; console.log(typeof nullChk == null); //false console.log(nullChk === null); //true 참조타입 자료형 배열 자바스크립트의 배열은 타 언어의 배열과 비교햇을 때, 좀 더 유연한 성질을 가지고 있다.(이 점을 주의하여야 한다.)\n다음과 같은 특징을 가지고 있다.\n 배열의 length는 실제 배열에 존재하는 원소 개수와 일치하는 것은 아니다. 배열의 Index는 자유이다, 가장 큰 Index 기준으로 length 값이 늘어난다. (실제 메모리가 늘어나는 것은 아니다.) 배열도 객체이므로 for in루프를 사용할 수 있지만, 불필요한 프로퍼티가 출력될 수 있으므로 일반 for문을 사용하는것이 성능적으로도 낫다. 배열에서 delete()메서드로 요소를 삭제하면 오직 undefined로 초기화만 해준다, 실질적으로 삭제하려면 splice()메서드를 사용해야만 한다.  배열 반복문 for 지정한 길이(array.length) 만큼 반복하며 요소에 접근할 수 있다.\nconst fruits = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;]; for(let i=0; i\u0026lt;fruits.length; i++){ console.log(fruits[i]); } forEach()\n배열의 각 요소에 한번씩 callback을 수행한다. (breack 불가)\n초기화되지 않은 원소들은 건너뛴다.\n배열의 사본을 생성하지 않으므로 참조하고 있는 경우 주의가 필요하다.\nconst arr = [\u0026#39;banana\u0026#39;, \u0026#39;kiwi\u0026#39;]; //일반 함수표현식 arr.forEach(function(element){ console.log(element); }); map()\nforEach()와 마찬가지로 요소를 순회하면서 표현식을 수행한다.\n큰 차이는 계산한 값들을 모아 새 배얄로 반환한다.\n성능이 느리긴하지만, 부수효과를 발생시키지 않는다는 장점이 있다.\n// 원소 100개의 배열을 생성하기 const arr = Array(100).fill().map(function(item, index){ return index; }); //[0~99] 배열을 생성하므로 변수에 담아 사용할 수 있다. (기존 배열에는 영향을 끼치지 않는다.)\nconst fruits = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;]; const newFruits = fruits.map(function(){ return \u0026#39;NEW\u0026#39;+value; }); 유용한 메서드 splice()\n배열 내부요소에 대해 제거하거나 제거한 위치에 값을 추가할 수 있다. (원본배열 수정)\nreturn 값은 제거된 요소만 담어서 반환한다. 제거한 요소가 없다면 빈 배열을 반환한다.\nconst fruits = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;]; const newFruits = fruits.splice(fruits.length, 0, \u0026#39;kiwi\u0026#39;); //맨끝에 키위 추가 const emptyFruits = fruits.splice(0, 1); //0번째 인덱스부터 \u0026#39;1\u0026#39;개 요소 제거  console.log(fruits); //[\u0026#39;kiwi\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;mango\u0026#39;] console.log(newFruits); //제거한 요소가 없으므로 빈값 [] console.log(emptyFruits); //제거한 요소 [apple] slice()\n원본 배열을 해치지 않고 얉은 복사본을 생성해 새 배열로 반환해준다.\nconst animals = [\u0026#39;ant\u0026#39;, \u0026#39;bison\u0026#39;, \u0026#39;camel\u0026#39;, \u0026#39;duck\u0026#39;, \u0026#39;elephant\u0026#39;]; console.log(animals.slice(2)); // expected output: Array [\u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;, \u0026#34;elephant\u0026#34;] console.log(animals.slice(2, 4)); // expected output: Array [\u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;] console.log(animals.slice(1, 5)); // expected output: Array [\u0026#34;bison\u0026#34;, \u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;, \u0026#34;elephant\u0026#34;] 객체 객체는 정적인 정보에 적합하다. (반복, 갱신, 대체가 필요한 정보에는 적합하지 않다.)\n자바스크립트에서의 객체는 타 언어와 다르게 여려 type의 프로퍼티들을 담을 수 있다.\n객체 생성하기 생성자 방식, 리터럴 방식으로 객체를 생성할 수 있는데 리터럴 방식으로 생성하기를 권고하고 있다. (성능, 안정)\n//생성자 방식 const fruits = new Object(); fruits.name = \u0026#39;grape\u0026#39;; fruits.price = 3000; //리터럴 방식 const fruits2 = { namae : \u0026#39;grape\u0026#39;, price : 3000 } 대괄호표기법과 마침표표기법 보통 마침표(.)를 이용해서 프로퍼티에 접근 하지만, 특별한 상황에선 배열처럼 대괄호([])를 이용해서 접근해야한다. (프로퍼티명이 표현식이거나 예약어일 경우)\nconst userInfo = { name : \u0026#39;jiny\u0026#39;, age : \u0026#39;25\u0026#39;, gerder : \u0026#39;male\u0026#39;, }; //마침표표기법 (일반 접근) const userName = userInfo.name; //대괄호표기법 (예약어 or 표현식) userInfo[\u0026#39;favorite-game\u0026#39;] = \u0026#39;FIFA\u0026#39;; console.log(userInfo[\u0026#39;favorite-game\u0026#39;]); 유용한 객체 메서드 Object.keys()\n객체의 요소들을 배열로 반환한다. Object.values()\n객체의 프로퍼티 값 (value)를 배열로 반환한다.\nconst userProperties = Object.keys(userInfo); //[\u0026#39;jiny\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gerder\u0026#39;] const userValues = Object.values(userInfo); //[\u0026#39;jiny\u0026#39;, \u0026#39;25\u0026#39;, \u0026#39;male\u0026#39;] Object.entries()\n객체의 [Key, Value] 형태의 배열로 반환한다.\nconst userlist = Object.entries(userInfo( //[[\u0026#34;name\u0026#34;,\u0026#34;jiny\u0026#34;],[\u0026#34;age\u0026#34;,\u0026#34;25\u0026#34;],[\u0026#34;gerder\u0026#34;,\u0026#34;male\u0026#34;]] 객체 사용 시 주의점 객체 또는 배열에서 속성이 제대로 정의되지 않으면 오류를 반환한ㄷ나.\n따라서 객체의 속성과 배열의 요소가 정상적으로 포함되어있는지 판단하는 검증이 필요하다.\nconst imageInfo_1 = {} //속성이 정의되지 않음 const imageInfo_2 = {file : []} //배열 개체가 없음 const imageInfo_3 = {file : [\u0026#39;app.png\u0026#39;, \u0026#39;thumb.jpg\u0026#39;]} //정상 function getImagePath(imageObject){ //객체의 속성, 배열 요소 검사  if(imageObject.file \u0026amp;\u0026amp; imageObject.file.length \u0026gt; 0){ //..code  return; }else{ return [`http://root/image/default.jpg`]; } } 조건문 자바스크립트에서 판독하는 거짓(false)의 값은 다음과 같다.\n false null 0 NaN \u0026quot;\u0026quot;, \u0026lsquo;'  삼항 연산자 분기를 더욱 단순하게 표현할 수 있다.\nconst path = \u0026#39;img/app.jpg\u0026#39;; if(path){ return path; }else{ return \u0026#39;\u0026#39;; } //삼항 연산자 return path ? path : \u0026#39;\u0026#39;; OR 연산자 OR 연산자 (||)로 검사한 값 중 하나가 true를 바환하면, 확인한 값을 곧바로 할당할 수 있다.\ndefault값을 할당하기에 더욱 편하다.\nconst path = \u0026#39;img/app.jpg\u0026#39;; function getImagePath(url){ const path = url || \u0026#39;img/default.jpg\u0026#39;; return \u0026#39;http://root\u0026#39; + path; } console.log(getImagePath(path)); // http://root/img/app.jpg console.log(getImagePath()) // http://root/img/default.jpg ","date":"2021-08-03T21:38:58+09:00","permalink":"https://jinyisland.kr/post/javascript-datatype/","title":"자바스크립트에서의 데이터 타입"},{"content":"Google Analytics 4 내 블로그의 정적 웹사이트 호스팅 플랫폼은 hugo를 쓰고 있다.\n예전에 잠깐 썼던 Jekyll 플랫폼과 비교했을 때 배포속도도 빠르고 테마 문서도 잘 되어있어서 편하다 ㅎㅎ\n원래 SEO에 대해 신경 쓰지 않고있다가, GoogleAnaytics와 GoogleSearchConsle을 적용시켜보려고 이것저것 시도해봤지만, 아직도 구글 애널리틱스 보고서에는 방문자가 0이다..\n(사실 진짜 0명인줄 알았으나 내가 들어와있어도 실시간에는 0이다..)\n새로운 추적 ID 구글링을 통해 알아본 휴고에 구글 애널리틱스 적용하는 글들을 보면, config.toml에 GoogleAnalytics변수에 그냥 추적 ID를 넣으면 끝이라는 내용이 많아 실제로 그렇게 해보았는데 적용이 안되고 있다.\n그리고 대다수의 사용자 추적 ID는 GA-XXXXXXX..으로 되어있는데 나는 G-XXXXXXXX.. 이렇게 조금 다르기도 하다.\n다시 구글링을 해 본 결과, 현재 시점에선 GoogleAnaytics의 버전이 4이며 휴고 테마에서 GA 설정을 지원해주지 않는 이상 스크립트 태그를 직접 넣어야된다는 사실을 알게 되었다..\nGoole Analytics4 적용 방법 먼저 필자의 Hugo 테마는 stack theme를 사용하고 있다.\n이 테마는 아직 GoogleAnaytics에 대한 설정 컴포넌트가 존재하지 않아 직접 해보기로 하였다.\n1. GoogleAnalytics4 가입하기\n먼저 구글 계정으로 GoogleAnalyticd4 페이지에서 로그인한다.\n로그인 후 측정시작 버튼을 눌러 구글애널리틱스 계정을 생성하면된다.\n참고로 구글 ID와 별개로 계정을 생성할 수 있으며 원하는 ID로 만들면된다. 그 후 속성 이름도 사이트에 걸맞는 속성이름으로 짓자.\n2. 추적 ID 가져오기\nGA에는 고유적으로 추적에 사용할 ID가 주어지는데 GA관리자 화면서 하단 관리 -\u0026gt; 데이터 스트림 -\u0026gt; 스트림 항목을 클릭하면 측정 ID를 얻을 수 있다. (양식은 G-XXXXXXXXX)\n3. Hugo에 적용시키기\n이제 이 추적 ID를 휴고에 적용시키면 끝!\nconfig.toml에 추적 ID를 사용 할 변수로 지정해놓는다.\n[params] googleAnalytics = \u0026#34;G-XXXXXX\u0026#34; . . 구글 애널리틱스에서 제공하는 온페이지 태그를 추가해야한다.\n휴고에서는 보통 ./layout/partials디렉토리에 사이드 html을 작성해주기 때문에 구글 애널리틱스 스크립트를 위한 html을 작성한다.\nSite.Params부분에 config.toml에 정의한 추적 ID 변수를 적어주면 된다.\n\u0026lt;!-- layout/partials/google-analytics.md--\u0026gt; \u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id={{ .Site.Params.googleAnalytics }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag(\u0026#39;js\u0026#39;, new Date()); gtag(\u0026#39;config\u0026#39;, \u0026#39;{{ .Site.Params.googleAnalytics }}\u0026#39;); \u0026lt;/script\u0026gt; 이제 휴고 블로그에 모든 페이지에서 이 스크립트를 로드해주면 된다.\n보통 전역에서 사용할 html은 /layout/_default/baseof.html에 작성한다.\n\u0026lt;head\u0026gt; {{ if .Site.Params.googleAnalytics }} {{ partial \u0026#34;google-analytics.html\u0026#34; . }} {{ end }} {{- partial \u0026#34;head/head.html\u0026#34; . -}} {{- block \u0026#34;head\u0026#34; . -}}{{ end }} \u0026lt;/head\u0026gt; 여기까지 설정하면 구글애널리틱스에서 접속 현황이 잘 노출이된다!\n깃에 배포하고 다시 블로그에 들어가면 아래 사진 처럼 잘 나오는 것을 확인할 수 있다.\n","date":"2021-07-30T22:15:51+09:00","permalink":"https://jinyisland.kr/post/hugo-ga/","title":"GoogleAnalytics 4 휴고 블로그에 적용 시키기"},{"content":"자바스크립트의 특징 나는 주로 자바스크립트를 이용해 개발을하는 것을 좋아한다.\n내 기준 가장 자신있는 언어이기도 하고, 배우면서 흥미로움을 느낀 프로그래밍 언어 중 하나였다.\n하지만 자바스크립트는 쓰면 쓸수록 헷갈리는 개념도 많고, 처음엔 만만하게 보였지만 깊이 들어갈수록 난해한..언어이기도 하다.. (아직도 어렵다 ㅠㅠ)😵\n자바스크립트에 대한 핵심적인 내용을 짚고 넘어가고자 해당 시리즈를 포스팅하기로 마음 먹었다! 첫 번째는 자바스크립트는 어떻게 동작할까?\n유연한 언어 자바스크립트에서의 타입 체크는 타 언어보다 굉장히 유연하고 느슨하다. 아래 예시를 보면 보통의 언어 같으면 컴파일 단계에서 들어오지 않은 값에 대해 오류를 내뿜어내지만, 자바스크립트에서는 일단 처리를 한다.\n제대로 타입체크를 하지 않으면 undefined(알 수 없음), NaN(숫자가 아님)등의 원치않는 값들이 런타임 단계에서 출력되기도 한다.\n이런 유연함과 느슨함이 장점이자 단점이 되는것이 개발자에게 자유를 보장하지만, 자칫 검증을 제대로 하지 않을 경우 그 책임도 개발자에게 발생한다.\nfunction add(a, b){ return a + b; } add(1, 2); //3 add(\u0026#39;1\u0026#39;+2); //\u0026#39;12\u0026#39; add(1); //NaN 객체와 함수가 핵심 자바스크립트의 거의 모든 것은 객체이다. 객체는 값의 속성을 나타내는 key와 속성을 표현하는 value로 구성되어 있다.\n객체는 리터럴 방식으로 생성하는 방식과, 생성자 방식으로 생성하는 방식이 있다.\nvar fruit = { name : \u0026#39;apple\u0026#39;, price : 1200 } var food = new Object(); food.name = \u0026#39;ramen\u0026#39;; food.price = 1500; //동적으로 추가 및 삭제도 가능하다. fruit.color = \u0026#39;red\u0026#39;; //fruit 객체에 color 속성 추가 delete(food.price); //food 객체의 price 속성 삭제 boolean, number, string, null, undefined타입을 제외한 나머지는 모두 객체로 구성되어 있다.\n심지어 함수도 객체이다. 일반적인 객체보다 더 많은 기능이 있는 객체 정도로 생각하면 된다.\ntypeof [1, 2, 3] //\u0026#34;object\u0026#34; typeof {name : \u0026#39;jiny\u0026#39;} //\u0026#34;object\u0026#34; typeof new Date() //\u0026#34;object\u0026#34; typeof funtion(){} // \u0026#34;function\u0026#34; 위의 예제를 보면 배열은 객체로 취급하는것을 알 수 있지만, 함수는 자료형 검사시 \u0026ldquo;function\u0026quot;으로 출력되기 때문에 객체로 자료형을 인식하지 않는다고 생각할 수 있다.\n하지만 함수도 엄연하게 객체로 취급받는다. 이유는 여러가지가 있지만 아래 2가지 핵심적인 이유가 있다.\n 함수도 변수에 할당 가능하다. 자바스크립트에서의 일반 객체Object처럼 취급할 수 있다. 함수에 사용자 정의 속성을 추가하는 것도 가능하다.  function log(msg){ return msg; } //함수 log에 속성 추가 log.author = \u0026#39;jiny\u0026#39;; log.execute = log(\u0026#39;hello\u0026#39;); console.log(log.author); //\u0026#39;jiny\u0026#39; console.log(log.execute); //\u0026#39;hello\u0026#39; 함수도 값으로 취급한다. 함수를 이용해 할 수 있는 것은 마치 객체를 이용해 할 수 있는 것과 같다. (이를 일급 객체라고 정의한다.)   리터럴 생성 마치 객체 리터럴 생성 방식과 유사하게 함수도 선언과 동시에 빠르게 작성할 수 있다.  function add(a,b){ return a + b; }  변수나 배열의 요소 혹은 객체의 속성에 할당할 수도 있다.  //변수에 할당 var add = function(a,b){ return a + b; } //객체 속성에 할당 var calculator = { add : add } //배열에도 할당 var sampleArray = [0, \u0026#39;1,\u0026#39;, add]  함수의 인자로 전달가능하고, 리턴값으로도 사용할 수 있다.  var success = function(){ console.log(\u0026#34;success\u0026#34;); } //add 함수에 success 함수를 3번째 인자로 넘기는 코드 function add(a, b, callback){ var result = a + b; if(!isNaN(result){ return callback() } } //함수 실행 add(1,2,success); 자바스크립트가 실행되는 과정 콜스택 자바스크립트에서는 실행 컨텍스트라는 콜스택 처리 방식으로 코드들을 실행한다.\n콜스택은 함수들을 호출(Call)하는 호출 정보들을 스택(Stack)에 차곡차곡 쌓여 있는 것을 의미한다.\n제일 나중에 올려져있는 스택부터 처리하기 때문에 선언한 코드들을 블록단위로 호출 스택에 쌓아놓고 하나씩 반환하면서 코드들을 실행한다.\nconsole.log(\u0026#34;global stack\u0026#34;); function firstExecute(){ console.log(\u0026#34;first!\u0026#34;); } function secondExecute(){ firstExecute() console.log(\u0026#34;second!\u0026#34;); } secondExecute(); /* global stack first! second! */ 위 코드를 콜스택 구조로 표현하자면 아래와 같다.\n설명을 하자면 먼저 유호범위 최상위에 있는 console.log 메서드 부터 스택에 삽입된다. 호출스택에 모두 쌓이고 실행을 시키는 것이아니라 스택에 쌓는 순간 해당 컨텍스트가 실행된다.\n실행이 끝나면 다시 콜스택에서 반환이 되면서 콜스택에 쌓인 컨텍스트를 모두 비워내게 되는것이다.\n실행 컨텍스트 그럼 좀 더 자세하게, 실행 컨텍스트에는 어떤일이 일어날까?\n먼저, 해당 실행 컨텍스트에서 사용할 매개변수나 정의한 변수들이 생성된다. 즉, 실행 컨텍스트를 수행하기 위한 사전 작업을 하는 것이다. (이는 자바스크립트 엔진 내부에서 일어난다.)\n그리고 arguement 객체를 생성하는데 이는 호출할 때 넘긴 인자들이 저장되어 있는 객체라고 보면 된다. (배열이지만 객체다!)\nfunction add(a, b){ //code } 그 다음, 현재 컨텍스트의 유효 범위를 나타내는 스코프 정보를 생성하는 작업을 하게된다.\n리스트 형태로 만들어지는데 이 스코프 리스트를 활용해 상위 컨텍스트의 변수에 접근하거나, 해당 컨텍스트의 변수에 접근할 수 있다.\n이 스코프 리스트는 서로 연결되어 있어 (해당 컨텍스트 범위에 없으면 상위 컨텍스트 범위에서 찾는다..)스코프 체인으로 불린다.\nvar number = 2; function add(a, b){ return a + b + number; } 해당 함수안에서 매개변수를 사용 할 수 있고, 스코프 체인을 통해 외부의 변수들도 사용할 수 있는 상태이다.\n이제 생성된 지역 변수가 변수 객체로 만들어진 후에 해당 코드 범위안에 있는 여러 계산실행이 이루어진다.\n만약 값이 할당되지 않았거나, 넘겨 받지 못했다면 undefined로 할당되어버린다.\nvar number = 2; function add(a, b){ var result = a + b + number; return result; } add(2,3); 그동안 얕게나마 알고 있는 이 중요한 개념들을 다시 책을 찾아보고 정리하느라 애먹었다..\n더 깊게 들어가면 끝도 없이 여러 개념들이 즐비하게 나온다..ㅠㅠ 이 장에서는 2가지만 기억하면 될 것 같다!\n1. 자바스크립트는 거의 모든 것들이 객체로 구성되어 있다. (심지어 함수까지도..)\n2. 자바스크립트 엔진은 콜스택 기반의 실행컨텍스트(Execution Context)를 생성하며 코드들을 실행한다.\n참고자료  모던웹을 위한 자바스크립트 + JQuery 입문 - 객체 (윤인성 저) MDN - typeof 인사이드 자바스크립트 - arguments 객체 및 실행 컨텍스트 (송형주, 고현준 저)  ","date":"2021-07-27T23:47:42+09:00","permalink":"https://jinyisland.kr/post/how-js-work/","title":"자바스크립트는 어떻게 동작할까?"},{"content":"윈도우에서 작업한 Vue 프로젝트를 mac 환경에서 확인하려던 중 git clone 후 프로젝트를 실행해보니 아래와 같은 에러가 나왔다.\n\u0026gt; vue-todo@0.1.0 serve /Users/sjchoi/Mydoc/02_Code/05_vue/vue-practice/vue-todo \u0026gt; vue-cli-service serve sh: vue-cli-service: command not found npm ERR! code ELIFECYCLE npm ERR! syscall spawn npm ERR! file sh npm ERR! errno ENOENT npm ERR! vue-todo@0.1.0 serve: `vue-cli-service serve` npm ERR! spawn ENOENT npm ERR! npm ERR! Failed at the vue-todo@0.1.0 serve script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm WARN Local package.json exists, but node_modules missing, did you mean to install? npm ERR! A complete log of this run can be found in: npm은 당연히 설치되어있는데 왜그러는지 몰라 한참을 찾아보다가 npm 캐시를 지워주면 된다는 말을 듣고 캐시를 지우고 다시 package.json에 정의된 모듈을 설치하였더니 잘 된다!\nnpm cache clean --force #npm 캐시 삭제 npm install #package.json 의존하는 모듈 설치 만약 npm install을 시행해도, 프로젝트 실행이 안된다면, npm run serve 중 필요한 라이브러리를 설치하라고 뜰테니 해당 라이브러리를 설치하고 시행하면 잘 된다.\n","date":"2021-07-18T23:09:02+09:00","permalink":"https://jinyisland.kr/post/vue-import/","title":"외부 Vue 프로젝트 불러오기"},{"content":"컴포넌트 개념 화면의 영역을 분리하여 개발하는 것, Vue에서 최상위 컴포넌트는 root이다.\n컴포넌트 구성의 장점은 요소들을 재사용함으로써 개발 생산성이 향상되고, 컴포넌트들은 서로 관계가 형성된다.\n전역 컴포넌트 주로 플러그인, 라이브러리 등 앱 전역에서 사용 할 공통 컴포넌트를 작성한다.\n전역 컴포넌트를 생성하면 새 인스턴스를 생성할 때 마다 기본적으로 생성한다.\n//컴포넌트 생성 Vue.component(\u0026#39;app-header\u0026#39;, { template: \u0026#39;\u0026lt;h1\u0026gt;header\u0026lt;/h1\u0026gt;\u0026#39; //component Template }); Vue.component(\u0026#39;app-content\u0026#39;, { template: \u0026#39;\u0026lt;p\u0026gt;This is Vue-Component Write\u0026lt;/p\u0026gt;\u0026#39; }); //인스턴스 생성 new Vue({ el: \u0026#39;#app\u0026#39; //selector }); 지역 컴포넌트 Vue 인스턴스 내에 직접 삽입하는 방식이다. components로 정의한다.\nTree 구조로 구성할 수 있으며, 부모-자식 간 컴포넌트 사이 통신이 가능하다.\n지역 컴포넌트는 해당 인스턴스에서만 동작한다. 따라서 인스턴스를 새로 생성할 때 마다 컴포넌트를 등록해주어야 한다.\nnew Vue({ el: \u0026#39;#app\u0026#39;, //selector  components: { //지역 컴포넌트 정의  \u0026#39;app-footer\u0026#39;: { template: \u0026#39;\u0026lt;footer\u0026gt;Footer!\u0026lt;/footer\u0026gt;\u0026#39; } } }); Template 템플릿 내에 생성한 컴포넌트를 태그로 지정한다.\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!--컴포넌트에 등록한 템플릿 지정--\u0026gt; \u0026lt;app-header\u0026gt;\u0026lt;/app-header\u0026gt; \u0026lt;app-content\u0026gt;\u0026lt;/app-content\u0026gt; \u0026lt;/div\u0026gt; 컴포넌트 통신 방식 Vue 컴포넌트는 각 고유한 데이터 유효범위를 갖는다.\n부모 컴포넌트의 데이터가 바뀌면 하위 컴포넌트의 데이터가 바뀌지만, 반대로 하위 컴포넌트의 데이터가 바뀌면 부모 컴포넌트가 바뀌지 않는다. (단방향 흐름)\nprops 상위 컴포넌트에서 하위 컴포넌트로 데이터 전달 시 사용한다.\nvue에서는 v-bind디렉티브로 속성에 접근할 수 있는데, 하위 컴포넌트에서 상위 컴포넌트의 데이터 속성에 접근이 가능하다.\n자세하게 말하면, v-bind로 해당 컴포넌트에서 정의된 props 속성에 접근할 수 있고 props의 역할은 부모의 data영역에 접근할 수 있게 해주는 속성이라고 볼 수 있다.\n\u0026lt;!--template--\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;app-header v-bind:propsdata=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/app-header\u0026gt; \u0026lt;/div\u0026gt; //하위 컴포넌트 var appHeader = { template: \u0026#39;\u0026lt;h1\u0026gt;header\u0026lt;/h1\u0026gt;\u0026#39;, props: [\u0026#39;propsdata\u0026#39;] } // Vue 인스턴스 (root 컴포넌트) new Vue({ el: \u0026#39;#app\u0026#39;, components: { \u0026#39;app-header\u0026#39;: appHeader }, data: { message: \u0026#39;hello Vue~~!!\u0026#39; } }); emit props와는 반대로 하위 컴포넌트에서 상위 컴포넌트로 이벤트를 전달할 수 있다.\n이벤트를 전달함으로써, 콜백내 this를 통해 상위 데이터에 접근하는 방법이다.\n컴포넌트 methods 속성 내에 여러 이벤트들을 정의할 수 있는데, 정의한 custom event를 트리거하려면 $emit메서드에 이벤트 이름을 전달하면 된다.\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;app-content v-on:add=\u0026#34;addNumber\u0026#34;\u0026gt;\u0026lt;/app-content\u0026gt; \u0026lt;p\u0026gt;number : {{number}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; //하위 컴포넌트  const appContent = { template: \u0026#39;\u0026lt;button v-on:add=\u0026#34;addNumber\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt;\u0026#39;, methods: { addNumber: function (params) { this.$emit(\u0026#39;add\u0026#39;); //상위 컴포넌트에 binding 할 이벤트  } } } //Vue 인스턴스 (root)  const vueObject = new Vue({ el: \u0026#39;#app\u0026#39;, components: { //local component  \u0026#39;app-content\u0026#39;: appContent }, methods: { addNumber: function () { //this 키워드로 정의한 data에 접근 가능  console.log(this.number++); } }, data: { number: 1 } }); 동등 컴포넌트 간 통신   내가 생각하는 컴포넌트 통신 실제로 기존 DOM 조작 방식(JQuery)에 익숙한 나는 위의 사진처럼 종속관계가 아니어도 값을 주고받을 수 있을줄 알았으나, 아래와 같이 해야한다고 한다.\n  실제 컴포넌트 통신 방법 위에 설명했던 컴포넌트의 특성을 살려 동등 레벨의 컴포넌트(부모가 동일한)가 데이터를 전달하려면, emit(상위 컴포넌트로 전달) -\u0026gt; props(하위 컴포넌트로 전달) 과정을 거쳐야 한다.\n  만일 같은 레벨의 header와 footer 사이 데이터 전달이 필요하다면 먼저 body에 데이터를 전달해야한다. ($emit)\n\u0026lt;div id=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;app-header\u0026gt;\u0026lt;/app-header\u0026gt; \u0026lt;app-footer v-on:message=\u0026#34;bindData\u0026#34;\u0026gt;\u0026lt;/app-footer\u0026gt; \u0026lt;/div\u0026gt; //footer 컴포넌트 const footer = { template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;h3\u0026gt;FOOTER\u0026lt;/h3\u0026gt;\u0026lt;button v-on:click=\u0026#34;passData\u0026#34;\u0026gt;trans-data\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;, methods: { passData: function () { this.$emit(\u0026#39;message\u0026#39;, \u0026#39;footer-data\u0026#39;); //해당 이벤트에 파라미터 전달  } }, } new Vue({ el: \u0026#39;#body\u0026#39;, components: { \u0026#39;app-header\u0026#39;: header, \u0026#39;app-footer\u0026#39;: footer }, data: { message: \u0026#39;test\u0026#39; }, methods: { bindData: function (param) { this.message = param; } }, }); 이제 부모의 message는 하위 컴포넌트에서 전달한 데이터로 변경이 되어있다.\nprops속성을 통해 접근하면된다.\n\u0026lt;app-header v-bind:headerdata=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/app-header\u0026gt; //header 컴포넌트 const header = { template : \u0026#39;\u0026lt;h2\u0026gt;Header\u0026lt;/h2\u0026gt;\u0026#39;, props : [\u0026#39;headerdata\u0026#39;] } 참고자료  Vue 공식문서 - vm-emit 캡틴판교님의 Vue 기초 강의  ","date":"2021-07-01T21:27:40+09:00","permalink":"https://jinyisland.kr/post/vue-component/","title":"Vue 컴포넌트에 대한 개념"},{"content":"CLI? cli란 Command Line Interface, 즉 명령어 기반의 인터페이스 환경을 의미한다.\nvue 프로젝트 도입시 전체적인 웹애플레이케이션을 관리하려면 지금 소개하는 cli패키지를 설치하면 되고,\n별도의 페이지에서 국한적으로 사용하려면 cdn방식으로도 사용할 수 있다.\nCDN 방식을 사용하려면 아래 소스를 참고하면 된다.\n\u0026lt;head\u0026gt; \u0026lt;!-- Vue-CDN --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- template --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;app-footer\u0026gt;\u0026lt;/app-footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //vue 인스턴스 생성  new Vue({ el: \u0026#39;#app\u0026#39;, components: { \u0026#39;app-footer\u0026#39; : { template : \u0026#39;\u0026lt;footer\u0026gt;Footer!\u0026lt;/footer\u0026gt;\u0026#39; } } }); \u0026lt;/script\u0026gt; Vue 설치하기 먼저 npm (node package manager) 및 node가 설치되어있어야 한다.\n특히 node 는 vue에서 10.X 버전 이상을 권장하기 때문에, 버전을 확인하고 10.X이상 버전을 준비하는 것이 필수이다.\nnode -v #현재 node 버전 확인 (LTS 10.X 버전 이상을 설치해야 한다.) npm -v #npm 버전 확인 npm install -g @vue/cli #vue-cli install Vue-cli 버전 별 프로젝트 생성 vue cli 버전마다 프로젝트 생성 방법이 조금 다르다.\n혹시 2.X 환경으로 vue를 생성해야 한다면, 직접 프로젝트 템플릿을 지정해주어야 한다.\n 2.X  vue-webpack-boilerplate : 대형 프로젝트 규모에 적합 (hot-reload, router, unit test, linting 포함) webpack-simple : 빠른 프로토타입 구축 목적에 적합 vue-simple-boilerplate : 하나의 html만 존재 (튜토리얼 수준에 적합)  # vue init \u0026#39;project-template-type\u0026#39; \u0026#39;project-directory\u0026#39; vue init webpack-simple vue-project  3.X~\n3버전 들어서 프로젝트 생성이 간편하게 되었다.\ncreate로 프로젝트 경로만 잡아주고 생성하고 직접 필요한 모듈을 선택해서 설치할 수 있다.\n물론 default로 필수 모듈(babel, linting)만 설치하고 필요한 모듈은 알아서 설치해도 상관없다. # vue create \u0026#39;project-directory\u0026#39; vue create vue-project   프로젝트 구조 vue 프로젝트 필수 구조\nroot ├─public │ └─index.html : 로컬 서버 실행시 제일 처음 참조되는 페이지 ├─src │ └─main.js : 프로젝트 전체에 대한 정보 (vue 인스턴스 생성) │ └─app.vue : 메인 컴포넌트 ├─package.json : 프로젝트 모듈 및 의존성 설정 정보  index.html\nwebpack을 통해 여러 컴포넌트 vue, 리소스들이 통합해 주입되는 페이지이다. 즉 페이지 내용이 변경될 때 마다 페이지를 reload하는 것이 아닌 변경된 요소만을 탐색해 내용을 변경한다.\nvue는 이러한 가상 DOM을 활용하기에 최적화된 framework이고 이러한 구조를 SPA (Single Page Application)라 한다. \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;  main.js\n프로젝트에 대한 전체 정보를 담고 있는 main 스크립트 파일이다.\n최상위 인스턴스로써, 여러 컴포넌트들을 공유할 수 있고 상태state들을 관리한다. import App from \u0026#39;./App.vue\u0026#39;; //main component new Vue({ el: \u0026#39;#app\u0026#39;, render: h =\u0026gt; h(App) });  package.json\n프로젝트에서 사용중인 여러 모듈을 관리하는 곳이다.\n특히, devDependencies에서 프로젝트에서 사용중인 여러 플러그인들을 확인할 수 있다. (의존성 관리) \u0026#34;devDependencies\u0026#34;: { \u0026#34;@vue/cli-plugin-babel\u0026#34;: \u0026#34;~4.5.0\u0026#34;, \u0026#34;@vue/cli-plugin-eslint\u0026#34;: \u0026#34;~4.5.0\u0026#34;, \u0026#34;@vue/cli-service\u0026#34;: \u0026#34;~4.5.0\u0026#34;, \u0026#34;babel-eslint\u0026#34;: \u0026#34;^10.1.0\u0026#34;, \u0026#34;eslint\u0026#34;: \u0026#34;^6.7.2\u0026#34;, \u0026#34;eslint-plugin-vue\u0026#34;: \u0026#34;^6.2.2\u0026#34;, \u0026#34;vue-template-compiler\u0026#34;: \u0026#34;^2.6.11\u0026#34; }   ","date":"2021-06-30T20:20:49+09:00","permalink":"https://jinyisland.kr/post/vue-start/","title":"Vue 설치하기 및 프로젝트 구조"}]
[{"content":"개요 기존 http모듈로 서버를 구축 해서 간단한 요청과 응답 프로세스를 경험해보았는데 여타 언어들도 그렇듯이 프레임워크를 사용하면 더욱 효율적으로 작업을 할 수 있다. node.js 생태계에서는 압도적으로 express.js를 많이 사용한다.\n설치하기 npm 환경에서 install 명령어를 통해 express를 설치한다.\n1npm install express 기본 구조 기본적인 서버를 구축한 소스이다.\nhttp 모듈로 구축했을 때 URL도 파싱해야하고, if문으로 분기처리하기 수고스러웠는데 상당히 깔끔해졌다.\n각 라우터마다 요청, 응답 객체를 받아와 여러 형태로 받거나 전달할 수 있다.\n1//app.js 2const express = require(\u0026#34;express\u0026#34;); 3const app = express(); 4 5//get 메서드 6app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { 7 //200 응답을 지정하고, 메시지를 전송한다. 8 res.status(200).send(\u0026#34;hello express server!!\u0026#34;); 9}); 10 11//post 메서드 12app.post(\u0026#34;/write\u0026#34;, (req,res)=\u0026gt;{ 13\t/* code */ 14}); 15 16//서버 실행 17app.listen(8082, () =\u0026gt; { 18 console.log(\u0026#34;start express server\u0026#34;); 19}); 모니터링 플러그인 nodemon은 개발 생산성을 높여주는 모니터링 플러그인이다.\n보통 파일이 변경되면 서버를 종료하고 다시 실행시키는데 자동으로 프로젝트내의 파일들의 변경 사항을 감지해서 자동적으로 재시작해준다. cli 환경에서 실행되기 때문에 global 환경으로 설치해준다.\n1#설치 2npm install -g nodemon 3 4#nodemon으로 앱 실행 5nodemon app package.json에 start 스크립트로 셋팅해두면 npm start로 간편히 실행시킬 수 있다.\n(정식으로는 npm run start이지만, run 생략가능)\n1\u0026#34;script\u0026#34; : { 2 \u0026#34;start\u0026#34; : \u0026#34;nodemon app\u0026#34; 3} nodemon으로 앱을 실행하면 파일이 바뀌면 알아서 재시작해준다.\n1\u0026gt; npm-test@1.0.0 start 2\u0026gt; nodemon app 3[nodemon] 2.0.13 4[nodemon] to restart at any time, enter `rs` 5[nodemon] watching path(s): *.* 6[nodemon] watching extensions: js,mjs,json 7[nodemon] starting `node app.js` 8start express server sendFile express에서는 fs모듈 필요 없이 sendFile메서드로 html파일을 브라우저에 전달할 수 있다.\n1project 2├── app.js 3├── html 4│ └── about.html 5├── package-lock.json 6└── package.json 1const path = require(\u0026#39;path\u0026#39;) 2app.get(\u0026#34;/about\u0026#34;, (req, res) =\u0026gt; { 3 res.sendFile(path.join(__dirname, \u0026#34;/html/about.html\u0026#34;)); 4}); 라우터 사용시 주의사항 express에서 api를 요청받을 때 요청 경로를 지정한다는 의미로 라우팅이라는 용어가 등장하는데, 이를 제어하는 부분이 라우터이다.\n한 라우터에서 여러개의 응답을 보내게 된다면 에러가 발생하는 것을 꼭 알아두자. (반드시 단일 요청에는 단일 응답을 설계하자.)\n1//❌ bad 2app.get((\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { 3\tres.sendFile(\u0026#39;./index.html\u0026#39;); 4\tres.send(\u0026#39;response test\u0026#39;); 5\tres.json({key : \u0026#39;value\u0026#39;}); 6}); 7 8//✅ Good 9app.get((\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { 10\tres.send(\u0026#39;response test\u0026#39;); 11}); 참고자료  Node.js 교과서 - 익스프레스 프로젝트 시작하기 (조현영 저)  ","date":"2022-03-29T22:57:14+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/express-start/","title":"Express 설치 및 실행해보기"},{"content":"FileSystem node.js에서는 fs 모듈을 통해 파일 시스템에 접근할 수 있다. 현재 파일 기준으로 경로를 잡는것이 아닌 실행하는 node 콘솔 기준으로 경로를 바라본다는 특징이 있다. 파일 시스템에 접근할 때는 반드시 보안에 꼭 신경쓰는 것이 좋다. 또한 비동기 함수이므로 동시에 실행이 보장되지 않는다.\n1## hello Node.js! readFile 파일을 읽어오는 메서드이다. 첫 번째 인자에 해당 파일의 상대경로, 두 번째 인자에 콜백 함수를 입력 받는다.\n(실행하는 node 기준이므로 같은 디렉토리에 위치해야한다.)\n1const fs = require(\u0026#39;fs\u0026#39;); 2 3fs.readFile(\u0026#39;./resource/README.md\u0026#39;, (err,data)=\u0026gt;{ 4 if(err){ 5 throw err; 6 }; 7 8 console.log(data); //\u0026lt;Buffer 23 23 20 68 65 6c 6c 6f 20 4e 6f 64 65 2e 6a 73 21\u0026gt; 9 console.log(data.toString()); //## hello Node.js! 10}); 만약 아무런 변환 없이 그대로 출력한다면 버퍼 형태로 출력된다.\n따라서 문자로된 실제 파일 데이터를 읽고 싶다면 toString()메서드로 따로 변환해주어야 한다.\nwriteFile 반대로 파일을 작성하려면 writeFile메서드를 사용한다. 생성할 파일 경로(확장자 까지 입력)와 내용을 포함한다.\n1fs.writeFile(\u0026#39;./resource/README2.md\u0026#39;, \u0026#39;## Heading2\u0026#39;); 기존 내용이 있는 파일에 writeFile을 해버린다면 아예 덮어씌워지기 때문에 기존 내용뒤에 덧붙이려면 appendFile() 메서드를 사용하면 된다.\n1fs.appendFile(\u0026#39;../resource/README2.md\u0026#39;, \u0026#39;### hello Express!\u0026#39;); promises fs 모듈은 기본적으로 콜백 형태로 사용하기 때문에 복잡한 로직이 들어가게된다면 사용하기가 불편하다.\npromises속성을 통해 프로미스로 감싸지 않고 then 문법을 사용할 수 있다.\n1const fs = require(\u0026#34;fs\u0026#34;).promises; 2 3fs.readFile(\u0026#34;./resource/README.md\u0026#34;) 4\t.then((data)=\u0026gt;{ 5\treturn data.toString(); 6\t}) 7\t.then((fileData)=\u0026gt;{ 8\tconsole.log(fileData); 9\t}) 10\t.catch((error)=\u0026gt;{ 11\tconsole.error(erroor); 12\t}); 동기처리 node.js에서 파일 처리는 비동기 방식으로 처리되는데, sync 접미사를 붙여 동기식으로 처리할 수도 있다.\n장점으로는 별도의 추가적인 작업 없이 바로 동기식으로 처리되어 순서가 보장된다.\n1const fs = require(\u0026#34;fs\u0026#34;); 2 3let fileData = fs.readFileSync(\u0026#34;./README1.md\u0026#34;); 4console.log(fileData.toString()); 5 6fileData = fs.readFileSync(\u0026#34;./README2.md\u0026#34;); 7console.log(fileData.toString()); 8 9fileData = fs.readFileSync(\u0026#34;./README3.md\u0026#34;); 10console.log(fileData.toString()); 11 12fileData = fs.readFileSync(\u0026#34;./README4.md\u0026#34;); 13console.log(fileData.toString()); 단점으로는 요청이 대다수로 들어올 때 성능이 떨어진다는 단점이 있다. 이 문제의 해결 방법으로는 기존 promise 또는 async-await 문법으로 순서를 보장하게끔 해결하는 방법이 있다.\n기타 메서드 파일 접근 여부 확인하기 fs.access()메서드로 파일에 올바르게 접근할 수 있는지 파악할 수 있다.\nfs 모듈의 constants속성으로 경로에 대한 권한, 읽기 및 쓰기 여부를 판단한다.\n F_OK : 존재여부 W_OK : 쓰기 권한 여부 R_OK : 읽기 권한 여부  1const fs = require(\u0026#39;fs\u0026#39;).promises; 2const constants = require(\u0026#39;fs\u0026#39;).constants; 3 4fs.access(\u0026#39;./assets\u0026#39;, constants.F_OK | constants.W_OK | constants.R_OK) 5\t.then(() =\u0026gt; { 6\treturn Promise.reject(\u0026#39;exist folder!\u0026#39;); 7\t}) 8 .catch((err) =\u0026gt; { 9 console.log(err.code); 10 }); 11\t//이어서.. 디렉토리 생성하기 1fs.mkdir(\u0026#39;./dir_name\u0026#39;); 디렉토리 내용 읽어오기 1fs.readdir(\u0026#39;../resource\u0026#39;).then((dir)=\u0026gt;{ 2 console.log(\u0026#39;디렉토리 구조\u0026#39;, dir); //디렉토리 구조 [ \u0026#39;README.md\u0026#39;, \u0026#39;README2.md\u0026#39;] 3}) 참고자료  Node.js 교과서 - 파일 시스템 접근하기 (조현영 저) nodejs.dev - The Node.js fs module  ","date":"2022-02-28T22:05:52+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/node-file/","title":"Node.js 파일 시스템 접근하기"},{"content":"웹 폰트 웹 폰트를 적용하는 방법은 크게 2가지가 있다. 하나는 cdn을 이용하는 방법, 나머지 하나는 직접 폰트 파일을 경로에 미리 삽입하여 @font-face로 정의하는 방법이다.\nCDN을 활용한 방법 구글 폰트 등과 같이 cdn을 제공해주는 사이트에서 폰트를 적용하는 방법이다. 너무나 간단한게 장점이고 단점으로는 직접 파일을 적용하는 방법보다 로드 속도가 느리다. 적용 방법은 직접 cdn 링크를 html에 삽입하고, css에서 font-family로 적용하거나, css import를 통해 적용하는 방법이 있다.\n1/* cdn import */ 2@import url(\u0026#39;https://fonts.googleapis.com/css2?family=Dongle:wght@300\u0026amp;display=swap\u0026#39;); 3 4/* 폰트 적용 */ 5body { 6 font-family: \u0026#39;Dongle\u0026#39;, sans-serif; 7} 폰트파일 직접 적용 직접 폰트 파일을 서비스 디렉토리에 넣어주고 @font-face로 불러오는 방법이 있다. 첫 번째 방법보다 번거롭지만 해당 폰트가 설치되어있지 않는 사용자들도 모두 적용할 수 있기 때문에 안정적이다.\n먼저 폰트 파일(ttf, eot, woff 등)을 직접 특정 디렉토리에 넣는다. 포맷에 따라 지원하는 브라우저가 천차만별이기 때문에 가능하면 WOFF, WOFF2, OTF 파일을 사용하는 것이 좋다. 파일을 준비했다면 이제 css 코드로 해당 폰트를 정의해주면된다. 파일 포맷에 따른 예시는 다음과 같다.\n font-family : 적용하고자 하는 폰트의 이름 font-style : 폰트의 기본 스타일 (선택사항) font-weight : 폰트의 기본 굵기 (선택사항) src : 해당 폰트 파일의 위치  url : 경로 format : 폰트 파일 형식    1/*fonts.css*/ 2@font-face { 3 font-family : \u0026#34;font-name\u0026#34;; /*font 이름*/ 4 font-style : \u0026#34;normal\u0026#34;; /* font 스타일 정의 (기울임, 일반) */ 5 font-weight : 400; /* font 굵기 정의 */ 6 /* 브라우저\u0026amp;디바이스 환경에 따른 font 파일 위치 정의 */ 7 src: url(\u0026#39;webfont.eot\u0026#39;); /* IE9 Compat Modes */ 8 src: url(\u0026#39;webfont.eot?#iefix\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), /* IE6-IE8 */ 9 url(\u0026#39;webfont.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;), /* Modern Browsers */ 10 url(\u0026#39;webfont.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), /* Modern Browsers */ 11 url(\u0026#39;webfont.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;), /* Safari, Android, iOS */ 12 url(\u0026#39;webfont.svg#svgFontName\u0026#39;) format(\u0026#39;svg\u0026#39;); /* Legacy iOS */ 13} 14 15/* 폰트 적용 */ 16body { 17 font-family : \u0026#39;font-name\u0026#39; 18} 참고자료  w3schools - CSS Web Fonts Google Fonts - 구글 폰트  ","date":"2022-01-17T23:18:33+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/font/","title":"HTML에 폰트 적용하는 방법"},{"content":"global 브라우저의 window와 같은 전역 객체 역할, 하지만 브라우저와 관련된 객체(document 등)들은 사용하지 못한다. global객체 역시 생략해서 사용 가능하다. 그리고 브라우저의 window객체와 마찬가지로 global에 값을 주입하면 프로젝트 내 모든 파일에서 전역 변수로 사용할 수 있다 . (하지만 이러한 패턴은 지양한다, module을 통해 관리하자)\n1global.console.log(\u0026#34;hello Node!\u0026#34;); 2console.log(\u0026#34;hello Node!\u0026#34;); console 로그를 출력하는 객체, 흔히 사용하는 log, error 말고 신기한 것을 소개한다.\nconsole.time 수행 시점에 time을 찍어 해당 코드를 수행한 시간을 알아낼 수 있다. (효율성 측정에 용이하다.)\n1function add(a, b) { 2 console.timeEnd(\u0026#34;add\u0026#34;); //add: 0.098ms 3 return a + b; 4} 5 6console.time(\u0026#34;add\u0026#34;); 7 8add(1, 3); console.dir 객체 형태의 데이터를 출력하기 용이하다.\n1const fruit ={ 2\tname : \u0026#39;apple\u0026#39;, 3\ticon : \u0026#39;🍎\u0026#39; 4}; 5 6console.dir(fruit); setImmediate 기존 setTimeout을 사용해 초를 0으로 두더라도 비동기 상황에서는 정확한 0초가 아닐 수도 있다. 이벤트 루프 내의 다른 실행 코드가 타임아웃의 순서를 블로킹할 수 있기 때문이다. 따라서 즉시 함수를 출력하려면 setImmediate를 사용하는 것이 유리하다.\n1setImmediate(() =\u0026gt; { 2 console.log(\u0026#34;hi\u0026#34;); 3}); 4 5setImmediate((message) =\u0026gt; { 6\tconsole.log(message); 7}, \u0026#34;hello\u0026#34;); //\u0026#34;hello\u0026#34; 사용 방법은 첫 인자에 실행 함수를 전달하고, 두번째 인자에 함수로 전달할 값을 적어주면된다.\n__filename, __dirname 현재 파일에 대한 경로나 파일명을 반환해준다.\n1const currentFilePath = __filename; 2const currentDirPath = __dirname; 3// file명 포함 4console.log(currentFilePath); // C:\\Users\\user\\Desktop\\node\\test.js 5 6// file 디렉토리명 까지 포함 7console.log(currentDirPath); // C:\\Users\\user\\Desktop\\node this 1module.exports == exports == {} 웹 브라우저 상에서의 this 체계와 조금 다르다. (웹 브라우저에서의 전역 this == window 객체) node.js 상에서는 전역 스코프상에서의 this는 module 객체를 가르킨다. 함수 내부에서의 this는 global 객체를 가르킨다. (나머지 내부함수에서의 this 참조 스코프, 객체에서의 this등 다른 부분에서는 동일하다.)\nrequire 외부 파일 import시에 사용, 파일 맨 상단에 굳이 위치할 필요는 없다. 한번 require한 파일은 require.cache에 저장됨 → 다시 불러올 때 require.cache 탐색 후 해당 js파일을 읽어온다. (캐싱)\n1require(\u0026#39;./module\u0026#39;); //사용은 안하고 스크립트 실행만 하는 경우 2const module = require(\u0026#39;./module\u0026#39;); //변수에 process 현재 실행중인 노드 프로세스에 접근하는 모듈\n version : 노드 버전 platform : 운영체제 정보 pid : 프로세스 id uptime() : 프로세스 시작 후 흐른 시간(second) exePath : 노드 실행 경로 cwd() : 프로세스 실행 위치 env : 환경 변수들이 들어있는 객체 (외부에 노출되면 안되는 정보들을 저장하는 용도로 사용) 1const db_password = process.env.MYSQL_PW;  nextTick() : event loop task queue에서 우선권 부여 (promise then과 같이 micro-taskqueue 우선 처리) exit(0) : node 정상 종료 (exit(1)은 에러가 발생했다는 것을 명시하면서 종료)  OS 운영체제에 대한 정보\n1const osInfo = require(\u0026#39;os\u0026#39;);  arch() : 아키텍쳐 freemem() : 사용가능한 memory 용량 totalmem() : 전체 memory 용량  Path OS마다 다른 디렉토리 경로를 다루기위해 많이 사용 (Windows 또는 POSIX)\n1// /Users/choeseungjin/Mydoc/02_Code/02_JavaScript/backend/process.js 2path.join(__dirname, \u0026#34;..\u0026#34;, \u0026#34;/process.js\u0026#34;); 3// /process.js 4path.resolve(__dirname, \u0026#34;..\u0026#34;, \u0026#34;process.js\u0026#34;);  parse(\u0026lsquo;path..') : 파일 구조 분해 (root-dir-base-ext..) isAbsolute(\u0026lsquo;path\u0026rsquo;) : 절대경로인지 상대경로인지 true/false join(\u0026lsquo;path\u0026rsquo;,\u0026rsquo;..') : 하나의 경로로 합침 (..→ 부모, .→현재 위치 등등) resolve(\u0026lsquo;path\u0026rsquo;, \u0026lsquo;..') : 절대경로(/) 나올 경우 절대경로를 최상위로 표현 https://nodejs.org/dist/latest-v16.x/docs/api/  참고자료  Node.js 교과서 - 노드 내장 모듈 사용하기 (조현영 저) Node.js Docs - 공식 문서  ","date":"2022-01-10T23:19:14+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/useful-modules/","title":"Node.js 자주 사용하는 모듈 정리"},{"content":"npm NodeNode Package Manager, 말 그대로 Node.js 환경에서 여러 모듈들을 패키지화하여 관리하는 저장소 같은 역할이다.\n패키지를 직접 만들어 배포할 수 있고 다른 사람이 배포한 여러 패키지 모듈들을 설치해 프로젝트에 적용시킬 수도 있다.\nnpm 생성하기 npm 환경에서 제일 중요한 것은 패키지 관리이다. 패키지들은 package.json파일에서 일괄적으로 관리하는데 직접 json 파일로 생성해도 되고, 명령어를 입력해 생성해도 된다. 터미널에서 npm init명령어를 입력하면 자동적으로 package.json파일을 생성할 수 있다.\n1npm init 2# \u0026gt; packagename : 프로젝트 이름 입력 3# \u0026gt; version : 프로젝트 버전 입력 (default : 1.0.0) 4# \u0026gt; description : 프로젝트 간단한 설명 5# \u0026gt; entry poin : 자바스크립트 파일 진입 지점 (default : index.js) 6# \u0026gt; test command : 테스트 코드 (코드 실행 및 테스트시 필요한 명령어 입력) 7# \u0026gt; git repository : git 주소  8# \u0026gt; keywords : 패키지 키워드 (npm 패키지 검색 시 사용) 9# \u0026gt; author : 작성자 10# \u0026gt; license : 패키지 라이센스 (default : ISC) *오픈 소스는 대부분 MIT 라이선스를 사용한다. 위와 같이 init 단계를 마치면 프로젝트 경로에 package.json 파일이 생성된다. 생성할 때 test command입력 부분을 건너뛰었다면 아래와 같이 scripts 속성에 기본 값 test로 정의가 되어 있다. scripts 속성은 스크립트 실행 명령어를 여러개 정의할 수 있다. 대표적으로는 해당 프로젝트 실행 파일을 시작하는 명령어를 start로 지정해둔다.\n1{ 2 \u0026#34;name\u0026#34;: \u0026#34;npm-test\u0026#34;, 3 \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, 4 \u0026#34;description\u0026#34;: \u0026#34;practice for npm\u0026#34;, 5 \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, 6 \u0026#34;scripts\u0026#34;: { 7 \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, 8\t\u0026#34;start\u0026#34;: \u0026#34;node index.js\u0026#34; 9 }, 10 \u0026#34;author\u0026#34;: \u0026#34;jinyisland\u0026#34;, 11 \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34; 12} scripts속성에 사용자 지정 명령어를 정의할 수 있는데 해당 프로젝트 터미널에 npm run + command를 입력하면 정의된 스크립트가 실행된다. (예시는 npm run start)\n패키지 설치하기 npm install 명령어는 npm에 올라와있는 패키지를 다운로드 받을 수 있는 명령어이다. 해당 패키지 모듈이 의존하는 여러 패키지들도 같이 다운로드 받는다.\n1# express 패키지 설치 예제 2npm install express 여러 옵션들은 아래를 참고. 자주 사용하는 명령어만 적어놨는데 공식 문서에서 더 많은 명령어를 확인할 수 있다.\n  npm install -g : 전역 설치 (주로 직접 커맨드 환경에서 직접 사용할 패키지들에 사용) → package.json에서 관리하지 않으므로 관리할 때 주의\n  추적이 가능하게 하려면 먼저 install로 설치한 다음, npx명령어로 전역 패키지로 전환할 수 있다.\n1npm i -D nodemon 2npx nodemon node_modules     npm install -S (—save) “package-name”: package.json dependencies 속성에 추가 (npm 5버전부터 기본적으로 install에 적용되어 생략이 가능하다.)\n  npm install -D (—save-dev) “package-name” : package.json devDependencies 속성에 추가 (개발 편의로 설치하는 패키지 모듈은 주로 devDependencies에 설치한다.)\n  npm outdated : 관리중인 패키지의 변화\n  npm dedupe : 중복된 패키지 정리\n  npm update : 패키지 업데이트\n  npm uninstall “package-name”: 패키지 삭제\n  npm search : npm 패키지 검색\n  @version : 특정 버전으로 설치\n  package-lock.json 모듈들을 설치하다보면 package-lock.json파일이 생기는데, 여러 모듈에서 의존하고 있는 다른 패키지 모듈 버전관리를 위해 만들어진 파일이다.\n버전 관리 semver 방식 1\u0026#34;dependencies\u0026#34;: { 2 \u0026#34;express\u0026#34;: \u0026#34;^4.17.2\u0026#34; 3} npm 패키지들은 세자리 숫자로 구성되어 있는데 Semver방식을 따른다고 한다.\n Major : 하위 호환이 되지 않는 업데이트 Minor : 이전 버전과의 하위 호환 Patch : 간단한 버그 수정  알아두면 좋은 표기  ^ : 메이저 버전 하위 호환 (^1.9.6 버전이라면 해당 버전 이하의 1.X.X 버전 패키지들과 호환) ~ : 패치 버전 하위 호환 (~1.9.6 버전이라면 해당 버전 이하의 1.9.X 버전 패키지들과 호환) @latest : 최신 버전 (안정화) @next : 가장 최신 버전 (불안정화)  참고자료  Node.js 교과서 - npm 알아보기 (조현영 저) npm Docs - npm cli  ","date":"2022-01-10T22:40:47+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/npm/","title":"npm에 대한 개념과 사용 방법"},{"content":"Code Convention 프로젝트 진행 시 기능 구현도 중요하지만, 추후 유지보수를 위한 convention도 굉장히 중요하다고 생각한다. 특히 협업으로 작업하는 경우 거의 필수로 작용하는데, 개발자 마다 선호하는 코딩 스타일도 다르고 하물며 변수 명 하나하나 지을 때도 케밥케이스, 카멜케이스 등 여러 방식도 존재하기 때문이다. 물론 개인 프로젝트에서도 이 부분은 꽤나 중요한데 전체적인 일관성이 유지되어야 보는 사람들도 코드를 읽기 편하다. 컨벤션을 잘 지킬 수 있는 플러그인 중 대다수가 사용하는 eslint와 prettier를 vue와 연동해보는 것을 정리해보았다.\n사전 준비 만약 vue-cli를 사용할 경우, vue create 과정에서 eslint, prettier를 같이 설치할 수 있지만 이러한 옵션을 이미 알고 설치하는 경우는 목적에 맞게 진행한 것이기 때문에 아무것도 설치가 안 되어있는 것을 전제로 적용하는 것을 목표로 둔다.\nPrettier 설치 prettier는 코드를 규칙에 따라 일관성 있게 포맷팅해주는 역할을 하는 플러그인이다.\n  먼저 VSCode 확장에서 Prettier를 설치한다.\n  프로젝트 최상위 경로에 .prettierrc.js파일을 생성한다.\nnode 환경의 root는 package.json이 위치한 경로라고 이해하면 된다. 어떤 일관성을 유지 할 것인지 설정을 해주어야하기 때문에 설정 파일을 생성한다.\n1module.exports = { 2 singleQuote: true, //작은 따옴표 사용 (문자열) 3 bracketSpacing: false, //객체 리터럴 공백 제거 4 printWidth: 200, //코드의 블록 너비 5 tabWidth: 4, //개행 단위 6 semi: true, //문장 뒤에 세미클론 붙임 7 arrowParens: \u0026#39;avoid\u0026#39;, //화살표 함수에서 매개변수 괄호 여부 8 trailingComma: \u0026#39;none\u0026#39;//배열, 객체 속성에서 마지막 요소에 컴마 붙이지 않음 9}; 자주 사용하는 옵션을 예시로 들었다. 추가적인 옵션은 Prettier 공식 문서에서 확인 할 수 있다.\n  마지막으로 코드를 저장 할 때마다 포맷팅이 되어야 하니 VS Code settings.json에서 아래의 옵션을 추가한다.\n1//settings.json 2\u0026#34;editor.formatOnSave\u0026#34;: true   간혹 (3) 까지 진행을 하였음에도 불구하고, .vue컴포넌트 파일에서 자동 포맷팅이 안된다면 아래의 옵션도 추가해주자. 주로 Vetur, EsLint 등 다른 포맷팅을 지원해주는 플러그인과 충돌나서 그러는 경우가 많다고 한다.\n1//settings.json 2\u0026#34;[vue]\u0026#34;: { 3 \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; 4},   Eslint 설치 EsLint는 Prettier보다 더 넓은 기능을 갖춘 플러그인이다. 이름 그대로 린트 (문법 검사) 기능은 기본이고, Prettier에서 제공하는 기능인 포맷팅 기능도 자체적으로 지원한다.\n  vue-cli 환경에서 EsLint를 사용하기 위해 아래와 같이 플러그인을 설치한다.\n1npm install --save-dev eslint eslint-plugin-vue   전역 설정을 위해 최상위 경로에 .eslintrc.js파일을 생성한다. 기본 구조는 아래 소스를 참고.\n1//.eslintrc.js 2module.exports = { 3 extends: [ 4 \u0026#39;plugin:vue/vue3-recommended\u0026#39;, //Vue 3.X 버전 권장 규칙 5 // \u0026#39;plugin:vue/recommended\u0026#39; // Vue 2.X 버전을 사용한다면 활성화 6 ], 7 rules: {} 8} extends속성에 여러 규칙들을 기입할 수 있으며 (규칙 ID 여러개로 관리가 가능하다.) 자세한 설명은 eslint-plugin-vue 공식 문서에서 확인할 수 있다.\n  옵션 설정 이 부분은 워낙 방대해 사용하고 있는 설정 기준으로 설명해보자면\n1//.eslintrc.js 2module.exports = { 3 root: true, 4 env: { 5 node: true 6 }, 7 extends: [\u0026#39;plugin:vue/vue3-essential\u0026#39;, \u0026#39;eslint:recommended\u0026#39;, \u0026#39;@vue/prettier\u0026#39;], 8 parserOptions: { 9 parser: \u0026#39;babel-eslint\u0026#39; 10 }, 11 rules: { 12 \u0026#39;no-console\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;warn\u0026#39; : \u0026#39;off\u0026#39;, //콘솔 사용 제한 13 \u0026#39;no-debugger\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;warn\u0026#39; : \u0026#39;off\u0026#39;, //디버거 사용 제한 14 } 15};  root : 최상위 디렉토리 여부 env : 프로젝트 환경 (참고) extends : 사용 할 플러그인 이름 (참고) parserOptions : 구문 분석 옵션  ecmaVersion : ECMA 스크립트 버전 (3, 5, 6, .. , 2022, latest) sourceType : 파서의 출력 형태 parser : parser 선택   rules : 규칙 설정 (참고) 규칙은 다음과 같은 값으로 설정 할 수 있다. (off - 규칙 사용 안함, warn - 경고 규칙, error : 오류 발생)\n이 규칙 설정이 EsLint의 꽃이라 볼 수 있는데 다양한 설정으로 어떤 수준으로 개발자에게 알려줄 지 설정 할 수 있기 때문이다.\n자세한 규칙은 공식 문서를 참고하면 되고 아래와 같이 사용하면된다.  1{ 2 \u0026#34;rules\u0026#34;: { 3 \u0026#34;eqeqeq\u0026#34;: \u0026#34;off\u0026#34;, 4 \u0026#34;curly\u0026#34;: \u0026#34;error\u0026#34;, 5 \u0026#34;quotes\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;double\u0026#34;] 6 } 7}   참고자료  eslint-bea-vue document ESLint - Configuring ESLint  ","date":"2021-12-20T23:49:00+09:00","image":"https://jinyisland.kr/../../assets/vue/vue.png","permalink":"https://jinyisland.kr/post/prettier/","title":"Vue 코드 포맷팅"},{"content":"Vuex vuex는 vue.js에서 컴포넌트들의 상태 관리를 위한 효율적인 라이브러리이다.\nReact의 Flux 이름과 비슷한것을 보면 Flux 패턴에서 차용한 것이라고 한다.\nVuex를 사용하면 좋은 점 기본적으로 vue 생태계에서 컴포넌트 간 여러 정보들을 관리하려면 부모-자식 관계로 데이터들을 넘겨주고 받아야한다. 하지만 현실적으로 복잡한 컴포넌트 관계속에서 계속 주고 받으려면 여러 컴포넌트 파일에서 data 속성을 관리해주어야 하는 단점이 있다. 예를 들어 위 사진처럼 깊은 관계에서 다른 컴포넌트로 데이터를 보내려면 부모 컴포넌트를 계속 찾아 이벤트를 바인딩 시키고 다시 props로 내려주어야 하는 불편함이 있다. 하지만 vuex를 사용하게 된다면 아래와 같은 구조로 더욱 단순하게 작업할 수 있다. store이라는 일종의 중앙 저장소에서 관리할 수 있게 된다.\nVuex 패턴 Vuex에서는 어떤 패턴으로 상태들을 관리하는지 간략하게 설명해보자면, State, View, Actions라는 단방향 패턴 흐름으로 데이터들을 관리한다. 각각의 역할은 다음과 같다.\n state : 컴포넌트 간 공유하는 데이터 속성 (컴포넌트에서의 data 역할) View : 데이터를 표시하는 화면 Actions : 사용자 입력에 따라 데이터를 변경하는 메서드  주요 속성 vuex를 사용하려면 store 인스턴스를 구성해주어야 하는데 state, getters, mutations, actions 총 4개의 속성으로 구성되어 있다. 각각의 역할이 다르며 여러 컴포넌트에서 사용할 상태 값을 정의히고(state) 서버로부터 api 통신을 통해 비동기적으로 받아오거나(actions), 필요에 따라 상태 값들을 변경하고(mutations), 필요한 컴포넌트에게 실시간으로 전달해주는(getters) 역할을 한다.\n1//store.js 2import Vuex from \u0026#39;vuex\u0026#39;; 3export const store = new Vuex.Store({ 4 state: {}, 5 getters: {}, 6 mutations: {} 7 actions: {} 8}); 9 state 컴포넌트 간 공유하는 데이터들을 관리하는 역할이다.\n1state : { 2 message : \u0026#39;hello vuex!\u0026#39; 3} 정의된 상태 값이 필요한 컴포넌트에서는 아래와 같이 받아올 수 있다.\n1\u0026lt;!--component template --\u0026gt; 2\u0026lt;template\u0026gt; 3 \u0026lt;h2\u0026gt;{{this.$store.state.message}}\u0026lt;/h2\u0026gt; 4\u0026lt;/template\u0026gt; getters 연산된 state에 접근해 데이터를 조작하는 역할을 한다. (일종의 computed 역할)\n1state : { 2 hitCount : \u0026#39;\u0026#39;, 3}, 4 5getters : { 6 upHitCount : function(state) { 7 return state.hitCount++; 8 } 9} mutations state값을 변경하는 역할을 한다. (일종의 methods 역할)\n1state : { 2 todoList : [] 3}, 4 5mutations : { 6 setBoardList: function(state, item) { 7 return state.todoList.push(item); 8 }, 9} commit메서드로 호출할 수 있다. (첫 인자에 해당 메서드 이름을 넘기고, 두번째 인자에 데이터를 넘겨준다.)\n1this.$states.commit(\u0026#39;setBoardList\u0026#39;, { 2 id : 1, 3 task : \u0026#39;공부하기\u0026#39; 4}); actions 비동기 처리를 담당한다. 여러 컴포넌트에서 mutations로 비동기 이벤트가 일어나면 수행 시간 차이로 state가 변경될 경우 추적이 어렵기 때문에 actions에 비동기 로직들을 선언하면된다. 예를들어 api 요청, ES6 Async함수(Promise), setTimeout() 등의 로직들을 여기에 선언하면 된다.\ncommit메서드로 mutation 속성내의 메서드에 접근할 수 있으며, 컴포넌트에서 호출할 때는 dispatch메서드로 접근한다.\n1state : { 2 menuList : [] 3}, 4 5mutations : { 6 //state 데이터에 삽입 7 setMenuList: function(state, list) { 8 return state.menuList = list; 9 } 10}, 11 12actions : { 13 //api 요청 14 requestMenuList: function(state) { 15 axios.get(\u0026#39;/category/list\u0026#39;).then(function (response) { 16 state.commit(\u0026#39;setMenuList\u0026#39;, response.data.items); 17 }); 18 } 19} 1//vue-component 2created() { 3 this.$store.dispatch(\u0026#39;requestMenuList\u0026#39;); 4} 실습 사실 Vuex가 힘을 발휘하는 순간은 복잡한 대규모 웹 애플리케이션이지만.. 문법을 사용해보는 취지로 글쓰기-게시판 형태의 단순한 페이지로 문법을 익혀보았다. 간단히 내용을 입력하는 컴포넌트와 이를 출력해주는 컴포넌트로 구성되어 있는 페이지이다. Vuex 설치하기 먼저 vuex 라이브러리를 설치한다.\n1npm install vuex store 인스턴스 생성 store 인스턴스를 정의해주는 단계이다. 보통 프로젝트 폴더에서 src\\store디렉토리를 만들어서 여러 store들을 관리한다.\n(이번 포스팅에서는 store 1개로 관리하지만, 복잡한 웹 페이지에서는 여러 store로 모듈화할 수 있다.)\n위 구현 사진에서 write 버튼을 누르면 글을 입력하는 컴포넌트 (팝업)이 켜졌다가 글을 입력하면 꺼지는 동작이 필요하기 때문에 popupFlag라는 상태 값을 정의하였고, 게시글을 관리 할 boardList 배열도 정의하였다.\n1// src\\store\\store.js 2import Vuex from \u0026#39;vuex\u0026#39;; 3//vuex 4export const store = new Vuex.Store({ 5 state: { 6 boardList: [], //게시글 배열 7 popupFlag: false //true : 팝업창 열림, false : 꺼짐 8 }, 9 getters: {}, 10 mutations: {} 11 actions: {} 12}); mutations에는 팝업 상태를 관리하는 이벤트와 게시글을 넣어주는 이벤트가 필요하기 때문에 필요한 메서드들을 정의하였다.\n(외부 서버 통신이 필요하지 않기 때문에 actions를 생략하였고, 단순히 값만 주고받는 흐름이기 때문에 getters도 생략..ㅎㅎ)\n1import Vuex from \u0026#39;vuex\u0026#39;; 2//vuex 3export const store = new Vuex.Store({ 4 state: { 5 boardList: [], //게시글 배열 6 popupFlag: false //true : 팝업창 열림, false : 꺼짐 7 }, 8 9 mutations: { 10 setBoardList: function(state, item) { 11 state.popupFlag = false; 12 return state.boardList.push(item); 13 }, 14 15 onPopup: function(state) { 16 return (state.popupFlag = true); 17 }, 18 19 offPopup: function(state) { 20 return (state.popupFlag = false); 21 } 22 } 23}); 24 이제 설치한 vuex와 정의한 store 인스턴스를 vue에 등록해야하는데 main.js에 등록해주면 된다.\n1import { createApp } from \u0026#39;vue\u0026#39;; 2import Vuex from \u0026#39;vuex\u0026#39;; 3import { store } from \u0026#39;./store/store\u0026#39;; 4import App from \u0026#39;./App.vue\u0026#39;; 5 6const vuexApp = createApp(App); 7vuexApp.use(Vuex); 8vuexApp.use(store); 9vuexApp.mount(\u0026#39;#app\u0026#39;); 10 state 값 받아오기 예습 프로젝트에서 컴포넌트 구조는 게시글을 보여주는 메인 컴포넌트와 게시글을 입력하는 팝업 컴포넌트로 구성되어 있다. 팝업 컴포넌트는 popupFlag가 on 일 때 보여주어야 하므로 아래와 같이 클래스 바인딩을 해주면 된다. 핵심은 store에 접근할 때 $store키워드로 접근한다는 점이다.\n1\u0026lt;template\u0026gt; 2 \u0026lt;!-- popupFlag가 true일 때 hide 클래스 바인딩 --\u0026gt; 3 \u0026lt;section class=\u0026#34;write-wrap\u0026#34; v-bind:class=\u0026#34;{hide : !this.$store.state.popupFlag}\u0026#34;\u0026gt; 4 \u0026lt;!-- popup 마크업 --\u0026gt; 5 \u0026lt;/section\u0026gt; 6\u0026lt;/template\u0026gt; mutations 메서드 호출하기 만약 글쓰기를 취소할 때에도 popupFlag를 변경해야하는데 togglePopup 메서드에서 헬퍼로 offPopup을 호출한다. 갑자기 스프레드 연산자가 나와서 당황스럽게지만, vuex에서는 헬퍼 함수라는 기능이 있어 컴포넌트에서 더욱 쉽게 vuex 속성에 접근하는 기능을 제공한다.\n1\u0026lt;!-- template --\u0026gt; 2\u0026lt;div class=\u0026#34;article-button\u0026#34;\u0026gt; 3 \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;cancel\u0026#34; v-on:click=\u0026#34;togglePopup\u0026#34;\u0026gt;cancel\u0026lt;/button\u0026gt; 4\u0026lt;/div\u0026gt; 컴포넌트에서 store에 정의된 mutations에 접근하려면 this.$store.commit('offPopup')을 단순히 호출만 하는 메서드를 하나 생성해야하는데 헬퍼를 사용하면 삼항연산자로 mutations에 이미 존재하는 메서드를 그대로 가져올 수 있어서 편하다. 호출 key만 정해주면 된다.\n1// popup component script 2import {mapMutations} from \u0026#39;vuex\u0026#39;; 3export default { 4 methods: { 5 ...mapMutations({ 6 sendMessage : \u0026#39;setBoardList\u0026#39;, 7 togglePopup : \u0026#39;offPopup\u0026#39; 8 }), 9 } 10} 실제로 글을 등록하는 버튼에도 mutations에 정의된 setBoardList()메서드를 연결 해주어야 한다.\n1\u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;write\u0026#34; v-on:click=\u0026#34;sendMessage(this.constructMessage())\u0026#34;\u0026gt;send\u0026lt;/button\u0026gt; 1import {mapMutations} from \u0026#39;vuex\u0026#39;; 2export default { 3 data() { 4 return { 5 id : \u0026#34;\u0026#34;, 6 message : \u0026#34;\u0026#34; 7 } 8 }, 9 methods: { 10 ...mapMutations({ 11 sendMessage : \u0026#39;setBoardList\u0026#39;, 12 togglePopup : \u0026#39;offPopup\u0026#39; 13 }), 14 15 constructMessage: function () { 16 return { 17 date : new Date().toISOString().substr(0, 10).replace(/-/g, \u0026#39;\u0026#39;), 18 id : this.id, 19 message : this.message 20 } 21 }, 22 } 23} 메인 컴포넌트에서 boardList를 출력해주고 있었다면 잘 받아와지는 모습을 볼 수 있다.\n1\u0026lt;template\u0026gt; 2 \u0026lt;main v-bind:class=\u0026#34;{popup : this.$store.state.popupFlag}\u0026#34;\u0026gt; 3 \u0026lt;h2 class=\u0026#34;hide\u0026#34;\u0026gt;Recent POST\u0026lt;/h2\u0026gt; 4 \u0026lt;ol class=\u0026#34;list\u0026#34;\u0026gt; 5 \u0026lt;li class=\u0026#34;post-list\u0026#34; v-for=\u0026#34;(item) in this.$store.state.boardList\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; 6 \u0026lt;details\u0026gt; 7 \u0026lt;summary\u0026gt;{{item.message}}\u0026lt;/summary\u0026gt; 8 \u0026lt;p\u0026gt;{{item.message}}\u0026lt;/p\u0026gt; 9 \u0026lt;/details\u0026gt; 10 \u0026lt;div class=\u0026#34;post-info\u0026#34;\u0026gt; 11 \u0026lt;p\u0026gt;\u0026lt;span class=\u0026#34;author\u0026#34;\u0026gt;{{item.id}}\u0026lt;/span\u0026gt; | \u0026lt;span class=\u0026#34;date\u0026#34;\u0026gt;{{formatDate(item.date)}}\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; 12 \u0026lt;/div\u0026gt; 13 \u0026lt;/li\u0026gt; 14 \u0026lt;/ol\u0026gt; 15 \u0026lt;/main\u0026gt; 16\u0026lt;/template\u0026gt; 이번 예제의 전체 소스는 이곳에서 확인하실 수 있습니다!\n참고자료  캡틴판교님의 Vue 중급 강의 What is Vuex  ","date":"2021-12-03T16:10:08+09:00","image":"https://jinyisland.kr/../../assets/vue/vue.png","permalink":"https://jinyisland.kr/post/vuex/","title":"Vuex 개념과 실제 사용해보기!"},{"content":"tailwind? tailwind는 CSS 프레임워크이다. 사용방법은 공식 문서를 보면 잘 나와있다. 기본적으로 태그 내에 inline형태로 클래스 형태로 스타일을 입히는 방식이다. 기존 css로 작업했을 때와 tailwind를 사용했을 때를 비교해 보자면 다음과 같다.\n  브라우징 최적화\nautoprefixer를 내장해서 사용하고 있기 때문에, 브라우저별로 상이한 스타일 문제로 골머리를 앓지 않아도 된다.\n  클래스 기반 스타일 tailwind 기본 사용법은 태그 내에 클래스로 스타일을 입히는 방식이다. 예를 들어 특정 태그에 배경색을 입히려면 아래와 같이 작성한다. 클래스 명도 이해하기 쉽도록 구성되어 있기 때문에 대충 이름만 봐도 어떠한 역할인지는 파악이 된다.\n1\u0026lt;p class=\u0026#34;bg-green-300\u0026#34;\u0026gt;light green.\u0026lt;/p\u0026gt; 하지만 매번 태그에 중복된 스타일을 입히게 되면 나중엔 태그 클래스가 너무 길어져 가독성이 떨어지는 건 단점이 되기도 한다.\n  편리한 커스터마이징\ntailwind는 맞춤형 사용자 인터페이스를 지향하는 프레임워크이기 때문에, 사용자가 커스텀하기 쉽게 구성되어있다.\ntailwind.config.js파일을 생성해 사용자가 원하는대로 다시 구성할 수 있다.\n1//사용자 지정 breack point 2module.exports = { 3 theme: { 4 screens: { 5 \u0026#39;sm\u0026#39;: \u0026#39;640px\u0026#39;, 6 \u0026#39;md\u0026#39;: \u0026#39;768px\u0026#39;, 7 \u0026#39;lg\u0026#39;: \u0026#39;1024px\u0026#39;, 8 \u0026#39;xl\u0026#39;: \u0026#39;1280px\u0026#39;, 9 \u0026#39;2xl\u0026#39;: \u0026#39;1536px\u0026#39;, 10 } 11 } 12}   tailwindCSS 설치 먼저 tailwindcss 의존한 라이브러리들을 설치한다. 참고로 최소 node 환경은 12.13.0이상이다.\nvue 프로젝트를 먼저 생성하고, tailwind-css를 설치한다.\n1npm install -D tailwindcss@latest postcss@latest autoprefixer@latest 공식사이트에서는 아래와 같이 모든 종속 라이브러리들을 최신 버전으로 설치하라고 가이드되어 있지만 postcss 버전이 문제가 되는 거같아 아래와 같이 설치하였더니 오류가 해결되었다.\n1npm install tailwindcss@npm:@tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9 tailwind 설정 파일을 생성한다. 아래 명령어를 입력하면 프로젝트 루트에 tailwind.config.js파일이 만들어지는데, 해당 파일에서 사용자 입맛에 맞게 여러 스타일을 초기화할 수 있다.\n자세한 내용은 configuration 공식 문서 참고!\n1npx tailwindcss init -p 공식 가이드에 따르면, 사용하지 않는 스타일 용량 최적화를 위해 purge옵션은 작성하라고 권고하고 있다.\n1// tailwind.config.js 2 module.exports = { 3 purge: [\u0026#39;./index.html\u0026#39;, \u0026#39;./src/**/*.{vue,js,ts,jsx,tsx}\u0026#39;], 4 darkMode: false, // or \u0026#39;media\u0026#39; or \u0026#39;class\u0026#39; 5 theme: { 6 extend: {}, 7 }, 8 variants: { 9 extend: {}, 10 }, 11 plugins: [], 12 } 이제 설정한 tailwind css파일을 전역으로 import 해주면 된다.\nmain.js에 import해주면 사용준비는 끝, 이제 문서를 보면서 스타일링을 해주면 된다.\n1import {createApp} from \u0026#39;vue\u0026#39;; 2import \u0026#39;tailwindcss/tailwind.css\u0026#39;; 3import App from \u0026#39;./App.vue\u0026#39;; 4 5createApp(App).mount(\u0026#39;#app\u0026#39;); tailwind IntelliSense 혹시 vscode로 vue를 개발하는 상황이라면 Tailwind CSS 인텔리센스 익스텐션을 적극 추천!!\n클래스를 사용할 때 마다 자동완성이 지원되서 작성 시간을 확 줄일 수 있다.\n색상같은 경우도 바로 눈으로 확인할 수 있어 확실히 편하다.\ntailwind Components tailwind components는 커뮤니티 형식으로 자신이 만든 여러 컴포넌트 CSS를 공유하는 사이트이다. button, modal 등 컴포넌트 종류에 따라 퀄리티 있는 여러 컴포넌트가 공개되어 있다. 필요에 따라 단순히 템플릿에 가져다 붙여도 사용해도 좋고, 아직 tailwind 사용법에 대한 감이 잘 오지 않는다면 참고해서 클론 해보는 것도 좋은 방법인 것 같다.\n","date":"2021-10-21T23:05:04+09:00","image":"https://jinyisland.kr/../../assets/vue/vue.png","permalink":"https://jinyisland.kr/post/vue-tailwind/","title":"Vue에 Tailwind CSS 적용하기"},{"content":"힙 정렬 완전 이진트리에서 파생된 heap 특성을 사용하여 정렬하는 알고리즘, 힙은 부모의 값이 자식의 값보다 항상 크거나 항상 작다라는 조건을 만족하는 완전이진트리 형태의 자료구조이다.\n완전이진트리는 자식 노드를 왼쪽부터 채워나가는 형태의 자료구조이다. 힙의 개념 완전이진트리와의 차이점은 큰 값이 상위, 작은 값이 하위에 위치한 트리형 자료구조로써 부모-자식 관계가 일정해야한다. 작은 값이 부모가 되는 힙 형태를 min-heap(최소 힙), 큰 값이 부모가 되는 트리 구조를 max-heap(최대 힙)이라고 한다. 힙은 다음과 같은 관계를 가지고 있어야한다.\n 부모 → a[ ( i - 1) / 2] 왼쪽 자식 → a[i * 2 + 1] 오른쪽 자식 → a[ i * 2 + 2]  동작 과정 힙의 특성을 이용해 정렬을 구현하는 방법은 다음과 같다.\n  배열을 이등분하여 좌측 요소부터 1씩 감소시키면서 heap 형태로 변환한다.\n1for (let i = Math.floor(tempArray.length / 2) - 1; i \u0026gt;= 0; i--) { 2 heap(tempArray, length, i); 3}   (1)의 과정을 수행하면, 이등분의 left부분은 heap 상태가 되어지면서 정렬 상태가 되어있을 것이다. 배열의 첫번째 요소(가장 큰 값)와 정렬되지 않은 우측 요소부터 heap 형태로 변환하는 과정을 반복한다.\n1for (let i = tempArray.length - 1; i \u0026gt; 0; i--) { 2 swap(tempArray, 0, i); //가장 큰 요소와 정렬되지 않은 마지막 요소와 교환 3 length--; 4 heap(tempArray, length, 0); //배열의 나머지 부분들을 heap상태로 만들며 정렬 과정 수행 5}   heap 형태로 변환하는 소스는 다음과 같다. 이진 트리 형태로 배열을 받으면서, root요소를 자식 요소의 값에 따라 계속 바꾸어주는 방식이다.\n1/** 2* heapify 메서드 3* @param {array} heapArray : heap으로 변환 할 배열 4* @param {number} length : 배열 길이 5* @param {number} parent : 부모 인덱스 6*/ 7function heap(heapArray, length, parent) { 8 const left = parent * 2 + 1; 9 const right = left + 1; 10 let root = parent; 11 //좌측 요소가 부모 값 보다 크면 부모 인덱스를 left 인덱스로 대입 12 if (left \u0026lt; length \u0026amp;\u0026amp; heapArray[left] \u0026gt; heapArray[root]) { 13 root = left; 14 } 15 16 //우측 요소가 부모 값 보다 크면 부모 인덱스를 right 인덱스로 대입 17 if (right \u0026lt; length \u0026amp;\u0026amp; heapArray[right] \u0026gt; heapArray[root]) { 18 root = right; 19 } 20 21 //부모 요소가 자식 요소와 바꾸어 졌으면 swap처리 및 heap 재검사 22 if (root !== parent) { 23 swap(heapArray, parent, root); 24 heap(heapArray, length, root); 25 } 26}   자바스크립트로 구현한 HeapSort 1function heapSort(array) { 2 /** 3* 요소 swap 메서드 4* @param {array} swapArray : swap 대상 배열 5* @param {number} a : 교체 대상 인덱스 6* @param {number} b : 교체 인덱스 7*/ 8 function swap(swapArray, a, b) { 9 const temp = swapArray[a]; 10 swapArray[a] = swapArray[b]; 11 swapArray[b] = temp; 12 } 13 14 /** 15* heapify 메서드 16* @param {array} heapArray : heap으로 변환 할 배열 17* @param {number} length : 배열 길이 18* @param {number} parent : 부모 인덱스 19*/ 20 function heap(heapArray, length, parent) { 21 const left = parent * 2 + 1; 22 const right = left + 1; 23 let root = parent; 24 //좌측 요소가 부모 값 보다 크면 부모 인덱스를 left 인덱스로 대입 25 if (left \u0026lt; length \u0026amp;\u0026amp; heapArray[left] \u0026gt; heapArray[root]) { 26 root = left; 27 } 28 29 //우측 요소가 부모 값 보다 크면 부모 인덱스를 right 인덱스로 대입 30 if (right \u0026lt; length \u0026amp;\u0026amp; heapArray[right] \u0026gt; heapArray[root]) { 31 root = right; 32 } 33 34 //부모 요소가 자식 요소와 바꾸어 졌으면 swap처리 및 heap 재검사 35 if (root !== parent) { 36 swap(heapArray, parent, root); 37 heap(heapArray, length, root); 38 } 39 } 40 41 /** 42* 정렬 메서드 43* @param {array} tempArray : 정렬 대상 배열 44* @returns 45*/ 46 function sort(tempArray) { 47 let length = tempArray.length; 48 if (length === 1) { 49 return tempArray; 50 } else { 51 //배열을 이등분하여 좌측 요소들을 heap 형태로 변환 52 for (let i = Math.floor(tempArray.length / 2) - 1; i \u0026gt;= 0; i--) { 53 heap(tempArray, length, i); 54 } 55 56 for (let i = tempArray.length - 1; i \u0026gt; 0; i--) { 57 swap(tempArray, 0, i); //가장 큰 요소와 정렬되지 않은 마지막 요소와 교환 58 length--; 59 heap(tempArray, length, 0); //배열의 나머지 부분들을 heap상태로 만들며 정렬 과정 수행 60 } 61 return tempArray; 62 } 63 } 64 65 return sort(array); 66} 67const unsorted = [5, 1, 3, 4, 2, 9, 7, 8]; 68console.log(heapSort(unsorted)); //[1, 2 ,3 ,4 ,5] 참고자료  자료구조와 함께 배우는 알고리즘 입문 - 검색 알고리즘 (Bohyoh Shibata 저) Heap Sort Solution In JavaScript (in-depth) - By. Mono Li  ","date":"2021-10-16T23:24:14+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/algorithm-heap/","title":"힙의 개념과 힙 정렬 알고리즘"},{"content":"vue에서 data 속성에 있는 값을 사용하고자 할 때, 값이 변화할 때 마다 자동적으로 리렌더링 해주는 인스턴스 속성이 2개가 있다. 바로 computed와 watch, 이 두 속성의 공통점은 값을 감지하다가 변경되면 메서드를 호출함으로써 값을 바로 반환해준다. 이 비슷한 두 속성에 대해 차이점에 대해서 알아보았다.\ncomputed 사용법은 아래 코드를 참고, computed속성 내에 메서드를 정의하고 템플릿내에 호출을 하면 해당 값이 바뀔 때 마다 재호출을 해준다. 이는 캐싱이되는 성질이 있어 해당 값이 바뀌지 않는다면 호출을 절대 하지 않는다.\n1 \u0026lt;template\u0026gt; 2 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 3 \u0026lt;p\u0026gt; {{ formatDate }} \u0026lt;/p\u0026gt; \u0026lt;!--2021년 10월 08일 --\u0026gt; 4 \u0026lt;/div\u0026gt; 5 \u0026lt;/template\u0026gt; 6 \u0026lt;script\u0026gt; 7 export default { 8 data(){ 9 return { 10 today : \u0026#39;20211008\u0026#39; 11 } 12 }, 13 computed : { 14 formatDate : function(){ 15 return `${date.substr(0,4)}년 ${date.substr(4,2)}월 ${date.substr(6,2)}일`; 16 } 17 } 18 } 19 \u0026lt;/script\u0026gt; watch watch도 computed와 사용법은 유사하다. 하지만 watch는 메서드 트리거의 역할로 사용하는 느낌이 더욱 강하다. computed는 직접 template내에 출력을 해야 해당 메서드가 실행되지만, watch는 값의 변화에만 의존해 메서드를 호출 시키기 때문이다. 웬만한 데이터 포맷팅이나 단순히 보여지는 영역을 컨트롤해야 한다면 computed를 사용하고 더욱 복잡한 로직 (API 통신 및 data 분기 처리)등은 watch를 사용하는 것을 권장하고 있는 것 같다.\n1 \u0026lt;template\u0026gt; 2 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 3 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;increase\u0026#34; v-on:click=\u0026#34;increaseNumber\u0026#34;\u0026gt; 4 \u0026lt;p id=\u0026#34;log\u0026#34;\u0026gt;{{ number }}\u0026lt;/p\u0026gt; 5 \u0026lt;/div\u0026gt; 6 \u0026lt;/template\u0026gt; 7 \u0026lt;script\u0026gt; 8 export default{ 9 data(){ 10 return { 11 number : 0 12 } 13 }, 14 watch: { 15 number: function(){ 16 if(this.number \u0026gt;= 10){ 17 alert(\u0026#34;10 이상 입니다!\u0026#34;); 18 } 19 } 20 }, 21 methods:{ 22 increaseNumber: function(){ 23 return this.number++; 24 } 25 } 26 } 27 \u0026lt;/script\u0026gt; 참고자료  Computed Props and Watchers — What\u0026rsquo;s the Difference? - Michael Thissen Computed 속성과 Watch - Vue School  ","date":"2021-10-09T23:17:34+09:00","image":"https://jinyisland.kr/../../assets/vue/vue.png","permalink":"https://jinyisland.kr/post/computed-watch/","title":"computed와 Watch"},{"content":"Http http 트랜잭션에는 상태가 없다. 모든 사용자 요청에는 사이트 기능에 맞는 상태들을 유지하는데 (사용자 정보, 권한 등등..) 이런 무수히 많은 상태들을 관리하려면 사용자를 식별할 수 있는 방법이 필요하다. 그중에 하나가 쿠키이다. 물론 사용자를 가릴 수 있는 방법에 초창기 여러 가지 방법이 있었는데 사용자 IP를 활용한 방법 등이 있었다. IP를 활용한 방법에는 다음과 같은 문제점이 있다.\n 사용자 기준이 아닌 접속 PC의 IP이기 때문에 정확한 사용자 구별이 어려움 ISP가 제공하는 IP 대역을 사용하는 경우, 대부분 매번 다른 주소를 받으므로 추후 식별이 어려움 NAT 장비 등, 보안을 위해 IP 주소를 private 하게 관리 → 서버에서 받는 사용자 IP가 실제 IP가 아닐 수 있음  위와 같은 문제점으로, IP를 활용한 방식보다 아예 사용자 마다의 인증 프로세스를 부여하여 명확한 식별 요청을 할 수 있는데 이 기능이 바로 우리가 흔히 접하는 로그인 기능\nCookie 쿠키는 사용자를 식별하고 세션을 유지시키는 방식 중에서 널리 사용되고 있는 방식이다. 유효 기간이 있으며 key와 value으로 이루어져 있다.\n동작방식 사용자가 처음 웹 사이트에 방문하면 서버는 사용자가 어떤 사용자인지 전혀 알지 못한다. 해당 사용자가 다시 웹 사이트에 방문할 때 해당 사용자가 어떤 사용자인지 식별하기 위해 서버에서는 응답 헤더에 쿠키 값을 할당한다. 형식은 다음과 같다.\nCookie: userName=\u0026quot;jiny\u0026quot;; auth=\u0026quot;1\u0026quot; 이제 브라우저(클라이언트)에서는 응답 헤더에서 쿠키 컨텐츠를 브라우저 쿠키 데이터베이스에 저장시킨다. 이는 Chrome 기준이며 각 브라우저별로 쿠키 보관 방식이 다르다.\n  chrome : sqlite local DB에 Cookies라는 테이블에 쿠키 정보 저장\n해당 테이블은 아래 필드로 이루어져 있다.\n host_key : 쿠키 도메인 name : 쿠키 이름 value : 쿠키 값 path : 쿠키 도메인 경로 expire_utc : 만료 시점 (UTC 기준 초 단위)    Internet Explorer : 캐시 디렉토리에 개별 파일로 쿠키 저장\n  세션 쿠키와 지속 쿠키 세션 쿠키는 사용자가 브라우저를 닫으면 삭제되며, 지속 쿠키는 사용자 PC 드라이브에 저장되어 재시작해도 살아있다.\n(Discard 파라미터 또는 만료시간 등이 설정되지 않은 쿠키는 기본적으로 세션 쿠키로 설정된다.)\nCookie 주고받기 node.js를 사용한 간단한 쿠키 주고받는 소스이다.\nsingup이라는 POST 요청이 들어오면, 클라이언트에서 전송한 사용자 ID를 바로 쿠키에 set 해서 응답한다. 브라우저에서는 해당 쿠키를 저장하고 다음 요청부터는 Request Headers에 쿠키를 삽입해서 서버로 전송한다. 주의할 점은 한글 문자열을 사용할 때 encodeURIComponent와 decodeURIComponent로 변환 해주는 과정이 필요하다.\nSetCookie 1const http = require(\u0026#34;http\u0026#34;); 2 3http.createServer(async (request, response) =\u0026gt; { 4const method = request.mtehod; 5const url = request.url 6 7if(method === \u0026#34;POST\u0026#34; \u0026amp;\u0026amp; url === \u0026#34;/signup\u0026#34;){ 8\tlet body = \u0026#34;\u0026#34;; 9\trequest.on(\u0026#34;data\u0026#34;, (data)=\u0026gt;{ 10\tbody += data; 11\t}); 12 13\treturn request.on(\u0026#34;end\u0026#34;, ()=\u0026gt;{ 14\tconst result = { 15\tresult: true, 16\tmessage: \u0026#34;success\u0026#34;, 17\t}; 18\tbody = JSON.parse(body); 19\t//응답 헤더에 쿠키 설정 20\tresponse.writeHead(200, { 21\t\u0026#34;content-Type\u0026#34;:\u0026#34;Application/json; charset=utf-8\u0026#34;, 22\t\u0026#34;Set-Cookie\u0026#34;: `user-id=${encodeURIComponent(body.id)}`, 23\t}); 24\tresponse.end(JSON.stringify(result)); 25\t}); 26}})}).listen(8088, () =\u0026gt; { 27 store.logger(\u0026#34;log\u0026#34;, \u0026#34;POST BOX START!!!!!\u0026#34;); 28});; 29 getCookie 이제 클라이언트에서 쿠키를 포함한 요청을 보내면 서버 측에서도 쿠키를 식별해야 한다.\n아쉽게도 node.js에서는 쿠키 값을 빼내올 함수가 따로 존재하지 않는다. request.headers.cookie에 쿠키 정보는 확인할 수 있지만 원하는 쿠키 값을 찾으려면 직접 함수로 구현해야 한다. 여러 책이나 자료에서도 찾을 수 있지만, 한번 cookie 구조 파악 겸 직접 작성해 보았다.😅\n1//쿠키 형식(request.headers.cookie) : _ga=GA1.1.55873572.1627649409; _ga_6TN7PCJZTQ=GS1.1.1631890653.16.1.1631891304.0; user-id=asddsa 2const getCookie = (cookies, key) =\u0026gt; { 3 const cookieArray = cookies.split(\u0026#34;;\u0026#34;); 4 let value = \u0026#34;\u0026#34;; 5 cookieArray.forEach((element) =\u0026gt; { 6 if (element.split(\u0026#34;=\u0026#34;)[0].trim() === key) { 7 return (value = element.split(\u0026#34;=\u0026#34;)[1]); 8 } 9 }); 10 return value.length ? decodeURIComponent(value) : value; 11}; 해당 함수를 바탕으로 원하는 쿠키 값이 있는지 확인할 수 있다.\n1if (method === \u0026#34;POST\u0026#34; \u0026amp;\u0026amp; url === \u0026#34;/write\u0026#34;) { 2\t//쿠키 값 탐색 3\tconst userId = getCookie(request.headers.cookie, \u0026#34;user-id\u0026#34;); 4\tlet body = \u0026#34;\u0026#34;; 5\t//쿠키 값 존재시 해당 사용자 ID, 아니면 익명 ID로 값 저장 6\tlet writer = userId.length ? userId : \u0026#34;anonymous\u0026#34;; 7\trequest.on(\u0026#34;data\u0026#34;, (data) =\u0026gt; { 8\tbody += data; 9\t}); 10\t11\treturn request.on(\u0026#34;end\u0026#34;, () =\u0026gt; { 12\tif (body.length) { 13\tbody = JSON.parse(body); 14\tstore.boardlist.push({ 15\ttitle: body.title, 16\tcontext: body.context, 17\twriter: writer, 18\twriteDate: new Date().toISOString().substr(0, 10), 19\t}); 20\t21\t//응답 성공 시 메인 화면으로 redirect 22\tresponse.writeHead(302, { 23\tLocation: \u0026#34;/\u0026#34;, 24\t}); 25\tresponse.end(); 26\t} else { 27\tresponse.writeHead(500, { \u0026#34;content-Type\u0026#34;: \u0026#34;Application/json; charset=utf-8\u0026#34; }); 28\tresponse.end( 29\tJSON.stringify({ 30\tresult: false, 31\tmessage: \u0026#34;NOT Value\u0026#34;, 32\t}) 33\t); 34\t} 35\t}); 36} 여러옵션 Expire 유효기간을 설정해야 지속 쿠키로 사용할 수 있다. Expires키로 설정할 수 있고 GMTString 형태로 변환해 전송해야 한다.\n만약 초를 입력하려면 Max-age=3000형태로 Max-age키를 사용해야 한다.\n1const minute = 10; 2const expireTime = new Date(); 3expireTime.setMinutes(expireTime.getMinues() + minute); 4 5response.writeHead(200, { 6\t\u0026#34;Set-Cookie\u0026#34;: `Expires=${expireTime}`, 7}); HttpOnly 스크립트로 접근할 수 없음, 로그인 등 보안이 필요한 요청에 필수적으로 사용 권장하며 조작을 방지할 수 있다.\n1\u0026#34;Set-Cookie\u0026#34;: \u0026#34;name=test; HttpOnly;\u0026#34; Path 해당 경로 이하 도메인에 쿠키 사용, 예를들어 Path = /user라면, /user 하위의 도메인에만 쿠키를 사용한다. (root 도메인에선 쿠키 사용 안함)\n1\u0026#34;Set-Cookie\u0026#34;: \u0026#34;name=test; HttpOnly Path=/;\u0026#34; Domain 쿠키가 전송될 도메인을 지정한다. (default 값은 현재 도메인)\nSecure HTTPS일 경우에만 쿠키가 전송된다.\n정리 이렇게 쿠키에 대해서 정리를 해보았다. 쿠키는 용도가 명확하다, 어떤 사용자인지 쉽게 식별할 수 있고 도메인 내에서 쿠키 권한을 각각 다르게 함으로써 분기 처리도 쉽게 할 수 있다.\n만약 로그인 기능을 구현한다면 로그인했을 때 해당 사용자가 어떠한 권한이 있는지, 해당 사용자의 로그인 기간은 얼마나 줄 것인지 이렇게 사용자 식별을 위해 도입된 로그인 기능을 좀 더 세밀하게 사용할 수 있다. 물론 브라우저와 디스크에 저장되기 때문에 예민한 정보들은 사용자가 알아볼 수 없도록 내부 키값을 따로 지정해 사용하는 등 여러 고민들도 해봐야 할 것 같다.\n참고 자료  HTTP 완벽 가이드 - 클라이언트 식별과 쿠키 Node.js 교과서 - 쿠키와 세션 이해하기 (조현영 저)  ","date":"2021-09-20T18:49:47+09:00","image":"https://jinyisland.kr/../../assets/web/web.png","permalink":"https://jinyisland.kr/post/cookies/","title":"Http 쿠키의 개념과 활용 방법"},{"content":"Node.js HTTP 모듈을 통해 간단히 요청보내고, 주고받는 초간단 API 서버를 만들어보았다.\nRequest createServer 콜백에서 request, response 인자를 받는데 request 객체에서 요청 정보들을 받을 수 있다.\n1const http = require(\u0026#34;http\u0026#34;); 2 3http.createServer(async (request, response)=\u0026gt;{ 4\ttry{ 5\tconst method = request.method; 6\tconst url = request.url; 7\t//step 1. 요청 메소드 구분 8\tif(method == \u0026#34;GET\u0026#34;){ 9\t//step 2. URL 구분 10\tif(url == \u0026#34;/\u0026#34;){ 11\t}else if(url == \u0026#34;/list\u0026#34;){ 12\t} 13\t}else if(method == \u0026#34;POST\u0026#34;){ 14\t//code.. 15\t}else if(method == \u0026#34;DELETE\u0026#34;){ 16\t} 17\t} catch { 18\t//step 3. 예외처리 (404, 500..) 19\t} 20}).listen(8080);  Method : request.method url : request.url  script 및 css 부끄럽게도 나는 html 파일에서 스크립트와 css경로만 적어주면 알아서 갖고오겠지?? 라고 안일하게 생각했다.\n계속 못받아오길래 직접 로그로 띄워본 결과(아래 참고).. css, html 파일도 계속 request를 하는데 파일이 없으니 404 응답을 해주고있었다. (생각해보니 스프링에서도 context 경로 일일이 설정했다..😅)\n../frontend/resources/css/style.css ../frontend/resources/css/board.css [👻 LOGGER][method : GET, url : /resources/js/pagination.js] [👻 LOGGER][method : GET, url : /resources/js/board.js] ../frontend/resources/js/pagination.js ../frontend/resources/js/board.js [👻 LOGGER][method : GET, url : /list] [👻 LOGGER][method : GET, url : /favicon.ico] 모든 리소스를 정적으로 일일이 구성하기에는 관리도 어렵고 부담스럽다.. url 경로를 동적으로 받아오면 된다!\n1try { 2 const resource = await fs.readFile(`../frontend${url}`); 3 console.log(`../frontend${url}`); 4 return response.end(resource); 5} catch (error) { 6 const notFoundView = await fs.readFile(\u0026#34;../frontend/html/notFound.html\u0026#34;).catch((err) =\u0026gt; { 7 return store.logger(\u0026#34;error\u0026#34;, err); 8 }); 9 response.writeHead(404, { \u0026#34;content-Type\u0026#34; : \u0026#34;text/html; charset=utf-8\u0026#34;}); 10 return response.end(notFoundView); 11} Response 이제 반대로 응답을 내려줄려면 response 객체를 활용하면된다.\nwriteHead메서드로 상태코드와 HTTP ContentType을 명시해주면되고 추가적으로 인코딩을 위해 charset도 정의해주면 좋다. (UTF-8 권장)\n1//http 상태코드, http header 정의 2response.writeHead(200, {\u0026#34;Content-Type\u0026#34; : \u0026#34;http header; charset=utf-8\u0026#34;}); 3//resource 전달 (html..json.. 등등) 4response.end(data); HTML Resource response.write(\u0026quot;\u0026quot;) 형태로 직접 작성하면서 전달해줄 수 있지만 코드도 길어지고 비효율적이다.. fs 모듈로 html 파일을 갖고올 수 있다. fs 모듈은 비동기 수행이므로 createServer 콜백을 async로 감싸는 것도 잊지말자.\n1const mainView = await fs.readFile(\u0026#34;../frontend/html/board.html\u0026#34;).catch((err)=\u0026gt;{ console.error(err) }); 2response.writeHead(200, {\u0026#34;Content-Type\u0026#34; : \u0026#34;http header; charset=utf-8\u0026#34;}); 3response.end(mainView); JSON Resource restAPI 통신시 JSON 포맷 데이터를 애용하게되는데, node에서는 손 쉽게 객체로 내려줄 수 있다. (역시 JSON 다루는 것은 node.js가 편하다..)\ncontent-type을 JSON 형태로 맞추고 객체를 String객체로 변환시켜서 응답해주면 된다.\n1const list = { 2 result : true, 3 data : { 4 items : store.boardlist 5 } 6} 7response.writeHead(200, { \u0026#34;content-Type\u0026#34; : \u0026#34;Application/json; charset=utf-8\u0026#34;}); 8return response.end(JSON.stringify(list)); 후기 이렇게 해서 간단한 서버를 만들어보았는데 확실히 구축 속도가 빠르긴하다.. 단 몇줄만으로 손쉽게 서버를 만들 수 있으니..\n*위 내용은 공부한 내용을 축약해서 정리해보았는데 혹여나 전체 소스가 필요한 분들을 위해 아래에 정리해보았습니다.(서버소스만..)\n파일 구조\n├── frontend │ ├── html │ │ ├── board.html │ │ ├── notFound.html │ │ └── serverError.html │ └── resources │ ├── css │ │ ├── board.css │ │ └── style.css │ └── js │ ├── board.js │ └── pagination.js └── server ├── restApi.js └── store.js store.js\n1const store = { 2 boardlist : [{ 3 title : \u0026#34;재미있는 요시아일랜드\u0026#34;, 4 context : \u0026#34;혹시 요시아일랜드 해보셨나요? 해보셨다고요?\u0026#34;, 5 writer : \u0026#34;yondo123\u0026#34;, 6 writeDate : \u0026#34;2021-09-17\u0026#34; 7 },{ 8 title : \u0026#34;재미있는 요시아일랜드\u0026#34;, 9 context : \u0026#34;혹시 요시아일랜드 해보셨나요? 해보셨다고요?\u0026#34;, 10 writer : \u0026#34;yondo123\u0026#34;, 11 writeDate : \u0026#34;2021-09-17\u0026#34; 12 },{ 13 title : \u0026#34;재미있는 요시아일랜드\u0026#34;, 14 context : \u0026#34;혹시 요시아일랜드 해보셨나요? 해보셨다고요?\u0026#34;, 15 writer : \u0026#34;yondo123\u0026#34;, 16 writeDate : \u0026#34;2021-09-17\u0026#34; 17 },{ 18 title : \u0026#34;재미있는 요시아일랜드\u0026#34;, 19 context : \u0026#34;혹시 요시아일랜드 해보셨나요? 해보셨다고요?\u0026#34;, 20 writer : \u0026#34;yondo123\u0026#34;, 21 writeDate : \u0026#34;2021-09-17\u0026#34; 22 },{ 23 title : \u0026#34;재미있는 요시아일랜드\u0026#34;, 24 context : \u0026#34;혹시 요시아일랜드 해보셨나요? 해보셨다고요?\u0026#34;, 25 writer : \u0026#34;yondo123\u0026#34;, 26 writeDate : \u0026#34;2021-09-17\u0026#34; 27 },{ 28 title : \u0026#34;재미있는 요시아일랜드\u0026#34;, 29 context : \u0026#34;혹시 요시아일랜드 해보셨나요? 해보셨다고요?\u0026#34;, 30 writer : \u0026#34;yondo123\u0026#34;, 31 writeDate : \u0026#34;2021-09-17\u0026#34; 32 },{ 33 title : \u0026#34;재미있는 요시아일랜드\u0026#34;, 34 context : \u0026#34;혹시 요시아일랜드 해보셨나요? 해보셨다고요?\u0026#34;, 35 writer : \u0026#34;yondo123\u0026#34;, 36 writeDate : \u0026#34;2021-09-17\u0026#34; 37 },{ 38 title : \u0026#34;재미있는 요시아일랜드\u0026#34;, 39 context : \u0026#34;혹시 요시아일랜드 해보셨나요? 해보셨다고요?\u0026#34;, 40 writer : \u0026#34;yondo123\u0026#34;, 41 writeDate : \u0026#34;2021-09-17\u0026#34; 42 }], 43 logger : function (type, message) { 44 switch (type) { 45 case \u0026#34;log\u0026#34;: 46 console.log(\u0026#34;[👻 LOGGER]\u0026#34; + message); 47 break; 48 case \u0026#34;error\u0026#34;: 49 console.log(\u0026#34;[⛔️ ERROR]\u0026#34; + message); 50 break; 51 case \u0026#34;warn\u0026#34;: 52 console.log(\u0026#34;[🚸 WARN]\u0026#34; + message); 53 break; 54 default: 55 console.error(\u0026#34;[LOGGER] 지원하지 않는 타입\u0026#34;); 56 break; 57 } 58 } 59} 60 61module.exports = store; server.js\n1const http = require(\u0026#34;http\u0026#34;); 2const fs = require(\u0026#34;fs\u0026#34;).promises; 3const store = require(\u0026#34;./store\u0026#34;); 4 5http.createServer(async (request, response) =\u0026gt; { 6 try { 7 const method = request.method; 8 const url = request.url; 9 10 store.logger(\u0026#34;log\u0026#34;, `[method : ${method}, url : ${url}]`); 11 12 //GET Method 13 if (method === \u0026#34;GET\u0026#34;) { 14 if (url === \u0026#34;/\u0026#34;) { 15 const mainView = await fs.readFile(\u0026#34;../frontend/html/board.html\u0026#34;).catch((err) =\u0026gt; { 16 return store.logger(\u0026#34;error\u0026#34;, err); 17 }); 18 response.writeHead(200, { \u0026#34;content-Type\u0026#34; : \u0026#34;text/html; charset=utf-8\u0026#34;}); 19 return response.end(mainView); 20 }else if(url == \u0026#34;/list\u0026#34;){ 21 const list = { 22 result : true, 23 data : { 24 items : store.boardlist 25 } 26 } 27 response.writeHead(200, { \u0026#34;content-Type\u0026#34; : \u0026#34;Application/json; charset=utf-8\u0026#34;}); 28 return response.end(JSON.stringify(list)); 29 } 30 31 try { 32 const view = await fs.readFile(`../frontend${url}`); 33 console.log(`../frontend${url}`); 34 return response.end(view); 35 } catch (error) { 36 const notFoundView = await fs.readFile(\u0026#34;../frontend/html/notFound.html\u0026#34;).catch((err) =\u0026gt; { 37 return store.logger(\u0026#34;error\u0026#34;, err); 38 }); 39 response.writeHead(404, { \u0026#34;content-Type\u0026#34; : \u0026#34;text/html; charset=utf-8\u0026#34;}); 40 return response.end(notFoundView); 41 } 42 } 43 //main 44 } catch (error) { 45 store.logger(\u0026#34;error\u0026#34;, error); 46 } 47}).listen(8080, ()=\u0026gt;{ 48 store.logger(\u0026#34;log\u0026#34;, \u0026#34;POST BOX START!!!!!\u0026#34;); 49}); 참고자료  Node.js 교과서 - http 모듈로 서버 만들기 (조현영 저) geeksforgeeks - HTTP Content-Type  ","date":"2021-09-17T23:48:56+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/node-restapi/","title":"Node.js HTTP모듈 실습"},{"content":"선형검색 배열에서 원하는 키 값 요소를 만날 때까지 순서대로 요소 검색, 값을 찾지 못하고 배열을 모두 순회하거나 값을 찾는다면 바로 종료한다.\n1function linearSearch(key, arr) { 2 for (let index = 0; index \u0026lt; arr.length; index++) { 3 if (key === arr[index]) { 4 return true 5 } 6 } 7 return false; 8} 9 10linearSearch(2811, [2, 15, 24, 28, 304, 16, 7, 1]); //false 11linearSearch(16, [2, 15, 24, 28, 304, 16, 7, 1]); //true 이진검색 이미 정렬되어 있는 배열(전제 조건)에서 범위를 좁혀가며 값을 찾는 탐색법 선형 탐색보다 속도가 빠르긴하지만 정렬되어 있는 리스트에 적용할 수 있다.\nleft = 탐색 시작 위치, center = 팀색 중앙 위치((n-1) / 2), right = 탐색 끝 위치 (n-1)로 초기화하여 점차적으로 좁혀나간다.\n정렬된 배열이라는 전제 조건이 붙기는 하지만, 선형 검색보다 순회 횟수가 크게 줄어 성능적으로 더 효율적이다.\n 중앙 요소가 찾는 Key보다 작을 때 기존 (center + 1) ~ right 까지 탐색 범위를 좁힌다. 중앙 요소가 찾는 Key보다 클 때 left ~ (center - 1) 까지 탐색 범위를 좁힌다.  1function binarySearch(key, array) { 2 let count = 0; 3 let left = 0; 4 let right = array.length - 1; 5 6 while (left \u0026lt;= right) { 7 let center = Math.floor((left + right) / 2); 8 const item = array[center]; 9 count += 1; 10 if (item === key) { 11 console.log(\u0026#34;true, \u0026#34; + count); 12 return true; 13 } else if (item \u0026lt; key) { 14 left = center + 1; 15 } else { 16 right = center - 1; 17 } 18 } 19 console.log(\u0026#34;false, \u0026#34; + count); 20 return false; 21} 22 23binarySearch(10, [1, 2, 3, 4, 5, 6, 7, 8, 9]); //false, 4 24binarySearch(8, [1, 2, 3, 4, 5, 6, 7, 8, 9]); //true, 3 참고자료  자료구조와 함께 배우는 알고리즘 입문 - 검색 알고리즘 (Bohyoh Shibata 저)  ","date":"2021-09-14T23:25:12+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/algorithm-search/","title":"탐색 알고리즘 (선형, 이진)"},{"content":"Module module객체를 통해 각각의 기능이나 js파일들을 쉽게 모듈화가 가능하다.\nexport 코드를 외부에 내보내고 싶다면 export문을 사용한다. 함수, 변수, 클래스 등을 내보낼 수 있다.\n1//📁module/util.js 2const constants = { 3\tmessage : \u0026#39;simple message\u0026#39;; 4} 5 6const requestUrl = \u0026#39;/xyz-url\u0026#39;; 7 8const private = { 9\tprivateKey : \u0026#39;1234\u0026#39; 10} 11 12export {constants, requestUrl}; //배열로도 export가 가능하다. (1~2개 모듈은 보통 객체형식으로 많이 사용) 각각의 모듈 대상에 export 예약어를 붙여 내보낼 수도 있다.\n1export function constants = { 2\tmessage : \u0026#39;simple message\u0026#39;; 3} import import를 통해 상대 경로에 위치한 모듈 파일을 가져올 수 있다.\n1//📁main.js 2import * as util from \u0026#39;./module/util.js\u0026#39;; //util.js에 export된 내용들을 util이라는 변수로 사용 3import { constants } from \u0026#39;./module/util.js\u0026#39;; //util.js에 export된 내용 중 constants만 사용 export default export default를 사용하면 중괄호를 생략할 수 있다.\n특히 클래스를 불러올 때 유용하게 사용된다.(보통 자바스크립트 파일 한개당 한개의 클래스만 작성하기 때문이다.)\nexport\n1//📁module/Calculator.js 2//간단한 계산기 클래스 3export default class Calculator { 4 constructor(a, b) { 5 this.a = a; 6 this.b = b; 7 } 8 9 add() { 10 return this.a + this.b; 11 } 12\t//..code 13} import\n1import Calculator from \u0026#39;./module/Calculator.js\u0026#39;; 2let cal = new Calculator(1,2); 3console.log(cal.add()); //3 Node에서의 모듈화 node.js에서는export 대신 module.exports import 대신 require을 사용해서 모듈을 불러올 수 있다.\n주의사항은 단일 파일에서 module.exports는 한번만 수행할 수 있다.\n1//간단한 로그 찍어주는 함수 (📁modules/module.js) 2function logger(type, message) { 3 switch (type) { 4 case \u0026#34;log\u0026#34;: 5 console.log(\u0026#34;[👻 LOGGER]\u0026#34; + message); 6 break; 7 case \u0026#34;error\u0026#34;: 8 console.log(\u0026#34;[⛔️ ERROR]\u0026#34; + message); 9 break; 10 case \u0026#34;warn\u0026#34;: 11 console.log(\u0026#34;[🚸 WARN]\u0026#34; + message); 12 break; 13 default: 14 console.error(\u0026#34;[⛔️ LOGGER] 지원하지 않는 타입\u0026#34;); 15 break; 16 } 17} 18//상수 객체 19const constants = { 20 URL: \u0026#34;/xyz.com\u0026#34;, 21 FILEPATH: \u0026#34;/cloud.com\u0026#34;, 22}; 23 24//exports 25module.exports = { 26 logger, 27 constants, 28}; 29 30//import예제 (간단한 로그 찍어주는 함수 (📁main.js) 31const { logger, constants } = require(\u0026#34;./module/module\u0026#34;); 32 33logger(\u0026#34;log\u0026#34;, \u0026#34;LOGGING!!\u0026#34;); 34logger(\u0026#34;warn\u0026#34;, constants.FILEPATH); 예제\n위에서 만들었던 계산기 클래스를 모듈화\n1//📁module/Calculator.js 2//간단한 계산기 클래스 3class Calculator { 4 constructor(a, b) { 5 this.a = a; 6 this.b = b; 7 } 8 9 add() { 10 return this.a + this.b; 11 } 12 //..code 13} 14 15module.exports = Calculator; require 1const Calculator = require(\u0026#34;./module/Calculator\u0026#34;); 2let cal = new Calculator(1, 2); 3 4console.log(cal.add()); import-export 사용 기존 import-export 문법도 사용 가능하다. 방법은 2가지 정도인데 파일 확장자를 mjs로 만들거나, node 프로젝트 생성 시 package.json에서 type을 module속성을 넣으면된다고 한다. 하지만 완전히 같은 문법은 아니기때문에 node에서 사용해왔던 exports-require를 사용하는것이 좋다.\n브라우저에서의 모듈화 스크립트 type 속성에 module을 추가하면된다.\n1\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 참고자료 - 자바스크립트 코딩의 기술 - 가져오기와 내보내기로 기능을 분리하라 (조 모건 저)\n- Node.js 교과서 - 모듈만들기 (조현영 저)\n- stackabuse - How to use module.exports in Node.js\n","date":"2021-09-11T23:36:33+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/js-module/","title":"자바스크립트 모듈화"},{"content":"Promise 1function callbackDelay(sec, callback) { 2 setTimeout(()=\u0026gt;{ 3 callback(\u0026#34;콜백 Delay\u0026gt;\u0026gt;\u0026#34;+new Date().toString()); 4 }, sec * 1000) 5} 6 7callbackDelay(1, (result)=\u0026gt;{ 8 console.log(1, result); 9 callbackDelay(1, (result)=\u0026gt;{ 10 console.log(2, result); 11 callbackDelay(1, (result)=\u0026gt;{ 12 console.log(3, result) 13 }) 14 }) 15}) 16/*result 171 콜백 Delay\u0026gt;\u0026gt;Sun Jun 07 2020 18:43:56 GMT+0900 (GMT+09:00) 18promise.js:26 192 콜백 Delay\u0026gt;\u0026gt;Sun Jun 07 2020 18:43:57 GMT+0900 (GMT+09:00) 20promise.js:28 213 콜백 Delay\u0026gt;\u0026gt;Sun Jun 07 2020 18:43:58 GMT+0900 (GMT+09:00) 22*/ 자바스크립트에서 비동기 동작을 할때 우리는 항상 해당 함수에 콜백 함수를 넣어줬다. 만약 타이머로 1초마다 해당 시간을 출력하는 함수를 예시로 들면..\n대표적인 비동기 함수인 setTimeout을 호출할 때 이렇게 매 순간 콜백 함수를 전달해야 1..2..3..형태로 출력되는 것을 볼 수 있다. 하지만 이 코드의 불편함은 콜백이 콜백을 전달함으로써 **콜백지옥(callback hell)**이 펼쳐진다는것이다. 이를 개선하기 위해 Promise객체를 사용하면 더욱 간결하게 비동기 로직에 대응할 수 있다.\n사용법 Promise에는 3가지 상태가 있다. (대기 - 이행 - 실패)\n  대기는 프로미스를 생성자로 호출한 순간이다. 프로미스는 콜백 함수를 인수로 받고, 성공(resolve) - 실패(reject) 상태를 대응할 수 있다.\n1new Promise(function(resolve, reject){ 2 //code.. 3});   resolve를 호출할 시 이행 상태가 된다.\n1new Promise(function(resolve, reject){ 2 resolve(); 3});   이행(완료) 상태가 되면 then()메서드로 콜백함수를 전달할 수 있다.\n1new Promise(function(resolve, reject){ 2 const result = \u0026#34;success!\u0026#34;; 3 resolve(); 4}).then(function(res){ 5 console.log(res); 6}); 7 8//success!   실패 상태가 되면 catch()메서드로 받을 수 있다.\n1new Promise(function(resolve, reject){ 2 const fail = \u0026#34;fail!\u0026#34;; 3 reject(new Error(fail)); 4}) 5.then() 6.catch(function(res){ 7 console.log(res); 8}); 9 10//fail!   또한 여러개의 Promise들의 인스턴스를 순차적으로 연결시킬 수 있다.\n1function getData(){ 2\treturn new Promise(function(resolve, reject){ 3\tresolve(\u0026#39;success!!\u0026#39;); //then method chain 4\t}); 5} 6 7getData() 8 .then(function(data){ 9 console.log(data + \u0026#34;first\u0026#34;); 10 return data; 11 }) //success!!first 12 .then(function(data){ 13 console.log(data + \u0026#34;second\u0026#34;); 14 return data; 15 }) 16 .then(function(data){ 17 console.log(data + \u0026#34;third\u0026#34;); 18 }); 이제 기존 단순히 콜백을 전달하는 방식으로 작성한 타이머 코드를 프로미스 형태로 개선해보자.\n1function promiseDelay(sec) { 2 return new Promise((resolve, reject)=\u0026gt;{ 3 setTimeout(()=\u0026gt;{ 4 resolve(\u0026#34;프로미스 Delay\u0026gt;\u0026gt;\u0026#34;+new Date().toString()); 5 }, sec * 1000); 6 }); 7} 8 9promiseDelay(1) 10\t.then((res)=\u0026gt;{ 11 console.log(1,res); 12 return promiseDelay(1); //프로미스를 다시 호출하지 않으면 undefined 13\t}) 14\t.then((res)=\u0026gt;{ 15 console.log(2,res); 16\t}) return 활용법 프로미스 내부에서는 return 을 사용하지 않고, resolve()만 시행시킨다면 후행의 코드들도 모두 실행한다.\n따라서 즉시 then(이행 상태)으로 넘어가려면 return을 해주면 된다. (함수 return 방식과 동일하다.)\n1return new Promise((resolve, reject) =\u0026gt; { 2\tattach.readFile((data) =\u0026gt; { 3\tresolve(data); 4\tconsole.log(\u0026#39;success\u0026#39;) // 출력 5 }); 6}); catch문 내부에서 return을 통해 에러를 효율적으로 처리할 수있다.\n에러가 발생하면 catch메서드에서 처리하게되는데 , 다시 then으로 넘겨 에러 이후의 처리들도 할 수 있다.\n1const getUserInfo = () =\u0026gt; 2 new Promise((resolve, reject) =\u0026gt; { 3 setTimeout(() =\u0026gt; resolve({id:\u0026#39;abc\u0026#39;, pw:\u0026#39;qwerty\u0026#39;}), 1000); 4}); 5 6const executeHandler = userInfo =\u0026gt; 7 new Promise((resolve, reject) =\u0026gt; { 8 console.log(JSON.stringify(userInfo)); 9 setTimeout(() =\u0026gt; reject(new Error(\u0026#39;fail process\u0026#39;)), 1000); 10}); 11 12 getUserInfo() 13 .then(userInfo =\u0026gt; executeHandler(userInfo)) 14 .catch(error =\u0026gt; {return `\u0026#39;${error}\u0026#39; handlling success!!`}) //promise Chain, 오류가 발생하더라도 다시 값을 처리해 .then(result)로 넘길 수 있다. 15 .then(result =\u0026gt; console.log(result)); Async-await Promise를 더욱 간결하게 처리할 수 있는 문법이다. 함수 앞에 async 키워드를 선언하면 된다.\nawait예약어는 해당 함수가 꼭 프로미스 객체를 반환해야 한다.\n1function getlUserApi(){ 2\t//promise 반환 (비동기 함수) 3\treturn new Promise((resolve, reject) =\u0026gt; { //..code }); 4}; 5 6async function showUser(){ 7\tconst userInfo = await getUserApi(); 8\treturn userInfo; 9} 10 위 코드는 아래와 같이 Promise를 반환시킨다. 따라서 프로미스와 마찬가지로 then을 통해 콜백 함수를 처리한다.\n1async function showUser(){ 2\tconst userInfo = getUssrApi(); 3\treturn Promise.resolve(userInfo); 4} 만약 사용자의 정보를 받아오는 함수가 있다면 아래와 같이 사용할 수 있다.\n1//AJAX 대신 setTimeout으로 대체; 2function getUserApi(){ 3\treturn new Promise((resolve, reject) =\u0026gt; { //Promise 반환 4\tsetTimeout(() =\u0026gt; { 5\tresolve({name : \u0026#39;jiny\u0026#39;, age : 27}); 6\t}, 3000); 7\t}); 8} 9 10//async 함수 내부에 await 선언 11async function showUser(){ 12\tconst userInfo = await getUserApi(); 13\treturn userInfo; 14} 15 16//이행 처리 17showUser() 18\t.then(data =\u0026gt; { console.log(JSON.stringify(data)) }); 19 에러처리 async 함수내에서 오류가 발생하면 try-catch문으로 에러를 핸들링해줄 수 있다.\n물론 catch()로 프로미스에서 해결하지 못한 에러들도 추가적으로 처리가 가능하다.\n1async function showUser(){ 2\ttry{ 3\tconst result = await getUserApi(); 4\treturn userInfo; 5\t} catch(error) { 6\tconsole.error(error); 7\t} 8} Top-level await chrome 89+, Node.js 14+ 버전부터 async 함수 예외에서도 await을 사용할 수 있다고한다.\n최신 브라우저에서는 async로 굳이 감싸지 않아도 될듯하다.. (실제 테스트해보았더니 잘 실행된다!)\n1await getUserApi() 2\t.then(function(res){ console.log(JSON.stringify(res) }); 참고자료  Node.js 교과서 - 프로미스 (조현영 저) 자바스크립트 코딩의 기술 - async/await (조 모건 저) async와 await - JAVASCRIPT.INFO toplevel await - v8.dev  ","date":"2021-09-08T23:18:33+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/promise-async-await/","title":"Promise와 Async/await"},{"content":"비동기 처리 1//대충 이런 구조의 코드.. 2function checkValue(){ 3\t//로직검사.. 4} 5 6setTimeout(function(){ 7\tcheckValue(); 8}, 500); 9 10function getData(){ 11\t//AJAX로 소스를 받아오는 코드.. 12}; 13 14getData(); 자바스크립트를 처음 접했을 때, setTimeout이 왜 순서대로 시행 안되지??.. (why 나중에 시행되는거야..🤔)해서비동기에 대한 개념을 숙지했다. 대충 콜백함수로 넘겨서 호출해 해결하고 비동기 프로세스에 대한 개념 자체를 더 배우려하지 않았다. 이번에 Node.js 스터디를 하면서 비동기 프로세스를 꼭 알아야 성능 향상에 도움이 된다는 사실을 알게되었고 책과 강의를 통해 내가 이해한 비동기 처리과정을 최대한 간략하게 정리해보았다.\n이벤트 루프는 비동기 프로세스를 이해하기 위해 꼭 알아야 하는 자바스크립트 런타임 구성요소이다. 보통 실행 컨텍스트에 의해 선언한 코드들이 콜스택에 차곡차곡 모여지는데, 여기서 비동기 요청(setTimeout 또는 AJAX 비동기 통신 등등..)들은 백그라운드 영역으로 보낸다.\n그러면 해당 함수는 콜스택에서 빠져나오게되고, 해당 비동기 API와 함께 백그라운드 영역에 담게된다. (대표적인 예로 타이머를 그렸지만, DOM Event 및 AJAX통신도 해당된다.)\n여기서 백그라운드 영역은 JavaScript가 처리하는것이 아니라 실행 환경에서의 런타임 엔진(V8과 같은)에서 처리된다는 것을 꼭 명심하자. 비동기 함수들은 모두 Background영역에서 이루어지게된다. 서버에서 값을 수신해오거나, 특정 시간 뒤에 콜백을 처리하거나.. 이런 API동작이 완료되면 TaskQueue로 콜백 함수를 보내면서 콜스택이 비어져있는지 확인 후 TaskQueue에 있는 함수들을 하나 씩 콜스택으로 옮겨 시행하게된다.\nCallstack 실행 할 함수들을 담아놓은 영역, 변수와 스코프 정보들이 담겨있는 실행 컨텍스트가 스택 구조로 이루어져있다.\nEventloop 콜스택과 태스크 큐들을 감시하면서 콜스택이 비워져있으면 태스크 큐에 담겨져있는 함수를 가져와 실행시킬 수 있게 해준다. 따라서 콜스택이 비워져있지 않으면 비워질 때 까지 대기하는데 이러한 대기 시간 차이가 비동기 함수들의 완료 시간을 지연시키게 만든다.\nTaskQueue 백그라운드 영역에서 보낸 콜백 함수들을 받아 Queue구조로 저장되어있는 공간이다. 보통 완료된 순서대로 위치하지만 특정 경우에는 바뀌기도한다. (예를들면 Promise 객체의 then 이행 함수가 우선적으로 수행된다.)\n정리 아직도 어렵긴하지만 예전에 내가 생각한대로 되지 않았던 코드들이 왜 안되었는지 고개를 끄덕이게 만들었다..\n특히, Node.js 환경에서는 저 백그라운드 영역이 non-blocking처리가되는 영역이라고하니 이런 흐름을 꼭 숙지해야할 것 같다.\n참고자료  Node.js 교과서 - 조현영 저 What the heck is the event loop anyway? - Philip Roberts  ","date":"2021-09-07T21:59:08+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/eventloop/","title":"비동기와 이벤트 루프"},{"content":"화살표 함수 기존 함수 표기법을 화살표(⇒)형태로 간단하게 표기하는 함수 표기법\n기존 함수 표현식과의 차이 1//기존 함수 표현식 2function name(){ 3 //code.. 4} 5 6//화살표 함수 7() =\u0026gt; { 8\t//code.. 9} 화살표 함수 특징 괄호 생략 매개변수가 1개라면 괄호()도 생략이 가능하다.\n1const logMessage = message =\u0026gt; { console.log(message) } 2logMessage(\u0026#39;hello\u0026#39;); //\u0026#39;hello\u0026#39; Lexical this 일반 함수 표기에서는 this사용 시 동적으로 해당 함수를 실행한 객체로 바인딩되었다.\n하지만 화살표 함수에서는 자신을 소유하고 있는 객체로 바인딩되는게 아니라 해당 화살표함수를 소유하고 있는 상위 환경의 this를 그대로 계승한다. (이 개념을 Lexical this라고 한다..)\n따라서 해당 객체의 속성에 접근이 필요한 메서드에서는 화살표 함수를 쓰지말자..\n1const person = { 2 name : \u0026#39;choi\u0026#39;, 3 getName : function(){ 4 return console.log(this.name); 5 } 6} 7person.getName(); //choi 8 9const food = { 10 name : \u0026#39;kimchi\u0026#39;, 11 getName : () =\u0026gt; { return console.log(this.name) } 12} 13food.getName(); // \u0026#39;\u0026#39; 콜백 함수에서의 유용성 메서드 함수로 사용하는 대신, 함수를 반환하는 콜백 함수 용도로 사용하면 기존 함수 표현식 보다 깔끔해진다.\n이미 문맥이 존재하고 함수 내부에서 이 함수를 사용하려고 할 때 유용하다.\n1//배열로 구성된 원소들에 대한 값을 검증하는 함수 2const validator = { 3 message : \u0026#39;is valid.\u0026#39;, 4 checkElement : function(elements){ 5 return elements.map(element =\u0026gt; { 6 if(element) return element + this.message + \u0026#39;\\n\u0026#39;; 7 }); 8 } 9} 10validator.checkElement([\u0026#34;값\u0026#34;, \u0026#34;값2\u0026#34;]); 만약 위 메서드 checkElement에서 화살표 함수가 아니라 일반 함수 표현식을 사용했다면, 내부함수에서의 this는 상위 컨텍스트를 바라보기 때문에 validator의 message를 가져오지 못하고 undefined를 출력 할 것이다. 따라서 화살표 함수를 사용하게된다면, 이러한 this 바인딩 범위를 잘 생각해야 한다.\n","date":"2021-09-05T19:45:01+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/arrow-function/","title":"자바스크립트 화살표 함수"},{"content":"Temlate literals 기존 문자열 결합 시 연산자(+)를 사용하였는데 백틱(`) 기호를 사용하여 쉽게 결합할 수 있다.\n기존 연산자 사용 1const fruit = \u0026#39;apple\u0026#39;; 2const color = \u0026#39;red\u0026#39;; 3console.log(\u0026#39;My Favorite Fruit is\u0026#39; + fruit + \u0026#39;, color is \u0026#39; + color ); //\u0026#34;My Favorite Fruit isapple, color is red\u0026#34; 템플릿리터럴 사용 1const fruit = \u0026#39;apple\u0026#39;; 2const color = \u0026#39;red\u0026#39;; 3console.log(`My favorite Fruit is ${fruit}, color is ${color}`); 장점 보통 복잡한 문자열이거나 html 코드등을 직접 스크립트상에서 삽입할 때 쌍따옴표-홀따옴표등과 같이 사용하는 경우에 상당히 복잡했었다. (따옴표 종료 위치를 일일이 신경써야했기에)\n템플릿리터럴을 사용하면 일반 텍스트를 작성하듯 변수 위치만 신경써주면되니까 이런점이 편하다.\n1const name = \u0026#39;Jiny\u0026#39;; 2const template = `\u0026lt;p class=\u0026#34;user-name\u0026#34;\u0026gt;${name}\u0026lt;/p\u0026gt;` 참고자료  자바스크립트 코딩의 기술 - 조모건 저  ","date":"2021-09-05T19:36:27+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/template-literals/","title":"자바스크립트 템플릿리터럴"},{"content":"배열 데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계를 뜻한다. JAVA 배열의 특징은 다음과 같다.\n 같은 타입이어야 한다. 한번 생성된 배열을 길이를 변경할 수 없다.  자료형 배열 구성 요소의 자료형은 어떤 형이든 상관 없음\n1int[] a; //주로 이렇게 선언 2int a[]; 배열의 초기화 배열 원소의 기본 값(초기화)은 자료형에 따라 아래와 같이 생성된다. 아래 초깃값 생성 규칙은 배열뿐만아니라 클래스의 필드도 마찬가지이다!\n(메서드 내에서 생성한 지역 변수는 자동 초기화가 되지 않고 컴파일 오류를 출력한다.)\n byte,short, int : 0 long : 0L float : 0.0f double : 0.0d char : \u0026ldquo;\\u0000\u0026rdquo; string : null boolean : false  배열의 생성 자바에서 배열을 생성할 때 배열에 들어갈 타입을 명시한다.\n1int[] numberArray = new int[5]; //0,0,0,0,0 2//생성과 동시에 초기화 3int[] numberArray = new int[]{1,2,3,4,5}; //1,2,3,4,5 4int[] numberArray = {1,2,3,4,5}; //축약형, 위와 동일 5int[][] deepNumberArry = {{1,2}, {2,3}}; //2차원 배열 생성 배열의 복사 clone() 메서드 사용 배열을 복제하고 복제한 배열에 대한 참조를 생성한다.\n주의사항으로는 1차원배열은 깊은 복사를 해주지만, 2차원 배열에서는 깊은복사가 되지 않는다. (최상위 레벨만 깊은복사 → 나머지는 참조)\n1public class Array { 2 public static void main(String[] args) { 3 String[] fruits = {\u0026#34;apple\u0026#34;, \u0026#34;melon\u0026#34;, \u0026#34;banana\u0026#34;}; 4 String[] copyFruits = fruits.clone(); 5 for (int i = 0; i \u0026lt; fruits.length; i++) { 6 System.out.println(\u0026#34;fruits : \u0026#34; + fruits[i]); 7 System.out.println(\u0026#34;copyFruits : \u0026#34; + fruits[i]); 8 } 9 } 10} arraycopy() 메서드 사용 arraycopy(복사할 배열, 시작 위치, 새 배열, 새 배열 시작 위치, 복수 갯수) 4개의 인수를 받는다.\n지정된 위치를 받기 떼문에 기존 존재하는 배열에 새로 복제하는 경우에 유용하게 사용된다.\n1public class Array { 2 public static void main(String[] args) { 3 String[] fruits = {\u0026#34;apple\u0026#34;, \u0026#34;melon\u0026#34;, \u0026#34;banana\u0026#34;}; 4 String[] newFruits = new String[5]; 5 System.arraycopy(fruits, 0, newFruits, 0, 3); 6 for (int i = 0; i \u0026lt; newFruits.length; i++) { 7 System.out.println(\u0026#34;copyFruits : \u0026#34; + newFruits[i]); 8 } 9 } 10} 배열의 비교 리스트 형태의 클래스는 equals라는 메서드가 있지만 Array 클래스에는 직접 구현해야한다.. 만약 Array구조에 equals를 사용한다면 Object 클래스의 equals를 사용하게 되어서 단순히 인스턴스만 비교해준다. 배열을 비교하는 클래스 먼저 두 배열이 달라야한다면 다음과 같은 상태를 만족해야한다.\n 두 배열의 length가 다르다. 각각의 원소 값이 다르다.  1public class EqualArray { 2 static boolean isEqueals(int[] a, int[] b){ 3 if(a.length != b.length){ 4 return false; 5 }else{ 6 for (int i = 0; i \u0026lt; a.length; i++){ 7 if(a[i] != b[i]){ 8 return false; 9 } 10 } 11 } 12 return true; 13 } 14 15 public static void main(String[] args) { 16 int[] arrayA = {1,2,3,4,5}; 17 int[] arrayB = {1,2,3,4,5}; 18 19 System.out.println(isEqueals(arrayA, arrayB)); //true 20 } 21} 참고자료  자바의 정석 - 배열 (남궁성 저) 자료구조와 함께 배우는 알고리즘 입문(JAVA) - 배열 자료구조 (Bohyoh Shibata) CodeIt - ArrayList와 배열 equals 차이  ","date":"2021-09-04T22:57:27+09:00","image":"https://jinyisland.kr/../../assets/java/java.png","permalink":"https://jinyisland.kr/post/java-array/","title":"JAVA 자료구조 배열"},{"content":"요즘 공부하고 있는 vue.js 프레임워크를 사용하다보면 자연스럽게 es6 이상의 트렌디한 자바스크립트 문법이 눈에 띈다. 🧐\n물론 vue 코드를 빠르게 짤 수 있는 스니펫 플러그인에서도 기본적으로 es6+ 문법으로 안내해주기도하고.. vue를 사용해서가 아니라 이렇게 트렌디한~자바스크립트에서는 어떤 문법이 있는지 차례차례 짚고 넘어가고자 한다. (물론 내 기준 현업 또는 개인적으로 많이 쓰는 문법 위주로~ㅎㅎ)\n블록범위 먼저 let과 const를 제대로 이해하려면 블록범위를 제대로 알고넘어가야한다!\n블록범위 내에서 let과 const를 사용하면 해당 변수를 재할당할 수 없도록 지정할 수 있다. 자바스크립트에서의 블록유효범위는 if블록이나 for 반복문과 같이 중괄호로 둘러싸인 범위를 의미한다. 지금까지 사용했던 var로 변수를 선언하는 방식은, 중복되는 변수이어도 재할당을 하면서 코드가 많아질 경우 값이 바뀌는것을 파악해야하는 문제가 있었다.\n1var name = \u0026#39;choi\u0026#39;; 2var name = \u0026#39;kim\u0026#39;; 3console.log(name); //\u0026#39;kim\u0026#39; const 값을 재할당할 수 없지만, 참조된 값을 변경할 수는 있다.\n1const name = \u0026#39;choi\u0026#39;; 2const name = \u0026#39;kim\u0026#39;; //error 3 4const fruits = [\u0026#39;🍎\u0026#39;, \u0026#39;🍌\u0026#39;]; 5fruits.push(\u0026#39;🍓\u0026#39;); 6console.log(fruits); //\u0026#39;🍎\u0026#39;, \u0026#39;🍌\u0026#39;, \u0026#39;🍓\u0026#39; let 기존 var과 유사한 점은 변수를 재할당할 수 있는 점이다. 하지만 var로 선언한 변수는 어휘적 유효범위(lexical sope) 를 따르지만, let은 블록 유효범위를 따른다. 아래 예제를 보면 아이템의 가격을 반환해주는 함수이다. 만약 정가(price)와 갯수(inventory)가 존재하면 정가를 반환하고, 세일 가격(salePrice)와 세일중인 아이템 갯수(saleInventory)가 존재하면 할인가격을 반환한다. 이 예제에서 핵심은 let임에도 불구하고 변수를 2번 재할당하고 있다. 블록 유효범위를 따르기때문에 가능한 일이다.\n1function getPriceOfItems(item) { 2 let stack = item.inventory; 3 let price = item.price; 4 if (item.salePrice) { 5 let stack = item.saleInventory; //다른 유효범위 6 console.log(stack); //1 7 if (stack \u0026gt; 0) { 8 price = item.salePrice; 9 } 10 } 11 if (stack) { 12 console.log(stack); //3 13 return price; 14 } 15 return 0; 16} 17getPriceOfItems({ 18 price: 3600, 19 inventory: 3, 20 salePrice: 1800, 21 saleInventory: 1 22}); 23//1800 반복문에서의 유효범위 충돌 방지 지난번 클로저를 소개할 때 사용했던 예제이긴하지만.. 어휘적 유효범위를 따르는 var로 선언한 변수 때문에 비동기 로직에서 마지막 값만 계속 참조되는 현상이 일어났던 코드이다.\n1function countSec(seconds) { 2 for (var i = 1; i \u0026lt;= seconds; i++) { 3 setTimeout(function () { 4 console.log(i); //3..3..3.. 5 }, i * 1000); 6 } 7}; 8countSec(3); 아래처엄 클로저로 해결할 수 있었다.\n1function countSec(seconds) { 2 for (var i = 1; i \u0026lt;= seconds; i++) { 3 (function (curNum) { //즉시실행함수를 이용해 외부 변수 i를 복사하여 setTimout() 지역 변수로 끌어와 정상적으로 1,2,3 입력된다! 4 setTimeout(function () { 5 console.log(curNum); 6 }, curNum * 1000); 7 }(i)); 8 } 9}; 10 11countSec(3); let을 활용해서 더욱 간단히 해결할 수 있다.\n블록유효범위를 따르기 때문에 해당 블록에서만 유효하다는 특징을 잊지말자!\n1function countSec(seconds) { 2 for (let i = 1; i \u0026lt;= seconds; i++) { 3 setTimeout(function () { 4 console.log(i); 5 }, i * 1000); 6 } 7}; 8 9countSec(3); //1..2..3.. 정리 이렇게 기존 가장 많이 사용하였던 var과 const, let의 차이를 알아보았다.\n var : 어휘적 유효범위 (코드를 작성한 위치 기준에서의 참조되고 있는 범위)를 따르는 변수, 재할당과 값수정 모두 제한이 없다. const : 블록 유효범위를 따르며, 변수의 재할당 및 재선언이 불가능하다. let : 블록 유효범위를 따르며, 변수의 재할당은 불가능하지만, 재선언은 가능하다!  최대한 const를 사용해 변수들을 선언하는것이 바람직하며, 재할당이 필요한 경우에만 let을 사용하는것을 추천한다.\n참고자료  자바스크립트 코딩의 기술 - 조모건 저  ","date":"2021-08-30T23:39:26+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/let-const/","title":"let, const와 기존 var의 차이"},{"content":"라우터 클라이언트의 요청 경로에 따라 해당하는 컴포넌트를 불러와 페이지를 구성할 수 있다.\nURL 변경 시 DOM을 새로 갱신하는 것이 아니라 미리 컴포넌트를 가지고 있다가 변경된 요소영역만 갱신한다.(SPA 언어의 큰 특징)\n따라서 유연하게 페이지 젼환이 가능하다. vue 프레임워크에서는 vue-router라는 라우팅 라이브러리를 지원한다.\n설치하기 vue-router를 설치하고, package.json파일에서 모듈이 잘 추가되었는지 확인하자\n1npm install vue-router --save 라우터 속성 다음은 라우터 인스턴스를 생성할 때 설정하는 값이다.\n String mode : 기본 값은 Hash 모드 (history 모드를 사용하면 브라우저 히스토리 스택에 기록된다.) String redirect : 리다이렉팅 (주로 메인 페이지 등에 사용한다.) array routes : 페이지 라우팅 정보  String path : 페이지 경로 (url) Object component : 해당 url 페이지에 사용 할 Component Array children : 중첩 라우팅을 위한 배열    라우터 생성하기 라우터를 생성하는 방식은 인스턴스 방식, vue-router4 이후에 도입된 create 방식 두 가지가 존재한다.\n인스턴스 방식으로 생성 먼저 vue-router를 임포트하여 라우터 인스턴스를 새로 생성한다.\n1//📁router/router.js 2import Vue from \u0026#39;vue\u0026#39;; 3import VueRouter from \u0026#39;vue-router\u0026#39;; 4import Main from \u0026#39;../views/Main.vue\u0026#39;; 5import Info from \u0026#39;../views/Info.vue\u0026#39;; 6 7Vue.use(VueRouter); 8 9const router = new VueRouter({ 10\tmode:\u0026#39;history\u0026#39;, //해쉬값 제거 방식 11 routes: [{ 12 path: \u0026#39;/\u0026#39;, 13 redirect: \u0026#39;/home\u0026#39; 14 }, { 15 path: \u0026#39;/home\u0026#39;, 16 component: Main 17 }, { 18 path: \u0026#39;/Info\u0026#39;, 19 component: Info 20 }] 21}); 1//📁main.js 2import Vue from \u0026#39;vue\u0026#39;; 3import App from \u0026#39;./App.vue\u0026#39;; 4import {router} from \u0026#39;./router/index.js\u0026#39;; 5 6new Vue({ 7 router, 8 render: h =\u0026gt; h(App), 9}).$mount(\u0026#39;#app\u0026#39;) Create 방식으로 생성 router 4버전에서는 더 이상 인스턴스를 호출하지 않고, createRouter메서드를 사용해 라우터를 생성한다. (마치 Vue 3에서의 createApp을 따라가는 느낌..?) 개인적인 생각이지만 이런 메서드 생성 방식이 인스턴스 생성 방식 보다 가독성이 더 좋다고 느껴진다.\n1//📁router/router.js 2import { createWebHistory, createRouter } from \u0026#34;vue-router\u0026#34;; 3 4const routes = [{ /*route config*/ }] //라우팅 패스, 컴포넌트 등 정의 5 6const router = createRouter({ 7\thistory : createWebHistory(), 8\troutes 9}); 10 11export default router; 1//📁main.js 2import { createApp } from \u0026#39;vue\u0026#39; 3import App from \u0026#39;./App.vue\u0026#39; 4import router from \u0026#39;./router\u0026#39; 5 6const myApp = createApp(App); 7myApp.use(router); 8reckeyApp.mount(\u0026#39;#app\u0026#39;); 렌더링 라우터를 생성한 컴포넌트에 router-view태그를 선언하면 URL에 맞게 컴포넌트들이 맵핑된다.\n1\u0026lt;template\u0026gt; 2\t\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 3\t\u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt;\t4\t\u0026lt;/div\u0026gt; 5\u0026lt;/template\u0026gt; 라우터 링크 사용자에게 라우팅 된 경로로 이동하게끔 앵커태그를 생성하는 속성이다. router-link속성을 통해 앵커 태그 기능을 수행하게한다.\n1\u0026lt;router-link to=\u0026#34;/main\u0026#34;\u0026gt;main\u0026lt;/router-link\u0026gt; 2\u0026lt;!-- convert --\u0026gt; 3\u0026lt;a href=\u0026#34;#/main\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;main\u0026lt;/a\u0026gt; to속성에 동적으로 라우팅 경로를 생성시킬 수 있다. v-bind속성은 동적 경로를 생성하고 싶을 때 유용하다.\n1\u0026lt;router-link v-bind:to=\u0026#34;`/user/${item.username}`\u0026#34;\u0026gt;User-Info\u0026lt;/router-link\u0026gt; \u0026lt;!--./user/username --\u0026gt; 2\u0026lt;router-link to=\u0026#34;/user/\u0026#34;\u0026gt;USER\u0026lt;/router-link\u0026gt; \u0026lt;!--./user/ --\u0026gt; 스타일링 scoped속성을 통해 에서 해당 컴포넌트에서만 독립하게 사용하는 스타일을 입힐 수 있는데, 라우터 링크에서 사용되는 앵커태그의 기본 값은 router-link-exact-active이며, active-class속성을 통해 따로 정의할 수도 있다.\n1\u0026lt;template\u0026gt; 2\t\u0026lt;router-link to=\u0026#34;profile\u0026#34;\u0026gt; 3\t\u0026lt;h1\u0026gt;profile\u0026lt;/h1\u0026gt; 4\t\u0026lt;/router-link\u0026gt; 5\u0026lt;/template\u0026gt; 6\u0026lt;style scoped\u0026gt; 7\t.router-link-exact-active { 8\tcolor : red; 9\t} 10\u0026lt;/style\u0026gt; 동적 라우팅 url-path를 동적으로 요청받아 데이터를 넘길 수 있는 라우팅 방식이다. path끝에 :id를 붙이면 된다. (파라미터로 전달) 반대로 해당 파라미터 정보를 가져올 때는 $route 객체를 참조하면 된다. 만약 post/라는 url에 파라미터로 post id를 넘겨야한다고 생각해보자.\n1import AskItem from \u0026#39;../views/PostItem.vue\u0026#39;; 2const router = new VueRouter({ 3\troutes: [{ 4\tpath : \u0026#39;/post/:id\u0026#39; 5 component : PostItem 6\t}] 7}); 이제 사용자가 /post/123 이라는 url을 입력한다면, PostItem 컴포넌트에서는 \u0026lsquo;123\u0026rsquo;이라는 ID를 가진 내용을 API를 통해 요청받아야 할 것이다. this.$route.params.id를 통해 가져올 수 있다.\n1created() { 2 getPost(\u0026#39;requestPost\u0026#39;, this.$route.params.id); 3} 참고자료  캡틴판교님의 Vue 기초 강의 Vue Router - Vue 라우터 마이그레이션 Vue Router - 시작하기  ","date":"2021-08-23T22:54:41+09:00","image":"https://jinyisland.kr/../../assets/vue/vue.png","permalink":"https://jinyisland.kr/post/vue-router/","title":"Vue 라우터 개념 및 사용방법"},{"content":"클로저 개념 클로저는 쉽게말해 함수 선언시 생성되는 유효 범위이다.\n먼저 자바스크립트에서 클로저를 이해하려면 범위 지정(Lexical Scoping)을 이해하여야 한다.\n아래 코드를 보자.\n1var apple = \u0026#39;🍎\u0026#39;; 2 3function displayApple(){ 4\tconsole.log(apple); 5} 6 7displayApple(); 8//result : 🍎 간단하게 사과를 출력해주는 함수다.\n하지만, 정작 함수안에는 apple이라는 변수가 없는데도 불구하고 사과가 출력되었다.\n지난번 실행컨텍스트에서 언급했듯이 해당 유효범위에서 식별자를 찾지 못하면 점점 상위 ~ 전역으로 탐색한다. Scope Chain\n1var displayPrice; 2var apple = **\u0026#39;🍎\u0026#39;;** 3function displayApple(){ 4\tvar price = 1000; 5\tconsole.log(\u0026#39;**🍎\u0026#39;);** 6\tfunction setPrice(){ 7\tconsole.log(price + \u0026#39; won!!\u0026#39;); 8\t} 9\tdisplayPrice = setPrice; 10} 11 12displayApple(); 13noticePrice(); 그럼 위의 코드를 보면 맨 처음 사과를 보여주는 함수 내부에 사과 가격을 출력해주는 함수도 추가해보았다.\n이 함수는 전역 스코프에 정의되어있는 displayPrice에 할당하여 displayApple함수가 시행한 후 호출하였다.\n결론적으로 displayApple이 끝난 뒤 호출하는 noticePrice 함수 시행시 유효범위가 끝난 줄 알았던 내부함수가 잘 시행이 되었다!!\n어떤 원리로 이미 끝난 함수의 내부 함수를 호출할 수 있는 것일까?\n1/* 2**🍎** 3**🍎 41000 won!!** 5*/ 특징 먼저 외부함수(displayApple)내에서 내부함수(setPrice)를 선언하였을 때, 함수만 정의되는 것이 아니라 해당 시점의 유효 범위에 포함하는 모든 변수들도 같이 생성된다.\n따라서 외부함수를 먼저 실행하고 끝난 뒤 displayPrice가 참조하고있는 내부함수(setPrice)에 이미 끝난 시점임에도 불구하고 그 시점의 유효 범위에 접근할 수있게된다.\n클로저는 언제 어디서든 해당 함수 내부에 있는 스코프에 접근이 가능하지만, 그 만큼 비용이 발생된다는 것을 꼭 명심하자.\n(더 이상 해당 함수를 사용하는 곳이 없을 때나 페이지가 언로드될 때 까지 계속 메모리에 남아있는 일종의 족쇄같은 녀석이다.)\n또한 클로저는 단순히 해당 시점의 유효 범위 상태를 간직하고 있는 것이 아니라, 외부에 노출하지 않고 해당 유효 범위 상태를 수정할 수도 있다!\n클로저는 대체 언제사용할까? 그럼 클로저에 대한 개념은 알겠는데, 이 클로저를 언제 유용하게 사용할 수 있을까?\n은닉화 자바스크립트에서는 여타 언어와는 달리 접근 제어자를 명확하게 지원하지 않는다.\n클로저를 통해 변수의 유효 범위를 세밀하게 제어할 수 있다.\n1function Fruits(){ 2\tvar fruit = \u0026#39;🍎\u0026#39;; //private 3\t4\tthis.getFruit = function(){ 5\treturn fruit; 6\t} 7 8\tthis.setFruit = function(item){ 9\tfruit = item; 10\t} 11} 12 13fruits.getFruit(); //🍎 14fruits.fruit; //undefined 15fruits.setFruit(\u0026#39;🍇\u0026#39;); //사과를 포도로 바꾼다. 16fruits.getFruit(); //🍇 위 함수는 과일을 관리하는 생성자 함수이다.\n과일을 가져오는 getFruit()메서드와 설정하는 setFruit() 메서드가 존재한다.\n함수 수행결과와 같이 getFruit와 setFruit를 통해 함수 내부의 변수에 접근하는 것은 가능하지만, 직접적인 변수 접근엔 불가하다.\n즉, getFruit와 setFruit가 선언되면서 클로저를 생성함으로써 해당 유효범위에 있는 변수에 접근이 가능해진 것이다.\n참조형 반복문 반복문 내에 변수가 특정 변수를 계속 참조하고 있는 상황에서도 클로저를 활용해 유리하게 풀어나갈 수 있다.\n만약 setTimeout()함수에서 1초간격으로 특정 코드를 수행하는 로직을 짠다면 (예시로 각 초를 출력하도록..)\n1function countSec(seconds){ 2\tfor(var i=1; i\u0026lt;=seconds; i++){ 3\tsetTimeout(function(){ 4\tconsole.log(i); 5\t}, i*1000); //setTimeout에 인자로 들어가는 함수는 변수 i를 참조하지만, 이미 countSet()함수가 종료된 시점이라 최종 값으로 할당되었다.. 6\t} 7}; 8 9countSec(3); //4..4..4 예상과 달리 \u0026lsquo;4\u0026rsquo;만 3초동안 반복한다.\n이유는 setTimeout() 내부함수에서 생성한 변수가 자신 (생성하는 시점에 저장되어 있던 i) 을 기억하는 것이 아닌 생성된 i를 계속 참조하고 있기 때문에 이런 현상이 발생하는 것이다.\n이는 즉시실행함수를 통해 올바르게 동작시킬 수 있는데 반복할 때 마다 유효 범위에 i가 새로 정의되고 원하는 연산 값이 출력되는 것을 볼 수 있다.\n1function countSec(seconds){ 2\tfor(var i=1; i\u0026lt;=seconds; i++){ 3\t(function(curNum){ //즉시실행함수를 이용해 외부 변수 i를 복사하여 setTimout() 지역 변수로 끌어와 정상적으로 1,2,3 입력된다! 4\tsetTimeout(function(){ 5\tconsole.log(curNum); 6\t}, curNum*1000); 7\t}(i)); 8\t} 9}; 10 11countSec(3); //1..2..3 이러한 현상은 DOM 조작시에서도 발생할 수 있는데, 만약 특정 요소를 반복하면서 접근하는 경우에 발생된다.\n1\u0026lt;body\u0026gt; 2\t\u0026lt;button\u0026gt;First\u0026lt;/button\u0026gt; 3\t\u0026lt;button\u0026gt;Second\u0026lt;/button\u0026gt; 4\t\u0026lt;button\u0026gt;Third\u0026lt;/button\u0026gt; 5\u0026lt;/body\u0026gt; 1 var buttons = document.getElemnetByTagName(\u0026#39;button\u0026#39;); 2\tfor (var i = 0; i\u0026lt; buttons.length; i++){ 3\tbuttons[i].addEventListener(\u0026#39;click\u0026#39;, function(){ 4\tconsole.log(\u0026#39;clicked!\u0026#39; + i + \u0026#39; button!!\u0026#39;); 5\t}) 6\t} 만약 위와같이 단순하게 반복문으로 요소들의 이벤트를 트리거하는 상황이면, 이벤트 핸들러가 코드를 수행할 때 마지막에 저장된 i를 참조하게 된다.\n어떠한 버튼을 눌러도 3번째 버튼이라고 출력 될 것이다.\n이 역시 즉시시행함수로 바꿀 수 있다.\n1 var buttons = document.getElemnetByTagName(\u0026#39;button\u0026#39;); 2\tfor (var i = 0; i\u0026lt; buttons.length; i++)(function(n){ 3\tbuttons[i].addEventListener(\u0026#39;click\u0026#39;, function(){ 4\tconsole.log(\u0026#39;clicked!\u0026#39; + n + \u0026#39; button!!\u0026#39;); 5\t}); 6\t})(i); 참고자료  자바스크립트 닌자 비급 - 클로저와 가까워지기 (John Resig 저)  ","date":"2021-08-10T23:51:20+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/js-closure/","title":"자바스크립트 클로저"},{"content":"함수 자바스크립트의 함수는 객체로 취급 받는다. (일급객체)\n따라서 객체처럼 리터럴 방식으로 선언할 수 있고, new 연산자로 선언할 수도 있다. (대부분.. 리터럴 방식을 선호한다.)\n1//new 연산자 선언 2var sum = new Function(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;return a+b\u0026#39;); 3sum(1,3) //4 익명함수와 선언함수 익명 함수는 말 그대로 \u0026lsquo;이름을 갖지 않는\u0026rsquo; 함수이다.\n보통 변수에 저장해서 선언 후 호출한다.\n1add(2,3) //result : type error 2 3var add = function(x,y){ //익명함수 4\treturn x+y; 5} 6 7add(3,7); //result : 10 선언 함수는 함수 선언 시 이름을 지명한다.\n자바스크립트에서는 함수 선언을 변수를 지정하기 전 메모리에 미리 저장시키기 때문에 익명 함수 특성상 코드 상단에서도 실행시킬 수 있다.\n(이를 호이스팅이라 지칭하는데 단순히 코드 상단으로 옮겨지는 과정이라 생각하면 안되고, 실행 컨텍스트 입장에서 생각하여야 한다.)\n따라서 익명 함수는 변수에 저장 하기 때문에 미리 선언할 수 없고, 익명 함수는 선언하기 전에 실행문이 위치해도 문제가 없다.\n1add(2,3); //result : 5 2 3function add(x,y){ //선언함수 4\treturn x+y; 5} 6 7add(3,7); //result : 10 리턴 값 자바스크립트 함수는 return을 생략이 가능하다.\nreturn 문을 생략하는 함수는 반환물을 undefined로 반환한다.\n제어를 끝내려는 (단순 반환 지점으로 되돌림) 용도로 쓰이는 경우 undefined → boolean 값으로 false에 해당하므로 명확하게 표기하는 것은 return false로 표현하는 것이 낫다.\n함수는 객체로 취급받기 때문에 함수 반환 시 함수로도 반환해줄 수 있다는 것을 기억하자!\n1function notReturn(){ 2 console.log(\u0026#39;😝 돌려줄게 없다\u0026#39;); 3} 4 5if(notReturn()){ //return 생략 시 undefined로 반환 6 console.log(\u0026#39;true\u0026#39;); 7}else{ 8 console.log(\u0026#39;false\u0026#39;); 9} 10 11//result : false 매개변수 자바스크립트의 함수에도 역시나 유연한 성질을 갖고 있다.\n선언한 매개변수보다 많거나 더 작은 매개변수를 허용한다.\n1function displayFruit(fruits, price){ 2\tvar price = price || 0; 3\treturn fruits + price + \u0026#39;원\u0026#39;; 4} 5 6displayFruit(\u0026#39;🍒\u0026#39;); //\u0026#34;🍒0원\u0026#34; 7displayFruit(\u0026#39;🍒\u0026#39;, 2000); //\u0026#34;🍒2000원\u0026#34; 내부함수 함수 내부에 또 함수를 작성하는 패턴, 주로 여러 함수를 사용시 충돌 위험을 최소화하려고 사용한다.\n만약 외부함수와 내부함수의 이름이 갖다면 내부 함수부터 우선적으로 실행한다.\n(내부함수는 외부에서 접근할 수 없다, 자바스크립트는 함수 단위로 블록 스코프를 형성하기 때문이다.)\n1function pythagoras (wid, hei){ 2\tfunction square(x) { //내부함수 생성 3\treturn x*x; 4\t} 5\treturn Math.sqrt(square(wid) + square(hei)); //내부함수 호출 후 return 값 반환 6} 7 8pythagoras(2,3); 즉시실행함수 (IIFE) 함수를 정의함과 바로 동시에 실행되는 함수이다.\n최초 한 번의 실행만을 필요로 하는 함수에 사용할 수 있다.\n1(function (name){ 2\tconsole.log(name); //test 3})(\u0026#39;test\u0026#39;); 유명한 프레임워크인 jQuery에서도 즉시실행함수가 사용되었다.\n1(function(window, undefined){ 2 ..code 3})(window); 즉시실행함수도 함수이므로 변수에 저장이 가능하다.\n1(mySquare = function (x) { 2 console.log(x*x); 3})(2); 4mySquare(3); 5 6//result : 즉시실행함수 \u0026#39;mySquare\u0026#39;가 즉시 호출(2*2 = 4)되고, 곧이어 매개변수 \u0026#39;3\u0026#39;을 넘겨 재호출된다, 즉 재호출 가능하다. 7 8var mySquare = function (x) { 9 console.log(x*x); 10})(2); 11mySquare(3); 12console.log(mySquare(2)); 13 14//result : 특정 스코프 변수에 즉시실행함수를 담아두어 호출할 때만 사용할 수 있다. this 일반적으로 객체 내부에 정의된 함수를 메서드라고 지칭하는데, 함수에서 this키워드를 사용하면 해당 객체에 접근할 수 있다.\n반면 객체 내 함수의 내부 함수에서 this 키워드 호출 시 최상위 객체로 접근한다.\n만약 웹브라우저에서 특정 객체의 메서드가아닌 일반 함수를 호출한다면, 브라우저 최상위 객체인 window에 접근하는 것이다.\n1apple = \u0026#39;🍎\u0026#39;; //자바스크립트에선 변수 생략 시 window 객체에 저장한다. 2 3function callApple(){ 4\treturn this.apple; //최상위 객체인 window.apple 호출 5} 6 7callApple(); //\u0026#39;🍎\u0026#39; 반면 특정 객체내의 메서드 호출 시 해당 객체의 요소에 접근한다.\n1grape = \u0026#39;🫐\u0026#39;; 2var fruits = { 3\tgrape : \u0026#39;🍇\u0026#39;, 4\tcallGrape : function(){ 5\tfunction innerFunction(){ 6\tconsole.log(this.grape); //\u0026#39;🫐\u0026#39;; 7\t} 8\tinnerFunction(); 9\treturn this.grape; 10\t} 11} 12 13fruits.callGrape(); //\u0026#39;🍇\u0026#39; 위 예제를 그림으로 표현하면 아래와 같다. 함수를 호출하는 방법 지금까지 예제에선 ( )를 통해 함수를 호출했지만 call, apply메서드를 통해 함수를 호출할 수 있다.\ncall, apply 메서드를 사용하는 이유는 this 바인딩을 명시적으로 지정해줄 수 있기 때문이다.\ncall() call 메서드를 이용하여 함수를 호출시키고, this바인딩을 변경할 수 있다.\n1value = \u0026#39;🍏\u0026#39;; //window객체 2var nameObj = {value : \u0026#39;🍌\u0026#39;}; 3var gender = {value : \u0026#39;🍓\u0026#39;}; 4 5function getInfo() { 6\treturn this.value; 7} 8 9getInfo(); //일반 호출시 window.value(전역객체 value 출력) -\u0026gt; \u0026#39;🍏\u0026#39; 10getInfo.call(); //마찬가지로 window.value -\u0026gt; \u0026#39;🍏\u0026#39; 11getInfo.call(nameObj); // nameObj.value -\u0026gt; \u0026#39;🍌\u0026#39; 12getInfo.call(gender); //nameObj.value -\u0026gt; \u0026#39;🍓\u0026#39; apply() call() 메서드와 역할은 동일하나 리스트 형태로 프로퍼티들을 전달할 수 있다.\n1function Person(name, age, gender){ //생성자 함수 2\tthis.name = name; 3\tthis.age = age; 4\tthis.gender = gender; 5} 6 7var bindObj = {} //빈 객체 생성(bind 할 오브젝트) 8 9Person.apply(bindObj, [\u0026#39;name\u0026#39;,25,\u0026#39;man\u0026#39;]); //Person 함수를 호출하고, this는 bindObj 객체에 바인딩, 해당 프로퍼티를 Person에 전달 10console.dir(bindObj); //{name: \u0026#34;name\u0026#34;, age: 25, gender: \u0026#34;man\u0026#34;}; 프로토타입 프로토타입을 통해 객체가 가진 속성들에게 메서드를 공유할 수 있다.\n모든 함수는 객체이기 때문에, prototype 속성을 가지고 있는데 생성자 함수로 생성한 객체들도 그역시 프로토타입 객체를 참조한다.\n즉, 모든 자바스크립트 객체는 Object.prototype객체가 가진 프로퍼티와 메서드들을 서로 공유한다.\n(모든 객체들은 __proto__라는 부모 역할의 상위 프로토타입을 지니며, 최상위 프로토타입은 Object.prototype이다.)\n1//String 객체에 introduce 라는 메서드 정의, 모든 String 객체들은 이 메서드를 공유한다. 2String.prototype.introduce = function(){ 3 return \u0026#39;My Name is \u0026#39; + this ; 4} 5var name = \u0026#39;choi\u0026#39;; 6name.introduce(); //\u0026#34;My Name is choi\u0026#34; 7\u0026#39;kim\u0026#39;.introduce(); //\u0026#34;My Name is kim\u0026#34; 참고자료  자바스크립트 닌자 비급 - 함수를 자유자재로 휘두르기 (John Resig) 인사이드 자바스크립트 - 함수와 프로토타입 체이닝 (송형주, 고현준 저)  ","date":"2021-08-04T23:34:14+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/js-function/","title":"자바스크립트 함수, 이것만은 꼭 기억하자"},{"content":"원시타입과 참조타입 자바스크립트에서는 원시타입과 참조타입이 존재한다. 원시타입 그 자체가 값인 데이터 타입을 말한다.\n변수에 접근할 때 해당 변수에 저장된 실제 값을 조작한다.\n기본 값의 유형을 확인하려면 typeof연산자를 사용해서 확인할 수 있다.\n자바스크립트에서는 배열과 객체 모두 object로 취급한다는 사실을 꼭 잊지말자.\n1const typeNumeric = typeof 1; //number 2const typeBoolean = typeof true; //boolean 3const typeString = typeof \u0026#39;hello\u0026#39;; //string 4const typeFunction = typeof function(){ return;} //function 5const typeUndefined = typeof undefined; //undefined 6 7const typeObject = typeof {}; //object 8const typeArray = typeof [\u0026#39;1\u0026#39;]; //object 9const typeNull = typeof null; //object 참조타입 원시 값과는 달리 해당 객체의 참조에 대해서 작업한다.\n즉, 참조 값을 재할당하면 원래의 변수에 저장된 값도 새 변수의 위치로 복사된다.\n1const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;]; 2const newFruits = fruits; 3newFruits.push(\u0026#39;banana\u0026#39;); 4 5console.log(\u0026#39;fruits\u0026gt;\u0026gt;\u0026#39; + fruits); //fruits\u0026gt;\u0026gt; apple,mango,banana 6console.log(\u0026#39;newFruits\u0026gt;\u0026gt;\u0026#39; + newFruits); //newFruits\u0026gt;\u0026gt; apple,mango,banana 그럼 객체와 배열을 어떻게 판별할 수 있을까?\n배열 판별하기 배열은 isArray()메서드로 배열 타입임을 확인할 수 있다.\n1Array.isArray([1, 2, 3]); // true 2Array.isArray({foo: 123}); // false 3Array.isArray(\u0026#39;foobar\u0026#39;); // false 4Array.isArray(undefined); // false 객체 판별하기 자바스크립트에서는 객체를 판별하는것이 까다롭다.\n유사객체 타입이 많기 때문인데.. null타입과 array타입을 걸러내야 한다.\n1console.log(detectObject({})); //true 2console.log(detectObject([])); //false 3console.log(detectObject(null)); //false 4 5function detectObject(value){ 6 if(typeof value === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; value !==null \u0026amp;\u0026amp; !Array.isArray(value)){ 7 return true; 8 }else{ 9 return false; 10 } 11} 원시타입 자료형 Number 자바스크립트에서는 정수(int)든, 실수(double, float)이든 실수로 처리한다(모든 숫자는 Number 자료형).\n모든 숫자를 64비트 부동 소수점 형태로 저장하기 때문에 typeof 연산자 결과값이 number로 저장된다.\n따라서 숫자 계산시 매우 유연하게 계산할 수 있다.\n1let numberA = 15; 2let numberB = 15.2; 3numberA + numberB; //30.2 String 자바스크립트에서는 홀따옴표, 쌍따옴표 상관없이 문자를 표현할 수 있다.\n(웬만하면 일관성있게 사용하자, 나는 주로 홀따옴표를 선호한다 ㅎㅎ)\nconcat 메서드등 문자열도 배열에서 제공하는 여러 메서드들을 몇개 쓸 수는 있지만, 연산시 객체로 변환했다가 다시 문자열로 내부적으로 처리된다.\n사실 concat보단 +연산자를 주로 쓴다..\n1const text = \u0026#39;abcdefg\u0026#39;; 2const message = \u0026#34;hello\u0026#34;!; 3 4text + message; //abcdefghello! 5text.concat(message); //abcdefghello! null과 undefined 자바스크립트에서 값이 비어있음을 나타내는 자료형이다.\nundefined는 할당되지 않은 변수의 초기값이며 변수 자체의 값 또한 undefined 이다.\nnull을 확인하고자 할 때 typeof의 결과는 object이기 때문에 일치 연산자(===)를 사용해야만 한다.\n1var nullChk = null; 2 3console.log(typeof nullChk == null); //false 4console.log(nullChk === null); //true 참조타입 자료형 배열 자바스크립트의 배열은 타 언어의 배열과 비교햇을 때, 좀 더 유연한 성질을 가지고 있다.(이 점을 주의하여야 한다.)\n다음과 같은 특징을 가지고 있다.\n 배열의 length는 실제 배열에 존재하는 원소 개수와 일치하는 것은 아니다. 배열의 Index는 자유이다, 가장 큰 Index 기준으로 length 값이 늘어난다. (실제 메모리가 늘어나는 것은 아니다.) 배열도 객체이므로 for in루프를 사용할 수 있지만, 불필요한 프로퍼티가 출력될 수 있으므로 일반 for문을 사용하는것이 성능적으로도 낫다. 배열에서 delete()메서드로 요소를 삭제하면 오직 undefined로 초기화만 해준다, 실질적으로 삭제하려면 splice()메서드를 사용해야만 한다.  배열 반복문 for\n지정한 길이(array.length) 만큼 반복하며 요소에 접근할 수 있다.\n1const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;]; 2for(let i=0; i\u0026lt;fruits.length; i++){ 3\tconsole.log(fruits[i]); 4} forEach()\n배열의 각 요소에 한번씩 callback을 수행한다. (breack 불가)\n초기화되지 않은 원소들은 건너뛴다.\n배열의 사본을 생성하지 않으므로 참조하고 있는 경우 주의가 필요하다.\n1const arr = [\u0026#39;banana\u0026#39;, \u0026#39;kiwi\u0026#39;]; 2//일반 함수표현식 3arr.forEach(function(element){ 4\tconsole.log(element); 5}); map()\nforEach()와 마찬가지로 요소를 순회하면서 표현식을 수행한다.\n큰 차이는 계산한 값들을 모아 새 배얄로 반환한다.\n성능이 느리긴하지만, 부수효과를 발생시키지 않는다는 장점이 있다.\n1// 원소 100개의 배열을 생성하기 2const arr = Array(100).fill().map(function(item, index){ 3 return index; 4}); //[0~99] 배열을 생성하므로 변수에 담아 사용할 수 있다. (기존 배열에는 영향을 끼치지 않는다.)\n1const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;]; 2const newFruits = fruits.map(function(){ 3 return \u0026#39;NEW\u0026#39;+value; 4}); 5 유용한 메서드 splice()\n배열 내부요소에 대해 제거하거나 제거한 위치에 값을 추가할 수 있다. (원본배열 수정)\nreturn 값은 제거된 요소만 담어서 반환한다. 제거한 요소가 없다면 빈 배열을 반환한다.\n1const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;]; 2const newFruits = fruits.splice(fruits.length, 0, \u0026#39;kiwi\u0026#39;); //맨끝에 키위 추가 3const emptyFruits = fruits.splice(0, 1); //0번째 인덱스부터 \u0026#39;1\u0026#39;개 요소 제거 4 5console.log(fruits); //[\u0026#39;kiwi\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;mango\u0026#39;] 6console.log(newFruits); //제거한 요소가 없으므로 빈값 [] 7console.log(emptyFruits); //제거한 요소 [apple] slice()\n원본 배열을 해치지 않고 얉은 복사본을 생성해 새 배열로 반환해준다.\n1const animals = [\u0026#39;ant\u0026#39;, \u0026#39;bison\u0026#39;, \u0026#39;camel\u0026#39;, \u0026#39;duck\u0026#39;, \u0026#39;elephant\u0026#39;]; 2 3console.log(animals.slice(2)); 4// expected output: Array [\u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;, \u0026#34;elephant\u0026#34;] 5console.log(animals.slice(2, 4)); 6// expected output: Array [\u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;] 7console.log(animals.slice(1, 5)); 8// expected output: Array [\u0026#34;bison\u0026#34;, \u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;, \u0026#34;elephant\u0026#34;] 객체 객체는 정적인 정보에 적합하다. (반복, 갱신, 대체가 필요한 정보에는 적합하지 않다.)\n자바스크립트에서의 객체는 타 언어와 다르게 여려 type의 프로퍼티들을 담을 수 있다.\n객체 생성하기 생성자 방식, 리터럴 방식으로 객체를 생성할 수 있는데 리터럴 방식으로 생성하기를 권고하고 있다. (성능, 안정)\n1//생성자 방식 2const fruits = new Object(); 3fruits.name = \u0026#39;grape\u0026#39;; 4fruits.price = 3000; 5 6//리터럴 방식 7const fruits2 = { 8 namae : \u0026#39;grape\u0026#39;, 9 price : 3000 10} 대괄호표기법과 마침표표기법 보통 마침표(.)를 이용해서 프로퍼티에 접근 하지만, 특별한 상황에선 배열처럼 대괄호([])를 이용해서 접근해야한다. (프로퍼티명이 표현식이거나 예약어일 경우)\n1const userInfo = { 2 name : \u0026#39;jiny\u0026#39;, 3 age : \u0026#39;25\u0026#39;, 4 gerder : \u0026#39;male\u0026#39;, 5}; 6 7//마침표표기법 (일반 접근) 8const userName = userInfo.name; 9 10//대괄호표기법 (예약어 or 표현식) 11userInfo[\u0026#39;favorite-game\u0026#39;] = \u0026#39;FIFA\u0026#39;; 12console.log(userInfo[\u0026#39;favorite-game\u0026#39;]); 유용한 객체 메서드 Object.keys()\n객체의 요소들을 배열로 반환한다. Object.values()\n객체의 프로퍼티 값 (value)를 배열로 반환한다.\n1const userProperties = Object.keys(userInfo); //[\u0026#39;jiny\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gerder\u0026#39;] 2const userValues = Object.values(userInfo); //[\u0026#39;jiny\u0026#39;, \u0026#39;25\u0026#39;, \u0026#39;male\u0026#39;] Object.entries()\n객체의 [Key, Value] 형태의 배열로 반환한다.\n1const userlist = Object.entries(userInfo( //[[\u0026#34;name\u0026#34;,\u0026#34;jiny\u0026#34;],[\u0026#34;age\u0026#34;,\u0026#34;25\u0026#34;],[\u0026#34;gerder\u0026#34;,\u0026#34;male\u0026#34;]] 객체 사용 시 주의점 객체 또는 배열에서 속성이 제대로 정의되지 않으면 오류를 반환한ㄷ나.\n따라서 객체의 속성과 배열의 요소가 정상적으로 포함되어있는지 판단하는 검증이 필요하다.\n1const imageInfo_1 = {} //속성이 정의되지 않음 2const imageInfo_2 = {file : []} //배열 개체가 없음 3const imageInfo_3 = {file : [\u0026#39;app.png\u0026#39;, \u0026#39;thumb.jpg\u0026#39;]} //정상 4function getImagePath(imageObject){ 5 //객체의 속성, 배열 요소 검사 6 if(imageObject.file \u0026amp;\u0026amp; imageObject.file.length \u0026gt; 0){ 7 //..code 8 return; 9 }else{ 10 return [`http://root/image/default.jpg`]; 11 } 12} 조건문 자바스크립트에서 판독하는 거짓(false)의 값은 다음과 같다.\n false null 0 NaN \u0026quot;\u0026quot;, \u0026lsquo;'  삼항 연산자 분기를 더욱 단순하게 표현할 수 있다.\n1const path = \u0026#39;img/app.jpg\u0026#39;; 2if(path){ 3\treturn path; 4}else{ 5\treturn \u0026#39;\u0026#39;; 6} 7 8//삼항 연산자 9return path ? path : \u0026#39;\u0026#39;; OR 연산자 OR 연산자 (||)로 검사한 값 중 하나가 true를 바환하면, 확인한 값을 곧바로 할당할 수 있다.\ndefault값을 할당하기에 더욱 편하다.\n1const path = \u0026#39;img/app.jpg\u0026#39;; 2function getImagePath(url){ 3 const path = url || \u0026#39;img/default.jpg\u0026#39;; 4 return \u0026#39;http://root\u0026#39; + path; 5} 6 7console.log(getImagePath(path)); // http://root/img/app.jpg 8console.log(getImagePath()) // http://root/img/default.jpg 참고자료  모던웹을 위한 자바스크립트 + JQuery 입문 - 자료형 (윤인성 저) 인사이드 자바스크립트 - 데이터 타입과 연산자 (송형주, 고현준 저)  ","date":"2021-08-03T21:38:58+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/datatype/","title":"자바스크립트에서의 데이터 타입"},{"content":"Google Analytics 4 내 블로그의 정적 웹사이트 호스팅 플랫폼은 hugo를 쓰고 있다.\n예전에 잠깐 썼던 Jekyll 플랫폼과 비교했을 때 배포속도도 빠르고 테마 문서도 잘 되어있어서 편하다 ㅎㅎ\n원래 SEO에 대해 신경 쓰지 않고있다가, GoogleAnaytics와 GoogleSearchConsle을 적용시켜보려고 이것저것 시도해봤지만, 아직도 구글 애널리틱스 보고서에는 방문자가 0이다..\n(사실 진짜 0명인줄 알았으나 내가 들어와있어도 실시간에는 0이다..)\n새로운 추적 ID 구글링을 통해 알아본 휴고에 구글 애널리틱스 적용하는 글들을 보면, config.toml에 GoogleAnalytics변수에 그냥 추적 ID를 넣으면 끝이라는 내용이 많아 실제로 그렇게 해보았는데 적용이 안되고 있다.\n그리고 대다수의 사용자 추적 ID는 GA-XXXXXXX..으로 되어있는데 나는 G-XXXXXXXX.. 이렇게 조금 다르기도 하다.\n다시 구글링을 해 본 결과, 현재 시점에선 GoogleAnaytics의 버전이 4이며 휴고 테마에서 GA 설정을 지원해주지 않는 이상 스크립트 태그를 직접 넣어야된다는 사실을 알게 되었다..\nGoole Analytics4 적용 방법 먼저 필자의 Hugo 테마는 stack theme를 사용하고 있다.\n이 테마는 아직 GoogleAnaytics에 대한 설정 컴포넌트가 존재하지 않아 직접 해보기로 하였다.\n1. GoogleAnalytics4 가입하기\n먼저 구글 계정으로 GoogleAnalyticd4 페이지에서 로그인한다.\n로그인 후 측정시작 버튼을 눌러 구글애널리틱스 계정을 생성하면된다.\n참고로 구글 ID와 별개로 계정을 생성할 수 있으며 원하는 ID로 만들면된다. 그 후 속성 이름도 사이트에 걸맞는 속성이름으로 짓자.\n2. 추적 ID 가져오기\nGA에는 고유적으로 추적에 사용할 ID가 주어지는데 GA관리자 화면서 하단 관리 -\u0026gt; 데이터 스트림 -\u0026gt; 스트림 항목을 클릭하면 측정 ID를 얻을 수 있다. (양식은 G-XXXXXXXXX)\n3. Hugo에 적용시키기\n이제 이 추적 ID를 휴고에 적용시키면 끝!\nconfig.toml에 추적 ID를 사용 할 변수로 지정해놓는다.\n1[params] 2googleAnalytics = \u0026#34;G-XXXXXX\u0026#34; 3. 4. 구글 애널리틱스에서 제공하는 온페이지 태그를 추가해야한다.\n휴고에서는 보통 ./layout/partials디렉토리에 사이드 html을 작성해주기 때문에 구글 애널리틱스 스크립트를 위한 html을 작성한다.\nSite.Params부분에 config.toml에 정의한 추적 ID 변수를 적어주면 된다.\n1\u0026lt;!-- layout/partials/google-analytics.md--\u0026gt; 2\u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id={{ .Site.Params.googleAnalytics }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3\u0026lt;script\u0026gt; 4 window.dataLayer = window.dataLayer || []; 5 6 function gtag() { 7 dataLayer.push(arguments); 8 } 9 gtag(\u0026#39;js\u0026#39;, new Date()); 10 11 gtag(\u0026#39;config\u0026#39;, \u0026#39;{{ .Site.Params.googleAnalytics }}\u0026#39;); 12\u0026lt;/script\u0026gt; 이제 휴고 블로그에 모든 페이지에서 이 스크립트를 로드해주면 된다.\n보통 전역에서 사용할 html은 /layout/_default/baseof.html에 작성한다.\n1\u0026lt;head\u0026gt; 2 {{ if .Site.Params.googleAnalytics }} 3 {{ partial \u0026#34;google-analytics.html\u0026#34; . }} 4 {{ end }} 5 {{- partial \u0026#34;head/head.html\u0026#34; . -}} 6 {{- block \u0026#34;head\u0026#34; . -}}{{ end }} 7\u0026lt;/head\u0026gt; 여기까지 설정하면 구글애널리틱스에서 접속 현황이 잘 노출이된다!\n깃에 배포하고 다시 블로그에 들어가면 아래 사진 처럼 잘 나오는 것을 확인할 수 있다.\n","date":"2021-07-30T22:15:51+09:00","image":"https://jinyisland.kr/../../assets/web/web.png","permalink":"https://jinyisland.kr/post/hugo-ga/","title":"GoogleAnalytics 4 휴고 블로그에 적용 시키기"},{"content":"자바스크립트의 특징 나는 주로 자바스크립트를 이용해 개발을하는 것을 좋아한다.\n내 기준 가장 자신있는 언어이기도 하고, 배우면서 흥미로움을 느낀 프로그래밍 언어 중 하나였다.\n하지만 자바스크립트는 쓰면 쓸수록 헷갈리는 개념도 많고, 처음엔 만만하게 보였지만 깊이 들어갈수록 난해한..언어이기도 하다.. (아직도 어렵다 ㅠㅠ)😵\n자바스크립트에 대한 핵심적인 내용을 짚고 넘어가고자 해당 시리즈를 포스팅하기로 마음 먹었다! 첫 번째는 자바스크립트는 어떻게 동작할까?\n유연한 언어 자바스크립트에서의 타입 체크는 타 언어보다 굉장히 유연하고 느슨하다. 아래 예시를 보면 보통의 언어 같으면 컴파일 단계에서 들어오지 않은 값에 대해 오류를 내뿜어내지만, 자바스크립트에서는 일단 처리를 한다.\n제대로 타입체크를 하지 않으면 undefined(알 수 없음), NaN(숫자가 아님)등의 원치않는 값들이 런타임 단계에서 출력되기도 한다.\n이런 유연함과 느슨함이 장점이자 단점이 되는것이 개발자에게 자유를 보장하지만, 자칫 검증을 제대로 하지 않을 경우 그 책임도 개발자에게 발생한다.\n1function add(a, b){ 2\treturn a + b; 3} 4 5add(1, 2); //3 6add(\u0026#39;1\u0026#39;+2); //\u0026#39;12\u0026#39; 7add(1); //NaN 객체와 함수가 핵심 자바스크립트의 거의 모든 것은 객체이다. 객체는 값의 속성을 나타내는 key와 속성을 표현하는 value로 구성되어 있다.\n객체는 리터럴 방식으로 생성하는 방식과, 생성자 방식으로 생성하는 방식이 있다.\n1var fruit = { 2\tname : \u0026#39;apple\u0026#39;, 3\tprice : 1200 4} 5 6var food = new Object(); 7food.name = \u0026#39;ramen\u0026#39;; 8food.price = 1500; 9 10//동적으로 추가 및 삭제도 가능하다. 11fruit.color = \u0026#39;red\u0026#39;; //fruit 객체에 color 속성 추가 12delete(food.price); //food 객체의 price 속성 삭제 boolean, number, string, null, undefined타입을 제외한 나머지는 모두 객체로 구성되어 있다.\n심지어 함수도 객체이다. 일반적인 객체보다 더 많은 기능이 있는 객체 정도로 생각하면 된다.\n1typeof [1, 2, 3] //\u0026#34;object\u0026#34; 2typeof {name : \u0026#39;jiny\u0026#39;} //\u0026#34;object\u0026#34; 3typeof new Date() //\u0026#34;object\u0026#34; 4typeof funtion(){} // \u0026#34;function\u0026#34; 위의 예제를 보면 배열은 객체로 취급하는것을 알 수 있지만, 함수는 자료형 검사시 \u0026ldquo;function\u0026quot;으로 출력되기 때문에 객체로 자료형을 인식하지 않는다고 생각할 수 있다.\n하지만 함수도 엄연하게 객체로 취급받는다. 이유는 여러가지가 있지만 아래 2가지 핵심적인 이유가 있다.\n 함수도 변수에 할당 가능하다. 자바스크립트에서의 일반 객체Object처럼 취급할 수 있다. 함수에 사용자 정의 속성을 추가하는 것도 가능하다.  1function log(msg){ 2\treturn msg; 3} 4//함수 log에 속성 추가 5log.author = \u0026#39;jiny\u0026#39;; 6log.execute = log(\u0026#39;hello\u0026#39;); 7 8console.log(log.author); //\u0026#39;jiny\u0026#39; 9console.log(log.execute); //\u0026#39;hello\u0026#39; 함수도 값으로 취급한다. 함수를 이용해 할 수 있는 것은 마치 객체를 이용해 할 수 있는 것과 같다. (이를 일급 객체라고 정의한다.)   리터럴 생성 마치 객체 리터럴 생성 방식과 유사하게 함수도 선언과 동시에 빠르게 작성할 수 있다.  1function add(a,b){ 2\treturn a + b; 3}  변수나 배열의 요소 혹은 객체의 속성에 할당할 수도 있다.  1//변수에 할당 2var add = function(a,b){ 3\treturn a + b; 4} 5 6//객체 속성에 할당 7var calculator = { 8\tadd : add 9} 10//배열에도 할당 11var sampleArray = [0, \u0026#39;1,\u0026#39;, add]  함수의 인자로 전달가능하고, 리턴값으로도 사용할 수 있다.  1var success = function(){ 2\tconsole.log(\u0026#34;success\u0026#34;); 3} 4 5//add 함수에 success 함수를 3번째 인자로 넘기는 코드 6function add(a, b, callback){ 7\tvar result = a + b; 8\tif(!isNaN(result){ 9\treturn callback() 10\t} 11} 12 13//함수 실행 14add(1,2,success); 자바스크립트가 실행되는 과정 콜스택 자바스크립트에서는 실행 컨텍스트라는 콜스택 처리 방식으로 코드들을 실행한다.\n콜스택은 함수들을 호출(Call)하는 호출 정보들을 스택(Stack)에 차곡차곡 쌓여 있는 것을 의미한다.\n제일 나중에 올려져있는 스택부터 처리하기 때문에 선언한 코드들을 블록단위로 호출 스택에 쌓아놓고 하나씩 반환하면서 코드들을 실행한다.\n1console.log(\u0026#34;global stack\u0026#34;); 2 3function firstExecute(){ 4\tconsole.log(\u0026#34;first!\u0026#34;); 5} 6 7function secondExecute(){ 8\tfirstExecute() 9\tconsole.log(\u0026#34;second!\u0026#34;); 10} 11 12secondExecute(); 13 14/* 15global stack 16first! 17second! 18*/ 위 코드를 콜스택 구조로 표현하자면 아래와 같다.\n설명을 하자면 먼저 유호범위 최상위에 있는 console.log 메서드 부터 스택에 삽입된다. 호출스택에 모두 쌓이고 실행을 시키는 것이아니라 스택에 쌓는 순간 해당 컨텍스트가 실행된다.\n실행이 끝나면 다시 콜스택에서 반환이 되면서 콜스택에 쌓인 컨텍스트를 모두 비워내게 되는것이다.\n실행 컨텍스트 그럼 좀 더 자세하게, 실행 컨텍스트에는 어떤일이 일어날까?\n먼저, 해당 실행 컨텍스트에서 사용할 매개변수나 정의한 변수들이 생성된다. 즉, 실행 컨텍스트를 수행하기 위한 사전 작업을 하는 것이다. (이는 자바스크립트 엔진 내부에서 일어난다.)\n그리고 arguement 객체를 생성하는데 이는 호출할 때 넘긴 인자들이 저장되어 있는 객체라고 보면 된다. (배열이지만 객체다!)\n1function add(a, b){ 2\t//code 3} 그 다음, 현재 컨텍스트의 유효 범위를 나타내는 스코프 정보를 생성하는 작업을 하게된다.\n리스트 형태로 만들어지는데 이 스코프 리스트를 활용해 상위 컨텍스트의 변수에 접근하거나, 해당 컨텍스트의 변수에 접근할 수 있다.\n이 스코프 리스트는 서로 연결되어 있어 (해당 컨텍스트 범위에 없으면 상위 컨텍스트 범위에서 찾는다..)스코프 체인으로 불린다.\n1var number = 2; 2function add(a, b){ 3\treturn a + b + number; 4} 해당 함수안에서 매개변수를 사용 할 수 있고, 스코프 체인을 통해 외부의 변수들도 사용할 수 있는 상태이다.\n이제 생성된 지역 변수가 변수 객체로 만들어진 후에 해당 코드 범위안에 있는 여러 계산실행이 이루어진다.\n만약 값이 할당되지 않았거나, 넘겨 받지 못했다면 undefined로 할당되어버린다.\n1var number = 2; 2function add(a, b){ 3\tvar result = a + b + number; 4\treturn result; 5} 6 7add(2,3); 그동안 얕게나마 알고 있는 이 중요한 개념들을 다시 책을 찾아보고 정리하느라 애먹었다..\n더 깊게 들어가면 끝도 없이 여러 개념들이 즐비하게 나온다..ㅠㅠ 이 장에서는 2가지만 기억하면 될 것 같다!\n1. 자바스크립트는 거의 모든 것들이 객체로 구성되어 있다. (심지어 함수까지도..)\n2. 자바스크립트 엔진은 콜스택 기반의 실행컨텍스트(Execution Context)를 생성하며 코드들을 실행한다.\n참고자료  모던웹을 위한 자바스크립트 + JQuery 입문 - 객체 (윤인성 저) MDN - typeof 인사이드 자바스크립트 - arguments 객체 및 실행 컨텍스트 (송형주, 고현준 저)  ","date":"2021-07-27T23:47:42+09:00","image":"https://jinyisland.kr/../../assets/js/js.png","permalink":"https://jinyisland.kr/post/how-js-work/","title":"자바스크립트는 어떻게 동작할까?"},{"content":"윈도우에서 작업한 Vue 프로젝트를 mac 환경에서 확인하려던 중 git clone 후 프로젝트를 실행해보니 아래와 같은 에러가 나왔다.\n1\u0026gt; vue-todo@0.1.0 serve /Users/sjchoi/Mydoc/02_Code/05_vue/vue-practice/vue-todo 2\u0026gt; vue-cli-service serve 3 4sh: vue-cli-service: command not found 5npm ERR! code ELIFECYCLE 6npm ERR! syscall spawn 7npm ERR! file sh 8npm ERR! errno ENOENT 9npm ERR! vue-todo@0.1.0 serve: `vue-cli-service serve` 10npm ERR! spawn ENOENT 11npm ERR! 12npm ERR! Failed at the vue-todo@0.1.0 serve script. 13npm ERR! This is probably not a problem with npm. There is likely additional logging output above. 14npm WARN Local package.json exists, but node_modules missing, did you mean to install? 15 16npm ERR! A complete log of this run can be found in: npm은 당연히 설치되어있는데 왜그러는지 몰라 한참을 찾아보다가 npm 캐시를 지워주면 된다는 말을 듣고 캐시를 지우고 다시 package.json에 정의된 모듈을 설치하였더니 잘 된다!\n1npm cache clean --force #npm 캐시 삭제 2npm install #package.json 의존하는 모듈 설치 만약 npm install을 시행해도, 프로젝트 실행이 안된다면, npm run serve 중 필요한 라이브러리를 설치하라고 뜰테니 해당 라이브러리를 설치하고 시행하면 잘 된다.\n","date":"2021-07-18T23:09:02+09:00","image":"https://jinyisland.kr/../../assets/vue/vue.png","permalink":"https://jinyisland.kr/post/vue-import/","title":"외부 Vue 프로젝트 불러오기"},{"content":"컴포넌트 개념 화면의 영역을 분리하여 개발하는 것, Vue에서 최상위 컴포넌트는 root이다.\n컴포넌트 구성의 장점은 요소들을 재사용함으로써 개발 생산성이 향상되고, 컴포넌트들은 서로 관계가 형성된다.\n전역 컴포넌트 주로 플러그인, 라이브러리 등 앱 전역에서 사용 할 공통 컴포넌트를 작성한다.\n전역 컴포넌트를 생성하면 새 인스턴스를 생성할 때 마다 기본적으로 생성한다.\n1//컴포넌트 생성 2Vue.component(\u0026#39;app-header\u0026#39;, { 3 template: \u0026#39;\u0026lt;h1\u0026gt;header\u0026lt;/h1\u0026gt;\u0026#39; //component Template 4}); 5 6Vue.component(\u0026#39;app-content\u0026#39;, { 7 template: \u0026#39;\u0026lt;p\u0026gt;This is Vue-Component Write\u0026lt;/p\u0026gt;\u0026#39; 8}); 9 10//인스턴스 생성 11new Vue({ 12 el: \u0026#39;#app\u0026#39; //selector 13}); 지역 컴포넌트 Vue 인스턴스 내에 직접 삽입하는 방식이다. components로 정의한다.\nTree 구조로 구성할 수 있으며, 부모-자식 간 컴포넌트 사이 통신이 가능하다.\n지역 컴포넌트는 해당 인스턴스에서만 동작한다. 따라서 인스턴스를 새로 생성할 때 마다 컴포넌트를 등록해주어야 한다.\n1new Vue({ 2 el: \u0026#39;#app\u0026#39;, //selector 3 components: { 4 //지역 컴포넌트 정의 5 \u0026#39;app-footer\u0026#39;: { 6 template: \u0026#39;\u0026lt;footer\u0026gt;Footer!\u0026lt;/footer\u0026gt;\u0026#39; 7 } 8 } 9}); Template 템플릿 내에 생성한 컴포넌트를 태그로 지정한다.\n1\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 2 \u0026lt;!--컴포넌트에 등록한 템플릿 지정--\u0026gt; 3 \u0026lt;app-header\u0026gt;\u0026lt;/app-header\u0026gt; 4 \u0026lt;app-content\u0026gt;\u0026lt;/app-content\u0026gt; 5\u0026lt;/div\u0026gt; 컴포넌트 통신 방식 Vue 컴포넌트는 각 고유한 데이터 유효범위를 갖는다.\n부모 컴포넌트의 데이터가 바뀌면 하위 컴포넌트의 데이터가 바뀌지만, 반대로 하위 컴포넌트의 데이터가 바뀌면 부모 컴포넌트가 바뀌지 않는다. (단방향 흐름)\nprops 상위 컴포넌트에서 하위 컴포넌트로 데이터 전달 시 사용한다.\nvue에서는 v-bind디렉티브로 속성에 접근할 수 있는데, 하위 컴포넌트에서 상위 컴포넌트의 데이터 속성에 접근이 가능하다.\n자세하게 말하면, v-bind로 해당 컴포넌트에서 정의된 props 속성에 접근할 수 있고 props의 역할은 부모의 data영역에 접근할 수 있게 해주는 속성이라고 볼 수 있다.\n1\u0026lt;!--template--\u0026gt; 2\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 3\t\u0026lt;app-header v-bind:propsdata=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/app-header\u0026gt; 4\u0026lt;/div\u0026gt; 1//하위 컴포넌트 2var appHeader = { 3 template: \u0026#39;\u0026lt;h1\u0026gt;header\u0026lt;/h1\u0026gt;\u0026#39;, 4 props: [\u0026#39;propsdata\u0026#39;] 5} 6 7// Vue 인스턴스 (root 컴포넌트) 8new Vue({ 9 el: \u0026#39;#app\u0026#39;, 10 components: { 11 \u0026#39;app-header\u0026#39;: appHeader 12 }, 13 data: { 14 message: \u0026#39;hello Vue~~!!\u0026#39; 15 } 16}); emit props와는 반대로 하위 컴포넌트에서 상위 컴포넌트로 이벤트를 전달할 수 있다.\n이벤트를 전달함으로써, 콜백내 this를 통해 상위 데이터에 접근하는 방법이다.\n컴포넌트 methods 속성 내에 여러 이벤트들을 정의할 수 있는데, 정의한 custom event를 트리거하려면 $emit메서드에 이벤트 이름을 전달하면 된다.\n1 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 2 \u0026lt;app-content v-on:add=\u0026#34;addNumber\u0026#34;\u0026gt;\u0026lt;/app-content\u0026gt; 3 \u0026lt;p\u0026gt;number : {{number}}\u0026lt;/p\u0026gt; 4 \u0026lt;/div\u0026gt; 1 //하위 컴포넌트 2 const appContent = { 3 template: \u0026#39;\u0026lt;button v-on:add=\u0026#34;addNumber\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt;\u0026#39;, 4 methods: { 5 addNumber: function (params) { 6 this.$emit(\u0026#39;add\u0026#39;); //상위 컴포넌트에 binding 할 이벤트 7 } 8 } 9 } 10 11 //Vue 인스턴스 (root) 12 const vueObject = new Vue({ 13 el: \u0026#39;#app\u0026#39;, 14 components: { //local component 15 \u0026#39;app-content\u0026#39;: appContent 16 }, 17 methods: { 18 addNumber: function () { 19 //this 키워드로 정의한 data에 접근 가능 20 console.log(this.number++); 21 } 22 }, 23 data: { 24 number: 1 25 } 26 }); 동등 컴포넌트 간 통신   내가 생각하는 컴포넌트 통신 실제로 기존 DOM 조작 방식(JQuery)에 익숙한 나는 위의 사진처럼 종속관계가 아니어도 값을 주고받을 수 있을줄 알았으나, 아래와 같이 해야한다고 한다.\n  실제 컴포넌트 통신 방법 위에 설명했던 컴포넌트의 특성을 살려 동등 레벨의 컴포넌트(부모가 동일한)가 데이터를 전달하려면, emit(상위 컴포넌트로 전달) -\u0026gt; props(하위 컴포넌트로 전달) 과정을 거쳐야 한다.\n  만일 같은 레벨의 header와 footer 사이 데이터 전달이 필요하다면 먼저 body에 데이터를 전달해야한다. ($emit)\n1\u0026lt;div id=\u0026#34;body\u0026#34;\u0026gt; 2 \u0026lt;app-header\u0026gt;\u0026lt;/app-header\u0026gt; 3 \u0026lt;app-footer v-on:message=\u0026#34;bindData\u0026#34;\u0026gt;\u0026lt;/app-footer\u0026gt; 4\u0026lt;/div\u0026gt; 1//footer 컴포넌트 2const footer = { 3 template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;h3\u0026gt;FOOTER\u0026lt;/h3\u0026gt;\u0026lt;button v-on:click=\u0026#34;passData\u0026#34;\u0026gt;trans-data\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;, 4 methods: { 5 passData: function () { 6 this.$emit(\u0026#39;message\u0026#39;, \u0026#39;footer-data\u0026#39;); //해당 이벤트에 파라미터 전달 7 } 8 }, 9} 10 11new Vue({ 12 el: \u0026#39;#body\u0026#39;, 13 components: { 14 \u0026#39;app-header\u0026#39;: header, 15 \u0026#39;app-footer\u0026#39;: footer 16 }, 17 data: { 18 message: \u0026#39;test\u0026#39; 19 }, 20 methods: { 21 bindData: function (param) { 22 this.message = param; 23 } 24 }, 25}); 이제 부모의 message는 하위 컴포넌트에서 전달한 데이터로 변경이 되어있다.\nprops속성을 통해 접근하면된다.\n1\u0026lt;app-header v-bind:headerdata=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/app-header\u0026gt; 1//header 컴포넌트 2const header = { 3 template : \u0026#39;\u0026lt;h2\u0026gt;Header\u0026lt;/h2\u0026gt;\u0026#39;, 4 props : [\u0026#39;headerdata\u0026#39;] 5} 참고자료  Vue 공식문서 - vm-emit 캡틴판교님의 Vue 기초 강의  ","date":"2021-07-01T21:27:40+09:00","image":"https://jinyisland.kr/../../assets/vue/vue.png","permalink":"https://jinyisland.kr/post/vue-component/","title":"Vue 컴포넌트에 대한 개념"},{"content":"CLI? cli란 Command Line Interface, 즉 명령어 기반의 인터페이스 환경을 의미한다.\nvue 프로젝트 도입시 전체적인 웹애플레이케이션을 관리하려면 지금 소개하는 cli패키지를 설치하면 되고,\n별도의 페이지에서 국한적으로 사용하려면 cdn방식으로도 사용할 수 있다.\nCDN 방식을 사용하려면 아래 소스를 참고하면 된다.\n1\u0026lt;head\u0026gt; 2 \u0026lt;!-- Vue-CDN --\u0026gt; 3 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4\u0026lt;/head\u0026gt; 5\u0026lt;body\u0026gt; 6 \u0026lt;!-- template --\u0026gt; 7 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 8 \u0026lt;app-footer\u0026gt;\u0026lt;/app-footer\u0026gt; 9 \u0026lt;/div\u0026gt; 10\u0026lt;/body\u0026gt; 11\u0026lt;script\u0026gt; 12 //vue 인스턴스 생성 13 new Vue({ 14 el: \u0026#39;#app\u0026#39;, 15 components: { 16 \u0026#39;app-footer\u0026#39; : { 17 template : \u0026#39;\u0026lt;footer\u0026gt;Footer!\u0026lt;/footer\u0026gt;\u0026#39; 18 } 19 } 20 }); 21\u0026lt;/script\u0026gt; Vue 설치하기 먼저 npm (node package manager) 및 node가 설치되어있어야 한다.\n특히 node 는 vue에서 10.X 버전 이상을 권장하기 때문에, 버전을 확인하고 10.X이상 버전을 준비하는 것이 필수이다.\n1 node -v #현재 node 버전 확인 (LTS 10.X 버전 이상을 설치해야 한다.) 2 npm -v #npm 버전 확인 3 npm install -g @vue/cli #vue-cli install Vue-cli 버전 별 프로젝트 생성 vue cli 버전마다 프로젝트 생성 방법이 조금 다르다.\n혹시 2.X 환경으로 vue를 생성해야 한다면, 직접 프로젝트 템플릿을 지정해주어야 한다.\n 2.X  vue-webpack-boilerplate : 대형 프로젝트 규모에 적합 (hot-reload, router, unit test, linting 포함) webpack-simple : 빠른 프로토타입 구축 목적에 적합 vue-simple-boilerplate : 하나의 html만 존재 (튜토리얼 수준에 적합)  1 # vue init \u0026#39;project-template-type\u0026#39; \u0026#39;project-directory\u0026#39; 2 vue init webpack-simple vue-project  3.X~\n3버전 들어서 프로젝트 생성이 간편하게 되었다.\ncreate로 프로젝트 경로만 잡아주고 생성하고 직접 필요한 모듈을 선택해서 설치할 수 있다.\n물론 default로 필수 모듈(babel, linting)만 설치하고 필요한 모듈은 알아서 설치해도 상관없다. 1 # vue create \u0026#39;project-directory\u0026#39; 2 vue create vue-project   프로젝트 구조 vue 프로젝트 필수 구조\n1 root 2 ├─public 3 │ └─index.html : 로컬 서버 실행시 제일 처음 참조되는 페이지 4 ├─src 5 │ └─main.js : 프로젝트 전체에 대한 정보 (vue 인스턴스 생성) 6 │ └─app.vue : 메인 컴포넌트 7 ├─package.json : 프로젝트 모듈 및 의존성 설정 정보 8  index.html\nwebpack을 통해 여러 컴포넌트 vue, 리소스들이 통합해 주입되는 페이지이다. 즉 페이지 내용이 변경될 때 마다 페이지를 reload하는 것이 아닌 변경된 요소만을 탐색해 내용을 변경한다.\nvue는 이러한 가상 DOM을 활용하기에 최적화된 framework이고 이러한 구조를 SPA (Single Page Application)라 한다. 1\u0026lt;body\u0026gt; 2 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 3\u0026lt;/body\u0026gt;  main.js\n프로젝트에 대한 전체 정보를 담고 있는 main 스크립트 파일이다.\n최상위 인스턴스로써, 여러 컴포넌트들을 공유할 수 있고 상태state들을 관리한다. 1import App from \u0026#39;./App.vue\u0026#39;; //main component 2new Vue({ 3 el: \u0026#39;#app\u0026#39;, 4 render: h =\u0026gt; h(App) 5});  package.json\n프로젝트에서 사용중인 여러 모듈을 관리하는 곳이다.\n특히, devDependencies에서 프로젝트에서 사용중인 여러 플러그인들을 확인할 수 있다. (의존성 관리) 1\u0026#34;devDependencies\u0026#34;: { 2 \u0026#34;@vue/cli-plugin-babel\u0026#34;: \u0026#34;~4.5.0\u0026#34;, 3 \u0026#34;@vue/cli-plugin-eslint\u0026#34;: \u0026#34;~4.5.0\u0026#34;, 4 \u0026#34;@vue/cli-service\u0026#34;: \u0026#34;~4.5.0\u0026#34;, 5 \u0026#34;babel-eslint\u0026#34;: \u0026#34;^10.1.0\u0026#34;, 6 \u0026#34;eslint\u0026#34;: \u0026#34;^6.7.2\u0026#34;, 7 \u0026#34;eslint-plugin-vue\u0026#34;: \u0026#34;^6.2.2\u0026#34;, 8 \u0026#34;vue-template-compiler\u0026#34;: \u0026#34;^2.6.11\u0026#34; 9}   ","date":"2021-06-30T20:20:49+09:00","image":"https://jinyisland.kr/../../assets/vue/vue.png","permalink":"https://jinyisland.kr/post/vue-start/","title":"Vue 설치하기 및 프로젝트 구조"}]
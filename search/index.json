[{"content":"컴포넌트 개념 화면의 영역을 분리하여 개발하는 것, Vue에서 최상위 컴포넌트는 root이다.\n컴포넌트 구성의 장점은 요소들을 재사용함으로써 개발 생산성이 향상되고, 컴포넌트들은 서로 관계가 형성된다.\n전역 컴포넌트 주로 플러그인, 라이브러리 등 앱 전역에서 사용 할 공통 컴포넌트를 작성한다.\n전역 컴포넌트를 생성하면 새 인스턴스를 생성할 때 마다 기본적으로 생성한다.\n//컴포넌트 생성 Vue.component(\u0026#39;app-header\u0026#39;, { template: \u0026#39;\u0026lt;h1\u0026gt;header\u0026lt;/h1\u0026gt;\u0026#39; //component Template }); Vue.component(\u0026#39;app-content\u0026#39;, { template: \u0026#39;\u0026lt;p\u0026gt;This is Vue-Component Write\u0026lt;/p\u0026gt;\u0026#39; }); //인스턴스 생성 new Vue({ el: \u0026#39;#app\u0026#39; //selector }); 지역 컴포넌트 Vue 인스턴스 내에 직접 삽입하는 방식이다. components로 정의한다.\nTree 구조로 구성할 수 있으며, 부모-자식 간 컴포넌트 사이 통신이 가능하다.\n지역 컴포넌트는 해당 인스턴스에서만 동작한다. 따라서 인스턴스를 새로 생성할 때 마다 컴포넌트를 등록해주어야 한다.\nnew Vue({ el: \u0026#39;#app\u0026#39;, //selector  components: { //지역 컴포넌트 정의  \u0026#39;app-footer\u0026#39;: { template: \u0026#39;\u0026lt;footer\u0026gt;Footer!\u0026lt;/footer\u0026gt;\u0026#39; } } }); Template 템플릿 내에 생성한 컴포넌트를 태그로 지정한다.\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!--컴포넌트에 등록한 템플릿 지정--\u0026gt; \u0026lt;app-header\u0026gt;\u0026lt;/app-header\u0026gt; \u0026lt;app-content\u0026gt;\u0026lt;/app-content\u0026gt; \u0026lt;/div\u0026gt; 컴포넌트 통신 방식 Vue 컴포넌트는 각 고유한 데이터 유효범위를 갖는다.\n부모 컴포넌트의 데이터가 바뀌면 하위 컴포넌트의 데이터가 바뀌지만, 반대로 하위 컴포넌트의 데이터가 바뀌면 부모 컴포넌트가 바뀌지 않는다. (단방향 흐름)\nprops 상위 컴포넌트에서 하위 컴포넌트로 데이터 전달 시 사용한다.\nvue에서는 v-bind디렉티브로 속성에 접근할 수 있는데, 하위 컴포넌트에서 상위 컴포넌트의 데이터 속성에 접근이 가능하다.\n자세하게 말하면, v-bind로 해당 컴포넌트에서 정의된 props 속성에 접근할 수 있고 props의 역할은 부모의 data영역에 접근할 수 있게 해주는 속성이라고 볼 수 있다.\n\u0026lt;!--template--\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;app-header v-bind:propsdata=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/app-header\u0026gt; \u0026lt;/div\u0026gt; //하위 컴포넌트 var appHeader = { template: \u0026#39;\u0026lt;h1\u0026gt;header\u0026lt;/h1\u0026gt;\u0026#39;, props: [\u0026#39;propsdata\u0026#39;] } // Vue 인스턴스 (root 컴포넌트) new Vue({ el: \u0026#39;#app\u0026#39;, components: { \u0026#39;app-header\u0026#39;: appHeader }, data: { message: \u0026#39;hello Vue~~!!\u0026#39; } }); emit props와는 반대로 하위 컴포넌트에서 상위 컴포넌트로 이벤트를 전달할 수 있다.\n이벤트를 전달함으로써, 콜백내 this를 통해 상위 데이터에 접근하는 방법이다.\n컴포넌트 methods 속성 내에 여러 이벤트들을 정의할 수 있는데, 정의한 custom event를 트리거하려면 $emit메서드에 이벤트 이름을 전달하면 된다.\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;app-content v-on:add=\u0026#34;addNumber\u0026#34;\u0026gt;\u0026lt;/app-content\u0026gt; \u0026lt;p\u0026gt;number : {{number}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; //하위 컴포넌트  const appContent = { template: \u0026#39;\u0026lt;button v-on:add=\u0026#34;addNumber\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt;\u0026#39;, methods: { addNumber: function (params) { this.$emit(\u0026#39;add\u0026#39;); //상위 컴포넌트에 binding 할 이벤트  } } } //Vue 인스턴스 (root)  const vueObject = new Vue({ el: \u0026#39;#app\u0026#39;, components: { //local component  \u0026#39;app-content\u0026#39;: appContent }, methods: { addNumber: function () { //this 키워드로 정의한 data에 접근 가능  console.log(this.number++); } }, data: { number: 1 } }); 동등 컴포넌트 간 통신   내가 생각하는 컴포넌트 통신 실제로 기존 DOM 조작 방식(JQuery)에 익숙한 나는 위의 사진처럼 종속관계가 아니어도 값을 주고받을 수 있을줄 알았으나, 아래와 같이 해야한다고 한다.\n  실제 컴포넌트 통신 방법 위에 설명했던 컴포넌트의 특성을 살려 동등 레벨의 컴포넌트(부모가 동일한)가 데이터를 전달하려면, emit(상위 컴포넌트로 전달) -\u0026gt; props(하위 컴포넌트로 전달) 과정을 거쳐야 한다.\n  만일 같은 레벨의 header와 footer 사이 데이터 전달이 필요하다면 먼저 body에 데이터를 전달해야한다. ($emit)\n\u0026lt;div id=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;app-header\u0026gt;\u0026lt;/app-header\u0026gt; \u0026lt;app-footer v-on:message=\u0026#34;bindData\u0026#34;\u0026gt;\u0026lt;/app-footer\u0026gt; \u0026lt;/div\u0026gt; //footer 컴포넌트 const footer = { template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;h3\u0026gt;FOOTER\u0026lt;/h3\u0026gt;\u0026lt;button v-on:click=\u0026#34;passData\u0026#34;\u0026gt;trans-data\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;, methods: { passData: function () { this.$emit(\u0026#39;message\u0026#39;, \u0026#39;footer-data\u0026#39;); //해당 이벤트에 파라미터 전달  } }, } new Vue({ el: \u0026#39;#body\u0026#39;, components: { \u0026#39;app-header\u0026#39;: header, \u0026#39;app-footer\u0026#39;: footer }, data: { message: \u0026#39;test\u0026#39; }, methods: { bindData: function (param) { this.message = param; } }, }); 이제 부모의 message는 하위 컴포넌트에서 전달한 데이터로 변경이 되어있다.\nprops속성을 통해 접근하면된다.\n\u0026lt;app-header v-bind:headerdata=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/app-header\u0026gt; //header 컴포넌트 const header = { template : \u0026#39;\u0026lt;h2\u0026gt;Header\u0026lt;/h2\u0026gt;\u0026#39;, props : [\u0026#39;headerdata\u0026#39;] } 참고자료  Vue 공식문서 - vm-emit 캡틴판교님의 Vue 기초 강의  ","date":"2021-07-01T21:27:40+09:00","permalink":"https://jinyisland.kr/p/vue-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%9C%EB%85%90/","title":"Vue 컴포넌트에 대한 개념"},{"content":"CLI? cli란 Command Line Interface, 즉 명령어 기반의 인터페이스 환경을 의미한다.\nvue 프로젝트 도입시 전체적인 웹애플레이케이션을 관리하려면 지금 소개하는 cli패키지를 설치하면 되고,\n별도의 페이지에서 국한적으로 사용하려면 cdn방식으로도 사용할 수 있다.\nCDN 방식을 사용하려면 아래 소스를 참고하면 된다.\n\u0026lt;head\u0026gt; \u0026lt;!-- Vue-CDN --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- template --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;app-footer\u0026gt;\u0026lt;/app-footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //vue 인스턴스 생성  new Vue({ el: \u0026#39;#app\u0026#39;, components: { \u0026#39;app-footer\u0026#39; : { template : \u0026#39;\u0026lt;footer\u0026gt;Footer!\u0026lt;/footer\u0026gt;\u0026#39; } } }); \u0026lt;/script\u0026gt; Vue 설치하기 먼저 npm (node package manager) 및 node가 설치되어있어야 한다.\n특히 node 는 vue에서 10.X 버전 이상을 권장하기 때문에, 버전을 확인하고 10.X이상 버전을 준비하는 것이 필수이다.\nnode -v #현재 node 버전 확인 (LTS 10.X 버전 이상을 설치해야 한다.) npm -v #npm 버전 확인 npm install -g @vue/cli #vue-cli install Vue-cli 버전 별 프로젝트 생성 vue cli 버전마다 프로젝트 생성 방법이 조금 다르다.\n혹시 2.X 환경으로 vue를 생성해야 한다면, 직접 프로젝트 템플릿을 지정해주어야 한다.\n 2.X  vue-webpack-boilerplate : 대형 프로젝트 규모에 적합 (hot-reload, router, unit test, linting 포함) webpack-simple : 빠른 프로토타입 구축 목적에 적합 vue-simple-boilerplate : 하나의 html만 존재 (튜토리얼 수준에 적합)  # vue init \u0026#39;project-template-type\u0026#39; \u0026#39;project-directory\u0026#39; vue init webpack-simple vue-project  3.X~\n3버전 들어서 프로젝트 생성이 간편하게 되었다.\ncreate로 프로젝트 경로만 잡아주고 생성하고 직접 필요한 모듈을 선택해서 설치할 수 있다.\n물론 default로 필수 모듈(babel, linting)만 설치하고 필요한 모듈은 알아서 설치해도 상관없다. # vue create \u0026#39;project-directory\u0026#39; vue create vue-project   프로젝트 구조 vue 프로젝트 필수 구조\nroot ├─public │ └─index.html : 로컬 서버 실행시 제일 처음 참조되는 페이지 ├─src │ └─main.js : 프로젝트 전체에 대한 정보 (vue 인스턴스 생성) │ └─app.vue : 메인 컴포넌트 ├─package.json : 프로젝트 모듈 및 의존성 설정 정보  index.html\nwebpack을 통해 여러 컴포넌트 vue, 리소스들이 통합해 주입되는 페이지이다. 즉 페이지 내용이 변경될 때 마다 페이지를 reload하는 것이 아닌 변경된 요소만을 탐색해 내용을 변경한다.\nvue는 이러한 가상 DOM을 활용하기에 최적화된 framework이고 이러한 구조를 SPA (Single Page Application)라 한다. \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;  main.js\n프로젝트에 대한 전체 정보를 담고 있는 main 스크립트 파일이다.\n최상위 인스턴스로써, 여러 컴포넌트들을 공유할 수 있고 상태state들을 관리한다. import App from \u0026#39;./App.vue\u0026#39;; //main component new Vue({ el: \u0026#39;#app\u0026#39;, render: h =\u0026gt; h(App) });  package.json\n프로젝트에서 사용중인 여러 모듈을 관리하는 곳이다.\n특히, devDependencies에서 프로젝트에서 사용중인 여러 플러그인들을 확인할 수 있다. (의존성 관리) \u0026#34;devDependencies\u0026#34;: { \u0026#34;@vue/cli-plugin-babel\u0026#34;: \u0026#34;~4.5.0\u0026#34;, \u0026#34;@vue/cli-plugin-eslint\u0026#34;: \u0026#34;~4.5.0\u0026#34;, \u0026#34;@vue/cli-service\u0026#34;: \u0026#34;~4.5.0\u0026#34;, \u0026#34;babel-eslint\u0026#34;: \u0026#34;^10.1.0\u0026#34;, \u0026#34;eslint\u0026#34;: \u0026#34;^6.7.2\u0026#34;, \u0026#34;eslint-plugin-vue\u0026#34;: \u0026#34;^6.2.2\u0026#34;, \u0026#34;vue-template-compiler\u0026#34;: \u0026#34;^2.6.11\u0026#34; }   ","date":"2021-06-30T20:20:49+09:00","permalink":"https://jinyisland.kr/p/vue-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0-%EB%B0%8F-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0/","title":"Vue 설치하기 및 프로젝트 구조"}]
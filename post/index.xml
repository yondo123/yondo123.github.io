<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jiny</title>
    <link>https://jinyisland.kr/post/</link>
    <description>Recent content in Posts on Jiny</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Apr 2022 21:17:46 +0900</lastBuildDate><atom:link href="https://jinyisland.kr/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Express 미들웨어 사용법</title>
      <link>https://jinyisland.kr/post/middleware/</link>
      <pubDate>Tue, 12 Apr 2022 21:17:46 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/middleware/</guid>
      <description>미들웨어 말 그대로 요청(Request)과 응답(Response) 사이 중간(middle)에서 핸들링해주는 익스프레스의 핵심 기능이다.
사용법 use메서드를 사용하고 요청 메서드 내부에서 미들웨어를 정의할 수 있다.
1//모든 요청에서 미들웨어 실행 2app.use((req, res, next)=&amp;gt; { 3	console.log(&amp;#39;middle ware execute&amp;#39;); 4	next(); 5}, (req, res) =&amp;gt; { 6	// code.. 7});; 8 9//특정 요청 또는 경로에서 미들웨어 실행 (next 인자는 생략 가능) 10app.get((&amp;#39;/&amp;#39;, (req, res, next)=&amp;gt;{ 11	console.log(&amp;#34;request get, &amp;#39;/&amp;#39;&amp;#34;); 12	next(); 13}, (req, res)=&amp;gt;{ 14	throw new Error(&amp;#39;error!</description>
    </item>
    
    <item>
      <title>자바스크립트 함수형 반복문</title>
      <link>https://jinyisland.kr/post/js-loop/</link>
      <pubDate>Wed, 06 Apr 2022 21:43:40 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-loop/</guid>
      <description>요즘 인프런을 통해 알고리즘 강의를 수강 중인데 개인적으로 많은 도움을 받고 있다. 단순히 알고리즘 문제를 친숙하게 다가가기 위해 강의를 끊은것인데.. 의외로 실무에서도 크게 도움이 될 것 같아 이번 기회에 포스팅을 했다.
함수형 반복문 사실 지금까지 반복문을 사용하는 방법은 크게 신경쓰지 않았다. 보통 레거시 코드에서는 for문을 많이 사용하는데(다른 언어에서도 많이 사용하고, 너무 친숙해졌다..) 이는 절대 낡거나 안좋은 코드라는 것은 절대 아니다!! 상황에 따라서 함수형으로 제공되는 반복문을 사용하는 경우가 효율적인 것도 있고 for를 사용하는 것이 더 효율적인 상황도 분명히 있다.</description>
    </item>
    
    <item>
      <title>Express 설치 및 실행해보기</title>
      <link>https://jinyisland.kr/post/express-start/</link>
      <pubDate>Tue, 29 Mar 2022 22:57:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/express-start/</guid>
      <description>개요 기존 http모듈로 서버를 구축 해서 간단한 요청과 응답 프로세스를 경험해보았는데 여타 언어들도 그렇듯이 프레임워크를 사용하면 더욱 효율적으로 작업을 할 수 있다. node.js 생태계에서는 압도적으로 express.js를 많이 사용한다.
설치하기 npm 환경에서 install 명령어를 통해 express를 설치한다.
1npm install express 기본 구조 기본적인 서버를 구축한 소스이다.
http 모듈로 구축했을 때 URL도 파싱해야하고, if문으로 분기처리하기 수고스러웠는데 상당히 깔끔해졌다.
각 라우터마다 요청, 응답 객체를 받아와 여러 형태로 받거나 전달할 수 있다.
1//app.js 2const express = require(&amp;#34;express&amp;#34;); 3const app = express(); 4 5//get 메서드 6app.</description>
    </item>
    
    <item>
      <title>Node.js 파일 시스템 접근하기</title>
      <link>https://jinyisland.kr/post/node-file/</link>
      <pubDate>Mon, 28 Feb 2022 22:05:52 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/node-file/</guid>
      <description>FileSystem node.js에서는 fs 모듈을 통해 파일 시스템에 접근할 수 있다. 현재 파일 기준으로 경로를 잡는것이 아닌 실행하는 node 콘솔 기준으로 경로를 바라본다는 특징이 있다. 파일 시스템에 접근할 때는 반드시 보안에 꼭 신경쓰는 것이 좋다. 또한 비동기 함수이므로 동시에 실행이 보장되지 않는다.
1## hello Node.js! readFile 파일을 읽어오는 메서드이다. 첫 번째 인자에 해당 파일의 상대경로, 두 번째 인자에 콜백 함수를 입력 받는다.
(실행하는 node 기준이므로 같은 디렉토리에 위치해야한다.)
1const fs = require(&amp;#39;fs&amp;#39;); 2 3fs.</description>
    </item>
    
    <item>
      <title>HTML에 폰트 적용하는 방법</title>
      <link>https://jinyisland.kr/post/font/</link>
      <pubDate>Mon, 17 Jan 2022 23:18:33 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/font/</guid>
      <description>웹 폰트 웹 폰트를 적용하는 방법은 크게 2가지가 있다. 하나는 cdn을 이용하는 방법, 나머지 하나는 직접 폰트 파일을 경로에 미리 삽입하여 @font-face로 정의하는 방법이다.
CDN을 활용한 방법 구글 폰트 등과 같이 cdn을 제공해주는 사이트에서 폰트를 적용하는 방법이다. 너무나 간단한게 장점이고 단점으로는 직접 파일을 적용하는 방법보다 로드 속도가 느리다. 적용 방법은 직접 cdn 링크를 html에 삽입하고, css에서 font-family로 적용하거나, css import를 통해 적용하는 방법이 있다.
1/* cdn import */ 2@import url(&amp;#39;https://fonts.googleapis.com/css2?family=Dongle:wght@300&amp;amp;display=swap&amp;#39;); 3 4/* 폰트 적용 */ 5body { 6 font-family: &amp;#39;Dongle&amp;#39;, sans-serif; 7} 폰트파일 직접 적용 직접 폰트 파일을 서비스 디렉토리에 넣어주고 @font-face로 불러오는 방법이 있다.</description>
    </item>
    
    <item>
      <title>Node.js 자주 사용하는 모듈 정리</title>
      <link>https://jinyisland.kr/post/useful-modules/</link>
      <pubDate>Mon, 10 Jan 2022 23:19:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/useful-modules/</guid>
      <description>global 브라우저의 window와 같은 전역 객체 역할, 하지만 브라우저와 관련된 객체(document 등)들은 사용하지 못한다. global객체 역시 생략해서 사용 가능하다. 그리고 브라우저의 window객체와 마찬가지로 global에 값을 주입하면 프로젝트 내 모든 파일에서 전역 변수로 사용할 수 있다 . (하지만 이러한 패턴은 지양한다, module을 통해 관리하자)
1global.console.log(&amp;#34;hello Node!&amp;#34;); 2console.log(&amp;#34;hello Node!&amp;#34;); console 로그를 출력하는 객체, 흔히 사용하는 log, error 말고 신기한 것을 소개한다.
console.time 수행 시점에 time을 찍어 해당 코드를 수행한 시간을 알아낼 수 있다.</description>
    </item>
    
    <item>
      <title>npm에 대한 개념과 사용 방법</title>
      <link>https://jinyisland.kr/post/npm/</link>
      <pubDate>Mon, 10 Jan 2022 22:40:47 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/npm/</guid>
      <description>npm NodeNode Package Manager, 말 그대로 Node.js 환경에서 여러 모듈들을 패키지화하여 관리하는 저장소 같은 역할이다.
패키지를 직접 만들어 배포할 수 있고 다른 사람이 배포한 여러 패키지 모듈들을 설치해 프로젝트에 적용시킬 수도 있다.
npm 생성하기 npm 환경에서 제일 중요한 것은 패키지 관리이다. 패키지들은 package.json파일에서 일괄적으로 관리하는데 직접 json 파일로 생성해도 되고, 명령어를 입력해 생성해도 된다. 터미널에서 npm init명령어를 입력하면 자동적으로 package.json파일을 생성할 수 있다.
1npm init 2# &amp;gt; packagename : 프로젝트 이름 입력 3# &amp;gt; version : 프로젝트 버전 입력 (default : 1.</description>
    </item>
    
    <item>
      <title>Vue 코드 포맷팅</title>
      <link>https://jinyisland.kr/post/prettier/</link>
      <pubDate>Mon, 20 Dec 2021 23:49:00 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/prettier/</guid>
      <description>Code Convention 프로젝트 진행 시 기능 구현도 중요하지만, 추후 유지보수를 위한 convention도 굉장히 중요하다고 생각한다. 특히 협업으로 작업하는 경우 거의 필수로 작용하는데, 개발자 마다 선호하는 코딩 스타일도 다르고 하물며 변수 명 하나하나 지을 때도 케밥케이스, 카멜케이스 등 여러 방식도 존재하기 때문이다. 물론 개인 프로젝트에서도 이 부분은 꽤나 중요한데 전체적인 일관성이 유지되어야 보는 사람들도 코드를 읽기 편하다. 컨벤션을 잘 지킬 수 있는 플러그인 중 대다수가 사용하는 eslint와 prettier를 vue와 연동해보는 것을 정리해보았다.</description>
    </item>
    
    <item>
      <title>Vuex 개념과 실제 사용해보기!</title>
      <link>https://jinyisland.kr/post/vuex/</link>
      <pubDate>Fri, 03 Dec 2021 16:10:08 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vuex/</guid>
      <description>Vuex vuex는 vue.js에서 컴포넌트들의 상태 관리를 위한 효율적인 라이브러리이다.
React의 Flux 이름과 비슷한것을 보면 Flux 패턴에서 차용한 것이라고 한다.
Vuex를 사용하면 좋은 점 기본적으로 vue 생태계에서 컴포넌트 간 여러 정보들을 관리하려면 부모-자식 관계로 데이터들을 넘겨주고 받아야한다. 하지만 현실적으로 복잡한 컴포넌트 관계속에서 계속 주고 받으려면 여러 컴포넌트 파일에서 data 속성을 관리해주어야 하는 단점이 있다. 예를 들어 위 사진처럼 깊은 관계에서 다른 컴포넌트로 데이터를 보내려면 부모 컴포넌트를 계속 찾아 이벤트를 바인딩 시키고 다시 props로 내려주어야 하는 불편함이 있다.</description>
    </item>
    
    <item>
      <title>Vue에 Tailwind CSS 적용하기</title>
      <link>https://jinyisland.kr/post/vue-tailwind/</link>
      <pubDate>Thu, 21 Oct 2021 23:05:04 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-tailwind/</guid>
      <description>tailwind? tailwind는 CSS 프레임워크이다. 사용방법은 공식 문서를 보면 잘 나와있다. 기본적으로 태그 내에 inline형태로 클래스 형태로 스타일을 입히는 방식이다. 기존 css로 작업했을 때와 tailwind를 사용했을 때를 비교해 보자면 다음과 같다.
  브라우징 최적화
autoprefixer를 내장해서 사용하고 있기 때문에, 브라우저별로 상이한 스타일 문제로 골머리를 앓지 않아도 된다.
  클래스 기반 스타일 tailwind 기본 사용법은 태그 내에 클래스로 스타일을 입히는 방식이다. 예를 들어 특정 태그에 배경색을 입히려면 아래와 같이 작성한다. 클래스 명도 이해하기 쉽도록 구성되어 있기 때문에 대충 이름만 봐도 어떠한 역할인지는 파악이 된다.</description>
    </item>
    
    <item>
      <title>힙의 개념과 힙 정렬 알고리즘</title>
      <link>https://jinyisland.kr/post/algorithm-heap/</link>
      <pubDate>Sat, 16 Oct 2021 23:24:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/algorithm-heap/</guid>
      <description>힙 정렬 완전 이진트리에서 파생된 heap 특성을 사용하여 정렬하는 알고리즘, 힙은 부모의 값이 자식의 값보다 항상 크거나 항상 작다라는 조건을 만족하는 완전이진트리 형태의 자료구조이다.
완전이진트리는 자식 노드를 왼쪽부터 채워나가는 형태의 자료구조이다. 힙의 개념 완전이진트리와의 차이점은 큰 값이 상위, 작은 값이 하위에 위치한 트리형 자료구조로써 부모-자식 관계가 일정해야한다. 작은 값이 부모가 되는 힙 형태를 min-heap(최소 힙), 큰 값이 부모가 되는 트리 구조를 max-heap(최대 힙)이라고 한다. 힙은 다음과 같은 관계를 가지고 있어야한다.</description>
    </item>
    
    <item>
      <title>computed와 Watch</title>
      <link>https://jinyisland.kr/post/computed-watch/</link>
      <pubDate>Sat, 09 Oct 2021 23:17:34 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/computed-watch/</guid>
      <description>vue에서 data 속성에 있는 값을 사용하고자 할 때, 값이 변화할 때 마다 자동적으로 리렌더링 해주는 인스턴스 속성이 2개가 있다. 바로 computed와 watch, 이 두 속성의 공통점은 값을 감지하다가 변경되면 메서드를 호출함으로써 값을 바로 반환해준다. 이 비슷한 두 속성에 대해 차이점에 대해서 알아보았다.
computed 사용법은 아래 코드를 참고, computed속성 내에 메서드를 정의하고 템플릿내에 호출을 하면 해당 값이 바뀔 때 마다 재호출을 해준다. 이는 캐싱이되는 성질이 있어 해당 값이 바뀌지 않는다면 호출을 절대 하지 않는다.</description>
    </item>
    
    <item>
      <title>Http 쿠키의 개념과 활용 방법</title>
      <link>https://jinyisland.kr/post/cookies/</link>
      <pubDate>Mon, 20 Sep 2021 18:49:47 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/cookies/</guid>
      <description>Http http 트랜잭션에는 상태가 없다. 모든 사용자 요청에는 사이트 기능에 맞는 상태들을 유지하는데 (사용자 정보, 권한 등등..) 이런 무수히 많은 상태들을 관리하려면 사용자를 식별할 수 있는 방법이 필요하다. 그중에 하나가 쿠키이다. 물론 사용자를 가릴 수 있는 방법에 초창기 여러 가지 방법이 있었는데 사용자 IP를 활용한 방법 등이 있었다. IP를 활용한 방법에는 다음과 같은 문제점이 있다.
 사용자 기준이 아닌 접속 PC의 IP이기 때문에 정확한 사용자 구별이 어려움 ISP가 제공하는 IP 대역을 사용하는 경우, 대부분 매번 다른 주소를 받으므로 추후 식별이 어려움 NAT 장비 등, 보안을 위해 IP 주소를 private 하게 관리 → 서버에서 받는 사용자 IP가 실제 IP가 아닐 수 있음  위와 같은 문제점으로, IP를 활용한 방식보다 아예 사용자 마다의 인증 프로세스를 부여하여 명확한 식별 요청을 할 수 있는데 이 기능이 바로 우리가 흔히 접하는 로그인 기능</description>
    </item>
    
    <item>
      <title>Node.js HTTP모듈 실습</title>
      <link>https://jinyisland.kr/post/node-restapi/</link>
      <pubDate>Fri, 17 Sep 2021 23:48:56 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/node-restapi/</guid>
      <description>Node.js HTTP 모듈을 통해 간단히 요청보내고, 주고받는 초간단 API 서버를 만들어보았다.
Request createServer 콜백에서 request, response 인자를 받는데 request 객체에서 요청 정보들을 받을 수 있다.
1const http = require(&amp;#34;http&amp;#34;); 2 3http.createServer(async (request, response)=&amp;gt;{ 4	try{ 5	const method = request.method; 6	const url = request.url; 7	//step 1. 요청 메소드 구분 8	if(method == &amp;#34;GET&amp;#34;){ 9	//step 2. URL 구분 10	if(url == &amp;#34;/&amp;#34;){ 11	}else if(url == &amp;#34;/list&amp;#34;){ 12	} 13	}else if(method == &amp;#34;POST&amp;#34;){ 14	//code.</description>
    </item>
    
    <item>
      <title>탐색 알고리즘 (선형, 이진)</title>
      <link>https://jinyisland.kr/post/algorithm-search/</link>
      <pubDate>Tue, 14 Sep 2021 23:25:12 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/algorithm-search/</guid>
      <description>선형검색 배열에서 원하는 키 값 요소를 만날 때까지 순서대로 요소 검색, 값을 찾지 못하고 배열을 모두 순회하거나 값을 찾는다면 바로 종료한다.
1function linearSearch(key, arr) { 2 for (let index = 0; index &amp;lt; arr.length; index++) { 3 if (key === arr[index]) { 4 return true 5 } 6 } 7 return false; 8} 9 10linearSearch(2811, [2, 15, 24, 28, 304, 16, 7, 1]); //false 11linearSearch(16, [2, 15, 24, 28, 304, 16, 7, 1]); //true 이진검색 이미 정렬되어 있는 배열(전제 조건)에서 범위를 좁혀가며 값을 찾는 탐색법 선형 탐색보다 속도가 빠르긴하지만 정렬되어 있는 리스트에 적용할 수 있다.</description>
    </item>
    
    <item>
      <title>자바스크립트 모듈화</title>
      <link>https://jinyisland.kr/post/js-module/</link>
      <pubDate>Sat, 11 Sep 2021 23:36:33 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-module/</guid>
      <description>Module module객체를 통해 각각의 기능이나 js파일들을 쉽게 모듈화가 가능하다.
export 코드를 외부에 내보내고 싶다면 export문을 사용한다. 함수, 변수, 클래스 등을 내보낼 수 있다.
1//📁module/util.js 2const constants = { 3	message : &amp;#39;simple message&amp;#39;; 4} 5 6const requestUrl = &amp;#39;/xyz-url&amp;#39;; 7 8const private = { 9	privateKey : &amp;#39;1234&amp;#39; 10} 11 12export {constants, requestUrl}; //배열로도 export가 가능하다. (1~2개 모듈은 보통 객체형식으로 많이 사용) 각각의 모듈 대상에 export 예약어를 붙여 내보낼 수도 있다.</description>
    </item>
    
    <item>
      <title>Promise와 Async/await</title>
      <link>https://jinyisland.kr/post/promise-async-await/</link>
      <pubDate>Wed, 08 Sep 2021 23:18:33 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/promise-async-await/</guid>
      <description>Promise 1function callbackDelay(sec, callback) { 2 setTimeout(()=&amp;gt;{ 3 callback(&amp;#34;콜백 Delay&amp;gt;&amp;gt;&amp;#34;+new Date().toString()); 4 }, sec * 1000) 5} 6 7callbackDelay(1, (result)=&amp;gt;{ 8 console.log(1, result); 9 callbackDelay(1, (result)=&amp;gt;{ 10 console.log(2, result); 11 callbackDelay(1, (result)=&amp;gt;{ 12 console.log(3, result) 13 }) 14 }) 15}) 16/*result 171 콜백 Delay&amp;gt;&amp;gt;Sun Jun 07 2020 18:43:56 GMT+0900 (GMT+09:00) 18promise.js:26 192 콜백 Delay&amp;gt;&amp;gt;Sun Jun 07 2020 18:43:57 GMT+0900 (GMT+09:00) 20promise.js:28 213 콜백 Delay&amp;gt;&amp;gt;Sun Jun 07 2020 18:43:58 GMT+0900 (GMT+09:00) 22*/ 자바스크립트에서 비동기 동작을 할때 우리는 항상 해당 함수에 콜백 함수를 넣어줬다.</description>
    </item>
    
    <item>
      <title>비동기와 이벤트 루프</title>
      <link>https://jinyisland.kr/post/eventloop/</link>
      <pubDate>Tue, 07 Sep 2021 21:59:08 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/eventloop/</guid>
      <description>비동기 처리 1//대충 이런 구조의 코드.. 2function checkValue(){ 3	//로직검사.. 4} 5 6setTimeout(function(){ 7	checkValue(); 8}, 500); 9 10function getData(){ 11	//AJAX로 소스를 받아오는 코드.. 12}; 13 14getData(); 자바스크립트를 처음 접했을 때, setTimeout이 왜 순서대로 시행 안되지??.. (why 나중에 시행되는거야..🤔)해서비동기에 대한 개념을 숙지했다. 대충 콜백함수로 넘겨서 호출해 해결하고 비동기 프로세스에 대한 개념 자체를 더 배우려하지 않았다. 이번에 Node.js 스터디를 하면서 비동기 프로세스를 꼭 알아야 성능 향상에 도움이 된다는 사실을 알게되었고 책과 강의를 통해 내가 이해한 비동기 처리과정을 최대한 간략하게 정리해보았다.</description>
    </item>
    
    <item>
      <title>자바스크립트 화살표 함수</title>
      <link>https://jinyisland.kr/post/arrow-function/</link>
      <pubDate>Sun, 05 Sep 2021 19:45:01 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/arrow-function/</guid>
      <description>화살표 함수 기존 함수 표기법을 화살표(⇒)형태로 간단하게 표기하는 함수 표기법
기존 함수 표현식과의 차이 1//기존 함수 표현식 2function name(){ 3 //code.. 4} 5 6//화살표 함수 7() =&amp;gt; { 8	//code.. 9} 화살표 함수 특징 괄호 생략 매개변수가 1개라면 괄호()도 생략이 가능하다.
1const logMessage = message =&amp;gt; { console.log(message) } 2logMessage(&amp;#39;hello&amp;#39;); //&amp;#39;hello&amp;#39; Lexical this 일반 함수 표기에서는 this사용 시 동적으로 해당 함수를 실행한 객체로 바인딩되었다.
하지만 화살표 함수에서는 자신을 소유하고 있는 객체로 바인딩되는게 아니라 해당 화살표함수를 소유하고 있는 상위 환경의 this를 그대로 계승한다.</description>
    </item>
    
    <item>
      <title>자바스크립트 템플릿리터럴</title>
      <link>https://jinyisland.kr/post/template-literals/</link>
      <pubDate>Sun, 05 Sep 2021 19:36:27 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/template-literals/</guid>
      <description>Temlate literals 기존 문자열 결합 시 연산자(+)를 사용하였는데 백틱(`) 기호를 사용하여 쉽게 결합할 수 있다.
기존 연산자 사용 1const fruit = &amp;#39;apple&amp;#39;; 2const color = &amp;#39;red&amp;#39;; 3console.log(&amp;#39;My Favorite Fruit is&amp;#39; + fruit + &amp;#39;, color is &amp;#39; + color ); //&amp;#34;My Favorite Fruit isapple, color is red&amp;#34; 템플릿리터럴 사용 1const fruit = &amp;#39;apple&amp;#39;; 2const color = &amp;#39;red&amp;#39;; 3console.log(`My favorite Fruit is ${fruit}, color is ${color}`); 장점 보통 복잡한 문자열이거나 html 코드등을 직접 스크립트상에서 삽입할 때 쌍따옴표-홀따옴표등과 같이 사용하는 경우에 상당히 복잡했었다.</description>
    </item>
    
    <item>
      <title>JAVA 자료구조 배열</title>
      <link>https://jinyisland.kr/post/java-array/</link>
      <pubDate>Sat, 04 Sep 2021 22:57:27 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/java-array/</guid>
      <description>배열 데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계를 뜻한다. JAVA 배열의 특징은 다음과 같다.
 같은 타입이어야 한다. 한번 생성된 배열을 길이를 변경할 수 없다.  자료형 배열 구성 요소의 자료형은 어떤 형이든 상관 없음
1int[] a; //주로 이렇게 선언 2int a[]; 배열의 초기화 배열 원소의 기본 값(초기화)은 자료형에 따라 아래와 같이 생성된다. 아래 초깃값 생성 규칙은 배열뿐만아니라 클래스의 필드도 마찬가지이다!
(메서드 내에서 생성한 지역 변수는 자동 초기화가 되지 않고 컴파일 오류를 출력한다.</description>
    </item>
    
    <item>
      <title>let, const와 기존 var의 차이</title>
      <link>https://jinyisland.kr/post/let-const/</link>
      <pubDate>Mon, 30 Aug 2021 23:39:26 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/let-const/</guid>
      <description>요즘 공부하고 있는 vue.js 프레임워크를 사용하다보면 자연스럽게 es6 이상의 트렌디한 자바스크립트 문법이 눈에 띈다. 🧐
물론 vue 코드를 빠르게 짤 수 있는 스니펫 플러그인에서도 기본적으로 es6+ 문법으로 안내해주기도하고.. vue를 사용해서가 아니라 이렇게 트렌디한~자바스크립트에서는 어떤 문법이 있는지 차례차례 짚고 넘어가고자 한다. (물론 내 기준 현업 또는 개인적으로 많이 쓰는 문법 위주로~ㅎㅎ)
블록범위 먼저 let과 const를 제대로 이해하려면 블록범위를 제대로 알고넘어가야한다!
블록범위 내에서 let과 const를 사용하면 해당 변수를 재할당할 수 없도록 지정할 수 있다.</description>
    </item>
    
    <item>
      <title>Vue 라우터 개념 및 사용방법</title>
      <link>https://jinyisland.kr/post/vue-router/</link>
      <pubDate>Mon, 23 Aug 2021 22:54:41 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-router/</guid>
      <description>라우터 클라이언트의 요청 경로에 따라 해당하는 컴포넌트를 불러와 페이지를 구성할 수 있다.
URL 변경 시 DOM을 새로 갱신하는 것이 아니라 미리 컴포넌트를 가지고 있다가 변경된 요소영역만 갱신한다.(SPA 언어의 큰 특징)
따라서 유연하게 페이지 젼환이 가능하다. vue 프레임워크에서는 vue-router라는 라우팅 라이브러리를 지원한다.
설치하기 vue-router를 설치하고, package.json파일에서 모듈이 잘 추가되었는지 확인하자
1npm install vue-router --save 라우터 속성 다음은 라우터 인스턴스를 생성할 때 설정하는 값이다.
 String mode : 기본 값은 Hash 모드 (history 모드를 사용하면 브라우저 히스토리 스택에 기록된다.</description>
    </item>
    
    <item>
      <title>자바스크립트 클로저</title>
      <link>https://jinyisland.kr/post/js-closure/</link>
      <pubDate>Tue, 10 Aug 2021 23:51:20 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-closure/</guid>
      <description>클로저 개념 클로저는 쉽게말해 함수 선언시 생성되는 유효 범위이다.
먼저 자바스크립트에서 클로저를 이해하려면 범위 지정(Lexical Scoping)을 이해하여야 한다.
아래 코드를 보자.
1var apple = &amp;#39;🍎&amp;#39;; 2 3function displayApple(){ 4	console.log(apple); 5} 6 7displayApple(); 8//result : 🍎 간단하게 사과를 출력해주는 함수다.
하지만, 정작 함수안에는 apple이라는 변수가 없는데도 불구하고 사과가 출력되었다.
지난번 실행컨텍스트에서 언급했듯이 해당 유효범위에서 식별자를 찾지 못하면 점점 상위 ~ 전역으로 탐색한다. Scope Chain
1var displayPrice; 2var apple = **&amp;#39;🍎&amp;#39;;** 3function displayApple(){ 4	var price = 1000; 5	console.</description>
    </item>
    
    <item>
      <title>자바스크립트 함수, 이것만은 꼭 기억하자</title>
      <link>https://jinyisland.kr/post/js-function/</link>
      <pubDate>Wed, 04 Aug 2021 23:34:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-function/</guid>
      <description>함수 자바스크립트의 함수는 객체로 취급 받는다. (일급객체)
따라서 객체처럼 리터럴 방식으로 선언할 수 있고, new 연산자로 선언할 수도 있다. (대부분.. 리터럴 방식을 선호한다.)
1//new 연산자 선언 2var sum = new Function(&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;return a+b&amp;#39;); 3sum(1,3) //4 익명함수와 선언함수 익명 함수는 말 그대로 &amp;lsquo;이름을 갖지 않는&amp;rsquo; 함수이다.
보통 변수에 저장해서 선언 후 호출한다.
1add(2,3) //result : type error 2 3var add = function(x,y){ //익명함수 4	return x+y; 5} 6 7add(3,7); //result : 10 선언 함수는 함수 선언 시 이름을 지명한다.</description>
    </item>
    
    <item>
      <title>자바스크립트에서의 데이터 타입</title>
      <link>https://jinyisland.kr/post/datatype/</link>
      <pubDate>Tue, 03 Aug 2021 21:38:58 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/datatype/</guid>
      <description>원시타입과 참조타입 자바스크립트에서는 원시타입과 참조타입이 존재한다. 원시타입 그 자체가 값인 데이터 타입을 말한다.
변수에 접근할 때 해당 변수에 저장된 실제 값을 조작한다.
기본 값의 유형을 확인하려면 typeof연산자를 사용해서 확인할 수 있다.
자바스크립트에서는 배열과 객체 모두 object로 취급한다는 사실을 꼭 잊지말자.
1const typeNumeric = typeof 1; //number 2const typeBoolean = typeof true; //boolean 3const typeString = typeof &amp;#39;hello&amp;#39;; //string 4const typeFunction = typeof function(){ return;} //function 5const typeUndefined = typeof undefined; //undefined 6 7const typeObject = typeof {}; //object 8const typeArray = typeof [&amp;#39;1&amp;#39;]; //object 9const typeNull = typeof null; //object 참조타입 원시 값과는 달리 해당 객체의 참조에 대해서 작업한다.</description>
    </item>
    
    <item>
      <title>GoogleAnalytics 4 휴고 블로그에 적용 시키기</title>
      <link>https://jinyisland.kr/post/hugo-ga/</link>
      <pubDate>Fri, 30 Jul 2021 22:15:51 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/hugo-ga/</guid>
      <description>Google Analytics 4 내 블로그의 정적 웹사이트 호스팅 플랫폼은 hugo를 쓰고 있다.
예전에 잠깐 썼던 Jekyll 플랫폼과 비교했을 때 배포속도도 빠르고 테마 문서도 잘 되어있어서 편하다 ㅎㅎ
원래 SEO에 대해 신경 쓰지 않고있다가, GoogleAnaytics와 GoogleSearchConsle을 적용시켜보려고 이것저것 시도해봤지만, 아직도 구글 애널리틱스 보고서에는 방문자가 0이다..
(사실 진짜 0명인줄 알았으나 내가 들어와있어도 실시간에는 0이다..)
새로운 추적 ID 구글링을 통해 알아본 휴고에 구글 애널리틱스 적용하는 글들을 보면, config.toml에 GoogleAnalytics변수에 그냥 추적 ID를 넣으면 끝이라는 내용이 많아 실제로 그렇게 해보았는데 적용이 안되고 있다.</description>
    </item>
    
    <item>
      <title>자바스크립트는 어떻게 동작할까?</title>
      <link>https://jinyisland.kr/post/how-js-work/</link>
      <pubDate>Tue, 27 Jul 2021 23:47:42 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/how-js-work/</guid>
      <description>자바스크립트의 특징 나는 주로 자바스크립트를 이용해 개발을하는 것을 좋아한다.
내 기준 가장 자신있는 언어이기도 하고, 배우면서 흥미로움을 느낀 프로그래밍 언어 중 하나였다.
하지만 자바스크립트는 쓰면 쓸수록 헷갈리는 개념도 많고, 처음엔 만만하게 보였지만 깊이 들어갈수록 난해한..언어이기도 하다.. (아직도 어렵다 ㅠㅠ)😵
자바스크립트에 대한 핵심적인 내용을 짚고 넘어가고자 해당 시리즈를 포스팅하기로 마음 먹었다! 첫 번째는 자바스크립트는 어떻게 동작할까?
유연한 언어 자바스크립트에서의 타입 체크는 타 언어보다 굉장히 유연하고 느슨하다. 아래 예시를 보면 보통의 언어 같으면 컴파일 단계에서 들어오지 않은 값에 대해 오류를 내뿜어내지만, 자바스크립트에서는 일단 처리를 한다.</description>
    </item>
    
    <item>
      <title>외부 Vue 프로젝트 불러오기</title>
      <link>https://jinyisland.kr/post/vue-import/</link>
      <pubDate>Sun, 18 Jul 2021 23:09:02 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-import/</guid>
      <description>윈도우에서 작업한 Vue 프로젝트를 mac 환경에서 확인하려던 중 git clone 후 프로젝트를 실행해보니 아래와 같은 에러가 나왔다.
1&amp;gt; vue-todo@0.1.0 serve /Users/sjchoi/Mydoc/02_Code/05_vue/vue-practice/vue-todo 2&amp;gt; vue-cli-service serve 3 4sh: vue-cli-service: command not found 5npm ERR! code ELIFECYCLE 6npm ERR! syscall spawn 7npm ERR! file sh 8npm ERR! errno ENOENT 9npm ERR! vue-todo@0.1.0 serve: `vue-cli-service serve` 10npm ERR! spawn ENOENT 11npm ERR! 12npm ERR! Failed at the vue-todo@0.1.0 serve script. 13npm ERR! This is probably not a problem with npm.</description>
    </item>
    
    <item>
      <title>Vue 컴포넌트에 대한 개념</title>
      <link>https://jinyisland.kr/post/vue-component/</link>
      <pubDate>Thu, 01 Jul 2021 21:27:40 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-component/</guid>
      <description>컴포넌트 개념 화면의 영역을 분리하여 개발하는 것, Vue에서 최상위 컴포넌트는 root이다.
컴포넌트 구성의 장점은 요소들을 재사용함으로써 개발 생산성이 향상되고, 컴포넌트들은 서로 관계가 형성된다.
전역 컴포넌트 주로 플러그인, 라이브러리 등 앱 전역에서 사용 할 공통 컴포넌트를 작성한다.
전역 컴포넌트를 생성하면 새 인스턴스를 생성할 때 마다 기본적으로 생성한다.
1//컴포넌트 생성 2Vue.component(&amp;#39;app-header&amp;#39;, { 3 template: &amp;#39;&amp;lt;h1&amp;gt;header&amp;lt;/h1&amp;gt;&amp;#39; //component Template 4}); 5 6Vue.component(&amp;#39;app-content&amp;#39;, { 7 template: &amp;#39;&amp;lt;p&amp;gt;This is Vue-Component Write&amp;lt;/p&amp;gt;&amp;#39; 8}); 9 10//인스턴스 생성 11new Vue({ 12 el: &amp;#39;#app&amp;#39; //selector 13}); 지역 컴포넌트 Vue 인스턴스 내에 직접 삽입하는 방식이다.</description>
    </item>
    
    <item>
      <title>Vue 설치하기 및 프로젝트 구조</title>
      <link>https://jinyisland.kr/post/vue-start/</link>
      <pubDate>Wed, 30 Jun 2021 20:20:49 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-start/</guid>
      <description>CLI? cli란 Command Line Interface, 즉 명령어 기반의 인터페이스 환경을 의미한다.
vue 프로젝트 도입시 전체적인 웹애플레이케이션을 관리하려면 지금 소개하는 cli패키지를 설치하면 되고,
별도의 페이지에서 국한적으로 사용하려면 cdn방식으로도 사용할 수 있다.
CDN 방식을 사용하려면 아래 소스를 참고하면 된다.
1&amp;lt;head&amp;gt; 2 &amp;lt;!-- Vue-CDN --&amp;gt; 3 &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 4&amp;lt;/head&amp;gt; 5&amp;lt;body&amp;gt; 6 &amp;lt;!-- template --&amp;gt; 7 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 8 &amp;lt;app-footer&amp;gt;&amp;lt;/app-footer&amp;gt; 9 &amp;lt;/div&amp;gt; 10&amp;lt;/body&amp;gt; 11&amp;lt;script&amp;gt; 12 //vue 인스턴스 생성 13 new Vue({ 14 el: &amp;#39;#app&amp;#39;, 15 components: { 16 &amp;#39;app-footer&amp;#39; : { 17 template : &amp;#39;&amp;lt;footer&amp;gt;Footer!</description>
    </item>
    
  </channel>
</rss>

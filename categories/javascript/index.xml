<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on Jiny</title>
    <link>https://jinyisland.kr/categories/javascript/</link>
    <description>Recent content in JavaScript on Jiny</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Apr 2023 23:52:00 +0900</lastBuildDate><atom:link href="https://jinyisland.kr/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Polyfill이 무엇인가요??</title>
      <link>https://jinyisland.kr/post/polyfill-and-babel/</link>
      <pubDate>Sun, 02 Apr 2023 23:52:00 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/polyfill-and-babel/</guid>
      <description>들어가면서 브라우저 호환성 문제를 해결하기 위한 폴리필(polyfill) 개념과 실제 사용 방법을 조사하였습니다. React와 IE11 환경에서 동작하기 위한 폴리필을 중점적으로 다룹니다.
Polyfill 개념  기본적으로 지원하지 않는 이전 브라우저에서 최신 기능을 제공하는 데 필요한 코드 (JavaScript) ”mdn”
 자바스크립트는 끊임없이 발전되어왔기 때문에 명세도 계속 변화되어왔습니다.
이 과정에서 모든 브라우저는 발전된 스크립트 문법을 제공하지 않을 수 있기 때문에 브라우저 호환성 문제를 해결하기 위해 일종의 코드 조각을 추가하는 것을 polyfill이라고 합니다. polyfill을 지원하는 대표적인 라이브러리는 core-js와 polyfill.</description>
    </item>
    
    <item>
      <title>[React] Ref의 개념과 useImperativeHandle, Uncontrolled form</title>
      <link>https://jinyisland.kr/post/react-ref/</link>
      <pubDate>Tue, 28 Feb 2023 23:51:31 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/react-ref/</guid>
      <description>Ref  ref는 render 메서드에서 생성된 DOM 노드나 React 엘리먼트에 접근하는 방법을 제공합니다.
  포커스, 텍스트 선택, 혹은 미디어의 재생을 관리할 때 애니메이션을 직접적으로 실행시킬 때 React와 같이 서드 파티 DOM 라이브러리를 사용할 때  순수 자바스크립트에서는 UI를 변경하기 위해 DOM API를 사용하여 DOM에 직접적으로 접근하였습니다. React에서는 이러한 방식을 지양하고, ref 객체를 생성하여 접근하도록 권고합니다.
DOM API를 이용하여 접근하기 DOM에 접근하기 위해서는 기존의 DOM API를 사용할 수 있습니다.
import React from &amp;#39;react&amp;#39;; const Component = () =&amp;gt; { const hadleClick = () =&amp;gt; { document.</description>
    </item>
    
    <item>
      <title>[Redux] Redux 사용해보기</title>
      <link>https://jinyisland.kr/post/redux/</link>
      <pubDate>Mon, 02 Jan 2023 23:57:40 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/redux/</guid>
      <description>개요 리덕스는 상태 관리를 위한 라이브러리이다. 리액트에서만 사용하는 것이 아니라 순수 자바스크립트 환경 &amp;amp; 여러 프론트엔트 프레임워크에서도 사용이 가능하다. 일례로 Vue프로젝트에서 상태 관리를 사용하기 위해 사용했던 flux 패턴도 리덕스에서 참고 하였다. (당시 작성한 게시글)
공식문서에서 제안하는 리덕스의 필요성은 다음과 같다.
 계속해서 바뀌는 상당한 양의 데이터가 있다. 상태를 위한 단 하나의 근원이 필요하다. 최상위 컴포넌트가 모든 상태를 가지고 있는 것은 더 이상 적절하지 않다.  설치하기 공식 문서를 살펴보면 Redux Toolkit을 강력하게 추천해주고 있다.</description>
    </item>
    
    <item>
      <title>[Vue] Composition API 사용 방법</title>
      <link>https://jinyisland.kr/post/composition-api/</link>
      <pubDate>Tue, 26 Jul 2022 23:36:59 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/composition-api/</guid>
      <description>Options API의 장단점 Vue에서 기본적으로 사용하고 있는 패턴은 객체 내에 다양한 속성을 사용하고 있는 형태이다. 라이프사이클을 제어하기 위해 사용하는 mounted, updated 그리고 컴포넌트 내에서 여러 메서드들을 정의하고 데이터들을 참조할 때 정해진 속성에 정의해서 사용하였다. 이를 Options API라고 한다.
아래는 페이지네이션 기능 컴포넌트를 구현할 때 작성했던 코드인데, 컴포지션 API를 적용하지 않은 options api 방식으로 작성하였다.
export default { components: { //컴포넌트 정의  ChildComponent }, data() { //참조할 데이터 정의  return { newsItem: {}, showModal: false, page: 1, records: 20, listItems: [], options: { hideCount: true } }; }, mounted: function () { //마운트 시점 제어  this.</description>
    </item>
    
    <item>
      <title>[React] 리액트 라우터 기본 사용방법</title>
      <link>https://jinyisland.kr/post/react-router/</link>
      <pubDate>Wed, 22 Jun 2022 23:23:52 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/react-router/</guid>
      <description>페이지 라우팅 vue를 처음 접했을 때 이해했던 개념이지만, 한번 더 정리하자면 일단 라우터라는 개념은 네트워크 상에서 통신 데이터를 보낼 경로를 선택하는 과정을 의미한다. SPA 환경의 웹 애플리케이션(Vue, React, Angular)에서는 말 그대로 요청(Request)에 따라 알맞은 페이지를 반환해주는 과정 자체로 이해하면 된다.
SPA의 단일 페이지라는 이점을 살려, MPA(Multi Page Application) 환경과는 달리 페이지자체를 반환하지 않고 데이터만 불러와 렌더링해주기 때문에 사용자 입장에서 훨씬 빠르다고 느낄 수 있다. 또한 클라이언트에서 렌더링을 다루기때문에 CSR(Client Side Rendering)이라고도 불린다.</description>
    </item>
    
    <item>
      <title>[React] 컴포넌트에 Props 전달하기</title>
      <link>https://jinyisland.kr/post/react-props/</link>
      <pubDate>Mon, 13 Jun 2022 23:54:07 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/react-props/</guid>
      <description>개념 컴포넌트에 데이터를 전달하는 데이터를 prop이라고 한다. (Properties의 줄임말)
Props 단일 값 전달하기 컴포넌트 작성 시 해당 컴포넌트 태그에 변수이름={}으로 사용한다.
//App.js (최상위 컴포너트) const today = function () { return new Date().toISOString(); }; function App() { return ( &amp;lt;div className=&amp;#34;App&amp;#34;&amp;gt; &amp;lt;AppHeader /&amp;gt; &amp;lt;header className=&amp;#34;App-header&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;{myName}&amp;lt;/h2&amp;gt; &amp;lt;Time init={today} /&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;AppFooter /&amp;gt; &amp;lt;/div&amp;gt; ); } 전달받는 컴포넌트 (자식 컴포넌트)에서는 매개변수로 받아올 수 있는데 객체 타입으로 전달 받는다.
function Time(props) { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;What Time?</description>
    </item>
    
    <item>
      <title>[React] jsx 사용방법</title>
      <link>https://jinyisland.kr/post/jsx/</link>
      <pubDate>Mon, 02 May 2022 23:12:10 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/jsx/</guid>
      <description>JSX JavaScript Extension, 자바스립트를 확장한 문법이다.(HTML이 아니다.) 리액트에서 컴포넌트 구조를 작성하면서 HtML 대신 jsx로 UI를 표현한다고 생각하면 된다. vue에서는 template태그에 직접 HTML 문법을 사용했었는데 동일한 역할이다. 확장자는 jsx로 사용할 수 있으나 js로 사용해도 자동 변환이 되기 때문에 어느 것으로 해도 큰 상관은 없다.
기본 문법 스타일 적용하기 className
jsx에서는 스타일을 적용하기 위한 class는 자바스크립트 예약어라 className으로 대체한다.
const AppFooter = () =&amp;gt; { return &amp;lt;footer className=&amp;#34;red&amp;#34;&amp;gt;Footer&amp;lt;/footer&amp;gt;; }; InlineStyle
기존 방식대로 클래스나 id를 붙여 css를 적용하는 방법 외에도, 스크립트 자체에서 스타일을 적용시킬 수 있다.</description>
    </item>
    
    <item>
      <title>자바스크립트 함수형 반복문</title>
      <link>https://jinyisland.kr/post/js-loop/</link>
      <pubDate>Wed, 06 Apr 2022 21:43:40 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-loop/</guid>
      <description>요즘 인프런을 통해 알고리즘 강의를 수강 중인데 개인적으로 많은 도움을 받고 있다. 단순히 알고리즘 문제를 친숙하게 다가가기 위해 강의를 끊은것인데.. 의외로 실무에서도 크게 도움이 될 것 같아 이번 기회에 포스팅을 했다.
함수형 반복문 사실 지금까지 반복문을 사용하는 방법은 크게 신경쓰지 않았다. 보통 레거시 코드에서는 for문을 많이 사용하는데(다른 언어에서도 많이 사용하고, 너무 친숙해졌다..) 이는 절대 낡거나 안좋은 코드라는 것은 절대 아니다!! 상황에 따라서 함수형으로 제공되는 반복문을 사용하는 경우가 효율적인 것도 있고 for를 사용하는 것이 더 효율적인 상황도 분명히 있다.</description>
    </item>
    
    <item>
      <title>[Vue] Vue 코드 포맷팅</title>
      <link>https://jinyisland.kr/post/prettier/</link>
      <pubDate>Mon, 20 Dec 2021 23:49:00 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/prettier/</guid>
      <description>Code Convention 프로젝트 진행 시 기능 구현도 중요하지만, 추후 유지보수를 위한 convention도 굉장히 중요하다고 생각한다. 특히 협업으로 작업하는 경우 거의 필수로 작용하는데, 개발자 마다 선호하는 코딩 스타일도 다르고 하물며 변수 명 하나하나 지을 때도 케밥케이스, 카멜케이스 등 여러 방식도 존재하기 때문이다. 물론 개인 프로젝트에서도 이 부분은 꽤나 중요한데 전체적인 일관성이 유지되어야 보는 사람들도 코드를 읽기 편하다. 컨벤션을 잘 지킬 수 있는 플러그인 중 대다수가 사용하는 eslint와 prettier를 vue와 연동해보는 것을 정리해보았다.</description>
    </item>
    
    <item>
      <title>[Vue] Vuex 개념과 실제 사용해보기!</title>
      <link>https://jinyisland.kr/post/vuex/</link>
      <pubDate>Fri, 03 Dec 2021 16:10:08 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vuex/</guid>
      <description>Vuex vuex는 vue.js에서 컴포넌트들의 상태 관리를 위한 효율적인 라이브러리이다.
React의 Flux 이름과 비슷한것을 보면 Flux 패턴에서 차용한 것이라고 한다.
Vuex를 사용하면 좋은 점 기본적으로 vue 생태계에서 컴포넌트 간 여러 정보들을 관리하려면 부모-자식 관계로 데이터들을 넘겨주고 받아야한다. 하지만 현실적으로 복잡한 컴포넌트 관계속에서 계속 주고 받으려면 여러 컴포넌트 파일에서 data 속성을 관리해주어야 하는 단점이 있다. 예를 들어 위 사진처럼 깊은 관계에서 다른 컴포넌트로 데이터를 보내려면 부모 컴포넌트를 계속 찾아 이벤트를 바인딩 시키고 다시 props로 내려주어야 하는 불편함이 있다.</description>
    </item>
    
    <item>
      <title>[Vue] Vue에 Tailwind CSS 적용하기</title>
      <link>https://jinyisland.kr/post/vue-tailwind/</link>
      <pubDate>Thu, 21 Oct 2021 23:05:04 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-tailwind/</guid>
      <description>tailwind? tailwind는 CSS 프레임워크이다. 사용방법은 공식 문서를 보면 잘 나와있다. 기본적으로 태그 내에 inline형태로 클래스 형태로 스타일을 입히는 방식이다. 기존 css로 작업했을 때와 tailwind를 사용했을 때를 비교해 보자면 다음과 같다.
  브라우징 최적화
autoprefixer를 내장해서 사용하고 있기 때문에, 브라우저별로 상이한 스타일 문제로 골머리를 앓지 않아도 된다.
  클래스 기반 스타일 tailwind 기본 사용법은 태그 내에 클래스로 스타일을 입히는 방식이다. 예를 들어 특정 태그에 배경색을 입히려면 아래와 같이 작성한다. 클래스 명도 이해하기 쉽도록 구성되어 있기 때문에 대충 이름만 봐도 어떠한 역할인지는 파악이 된다.</description>
    </item>
    
    <item>
      <title>힙의 개념과 힙 정렬 알고리즘</title>
      <link>https://jinyisland.kr/post/algorithm-heap/</link>
      <pubDate>Sat, 16 Oct 2021 23:24:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/algorithm-heap/</guid>
      <description>힙 정렬 완전 이진트리에서 파생된 heap 특성을 사용하여 정렬하는 알고리즘, 힙은 부모의 값이 자식의 값보다 항상 크거나 항상 작다라는 조건을 만족하는 완전이진트리 형태의 자료구조이다.
완전이진트리는 자식 노드를 왼쪽부터 채워나가는 형태의 자료구조이다. 힙의 개념 완전이진트리와의 차이점은 큰 값이 상위, 작은 값이 하위에 위치한 트리형 자료구조로써 부모-자식 관계가 일정해야한다. 작은 값이 부모가 되는 힙 형태를 min-heap(최소 힙), 큰 값이 부모가 되는 트리 구조를 max-heap(최대 힙)이라고 한다. 힙은 다음과 같은 관계를 가지고 있어야한다.</description>
    </item>
    
    <item>
      <title>[Vue] computed와 Watch</title>
      <link>https://jinyisland.kr/post/computed-watch/</link>
      <pubDate>Sat, 09 Oct 2021 23:17:34 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/computed-watch/</guid>
      <description>vue에서 data 속성에 있는 값을 사용하고자 할 때, 값이 변화할 때 마다 자동적으로 리렌더링 해주는 인스턴스 속성이 2개가 있다. 바로 computed와 watch, 이 두 속성의 공통점은 값을 감지하다가 변경되면 메서드를 호출함으로써 값을 바로 반환해준다. 이 비슷한 두 속성에 대해 차이점에 대해서 알아보았다.
computed 사용법은 아래 코드를 참고, computed속성 내에 메서드를 정의하고 템플릿내에 호출을 하면 해당 값이 바뀔 때 마다 재호출을 해준다. 이는 캐싱이되는 성질이 있어 해당 값이 바뀌지 않는다면 호출을 절대 하지 않는다.</description>
    </item>
    
    <item>
      <title>탐색 알고리즘 (선형, 이진)</title>
      <link>https://jinyisland.kr/post/algorithm-search/</link>
      <pubDate>Tue, 14 Sep 2021 23:25:12 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/algorithm-search/</guid>
      <description>선형검색 배열에서 원하는 키 값 요소를 만날 때까지 순서대로 요소 검색, 값을 찾지 못하고 배열을 모두 순회하거나 값을 찾는다면 바로 종료한다.
function linearSearch(key, arr) { for (let index = 0; index &amp;lt; arr.length; index++) { if (key === arr[index]) { return true; } } return false; } linearSearch(2811, [2, 15, 24, 28, 304, 16, 7, 1]); //false linearSearch(16, [2, 15, 24, 28, 304, 16, 7, 1]); //true 이진검색 이미 정렬되어 있는 배열(전제 조건)에서 범위를 좁혀가며 값을 찾는 탐색법 선형 탐색보다 속도가 빠르긴하지만 정렬되어 있는 리스트에 적용할 수 있다.</description>
    </item>
    
    <item>
      <title>자바스크립트 모듈화</title>
      <link>https://jinyisland.kr/post/js-module/</link>
      <pubDate>Sat, 11 Sep 2021 23:36:33 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-module/</guid>
      <description>Module module객체를 통해 각각의 기능이나 js파일들을 쉽게 모듈화가 가능하다.
export 코드를 외부에 내보내고 싶다면 export문을 사용한다. 함수, 변수, 클래스 등을 내보낼 수 있다.
//📁module/util.js const constants = { message : &amp;#39;simple message&amp;#39;; } const requestUrl = &amp;#39;/xyz-url&amp;#39;; const private = { privateKey : &amp;#39;1234&amp;#39; } export {constants, requestUrl}; //배열로도 export가 가능하다. (1~2개 모듈은 보통 객체형식으로 많이 사용) 각각의 모듈 대상에 export 예약어를 붙여 내보낼 수도 있다.
export function constants = { message : &amp;#39;simple message&amp;#39;; } import import를 통해 상대 경로에 위치한 모듈 파일을 가져올 수 있다.</description>
    </item>
    
    <item>
      <title>Promise와 Async/await</title>
      <link>https://jinyisland.kr/post/promise-async-await/</link>
      <pubDate>Wed, 08 Sep 2021 23:18:33 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/promise-async-await/</guid>
      <description>Promise function callbackDelay(sec, callback) { setTimeout(() =&amp;gt; { callback(&amp;#39;콜백 Delay&amp;gt;&amp;gt;&amp;#39; + new Date().toString()); }, sec * 1000); } callbackDelay(1, (result) =&amp;gt; { console.log(1, result); callbackDelay(1, (result) =&amp;gt; { console.log(2, result); callbackDelay(1, (result) =&amp;gt; { console.log(3, result); }); }); }); /*result 1 콜백 Delay&amp;gt;&amp;gt;Sun Jun 07 2020 18:43:56 GMT+0900 (GMT+09:00) promise.js:26 2 콜백 Delay&amp;gt;&amp;gt;Sun Jun 07 2020 18:43:57 GMT+0900 (GMT+09:00) promise.js:28 3 콜백 Delay&amp;gt;&amp;gt;Sun Jun 07 2020 18:43:58 GMT+0900 (GMT+09:00) */ 자바스크립트에서 비동기 동작을 할때 우리는 항상 해당 함수에 콜백 함수를 넣어줬다.</description>
    </item>
    
    <item>
      <title>비동기와 이벤트 루프</title>
      <link>https://jinyisland.kr/post/eventloop/</link>
      <pubDate>Tue, 07 Sep 2021 21:59:08 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/eventloop/</guid>
      <description>비동기 처리 //대충 이런 구조의 코드.. function checkValue() { //로직검사.. } setTimeout(function () { checkValue(); }, 500); function getData() { //AJAX로 소스를 받아오는 코드.. } getData(); 자바스크립트를 처음 접했을 때, setTimeout이 왜 순서대로 시행 안되지??.. (why 나중에 시행되는거야..🤔)해서비동기에 대한 개념을 숙지했다. 대충 콜백함수로 넘겨서 호출해 해결하고 비동기 프로세스에 대한 개념 자체를 더 배우려하지 않았다. 이번에 Node.js 스터디를 하면서 비동기 프로세스를 꼭 알아야 성능 향상에 도움이 된다는 사실을 알게되었고 책과 강의를 통해 내가 이해한 비동기 처리과정을 최대한 간략하게 정리해보았다.</description>
    </item>
    
    <item>
      <title>자바스크립트 화살표 함수</title>
      <link>https://jinyisland.kr/post/arrow-function/</link>
      <pubDate>Sun, 05 Sep 2021 19:45:01 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/arrow-function/</guid>
      <description>화살표 함수 기존 함수 표기법을 화살표(⇒)형태로 간단하게 표기하는 함수 표기법
기존 함수 표현식과의 차이 //기존 함수 표현식 function name() { //code.. } //화살표 함수 () =&amp;gt; { //code.. }; 화살표 함수 특징 괄호 생략 매개변수가 1개라면 괄호()도 생략이 가능하다.
const logMessage = (message) =&amp;gt; { console.log(message); }; logMessage(&amp;#39;hello&amp;#39;); //&amp;#39;hello&amp;#39; Lexical this 일반 함수 표기에서는 this사용 시 동적으로 해당 함수를 실행한 객체로 바인딩되었다.
하지만 화살표 함수에서는 자신을 소유하고 있는 객체로 바인딩되는게 아니라 해당 화살표함수를 소유하고 있는 상위 환경의 this를 그대로 계승한다.</description>
    </item>
    
    <item>
      <title>자바스크립트 템플릿리터럴</title>
      <link>https://jinyisland.kr/post/template-literals/</link>
      <pubDate>Sun, 05 Sep 2021 19:36:27 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/template-literals/</guid>
      <description>Temlate literals 기존 문자열 결합 시 연산자(+)를 사용하였는데 백틱(`) 기호를 사용하여 쉽게 결합할 수 있다.
기존 연산자 사용 const fruit = &amp;#39;apple&amp;#39;; const color = &amp;#39;red&amp;#39;; console.log(&amp;#39;My Favorite Fruit is&amp;#39; + fruit + &amp;#39;, color is &amp;#39; + color); //&amp;#34;My Favorite Fruit isapple, color is red&amp;#34; 템플릿리터럴 사용 const fruit = &amp;#39;apple&amp;#39;; const color = &amp;#39;red&amp;#39;; console.log(`My favorite Fruit is ${fruit}, color is ${color}`); 장점 보통 복잡한 문자열이거나 html 코드등을 직접 스크립트상에서 삽입할 때 쌍따옴표-홀따옴표등과 같이 사용하는 경우에 상당히 복잡했었다.</description>
    </item>
    
    <item>
      <title>let, const와 기존 var의 차이</title>
      <link>https://jinyisland.kr/post/let-const/</link>
      <pubDate>Mon, 30 Aug 2021 23:39:26 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/let-const/</guid>
      <description>요즘 공부하고 있는 vue.js 프레임워크를 사용하다보면 자연스럽게 es6 이상의 트렌디한 자바스크립트 문법이 눈에 띈다. 🧐
물론 vue 코드를 빠르게 짤 수 있는 스니펫 플러그인에서도 기본적으로 es6+ 문법으로 안내해주기도하고.. vue를 사용해서가 아니라 이렇게 트렌디한~자바스크립트에서는 어떤 문법이 있는지 차례차례 짚고 넘어가고자 한다. (물론 내 기준 현업 또는 개인적으로 많이 쓰는 문법 위주로~ㅎㅎ)
블록범위 먼저 let과 const를 제대로 이해하려면 블록범위를 제대로 알고넘어가야한다!
블록범위 내에서 let과 const를 사용하면 해당 변수를 재할당할 수 없도록 지정할 수 있다.</description>
    </item>
    
    <item>
      <title>[Vue] 라우터 개념 및 사용방법</title>
      <link>https://jinyisland.kr/post/vue-router/</link>
      <pubDate>Mon, 23 Aug 2021 22:54:41 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-router/</guid>
      <description>라우터 클라이언트의 요청 경로에 따라 해당하는 컴포넌트를 불러와 페이지를 구성할 수 있다.
URL 변경 시 DOM을 새로 갱신하는 것이 아니라 미리 컴포넌트를 가지고 있다가 변경된 요소영역만 갱신한다.(SPA 언어의 큰 특징)
따라서 유연하게 페이지 젼환이 가능하다. vue 프레임워크에서는 vue-router라는 라우팅 라이브러리를 지원한다.
설치하기 vue-router를 설치하고, package.json파일에서 모듈이 잘 추가되었는지 확인하자
npm install vue-router --save 라우터 속성 다음은 라우터 인스턴스를 생성할 때 설정하는 값이다.
 String mode : 기본 값은 Hash 모드 (history 모드를 사용하면 브라우저 히스토리 스택에 기록된다.</description>
    </item>
    
    <item>
      <title>자바스크립트 클로저</title>
      <link>https://jinyisland.kr/post/js-closure/</link>
      <pubDate>Tue, 10 Aug 2021 23:51:20 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-closure/</guid>
      <description>클로저 개념 클로저는 쉽게말해 함수 선언시 생성되는 유효 범위이다.
먼저 자바스크립트에서 클로저를 이해하려면 범위 지정(Lexical Scoping)을 이해하여야 한다.
아래 코드를 보자.
var apple = &amp;#39;🍎&amp;#39;; function displayApple() { console.log(apple); } displayApple(); //result : 🍎 간단하게 사과를 출력해주는 함수다.
하지만, 정작 함수안에는 apple이라는 변수가 없는데도 불구하고 사과가 출력되었다.
지난번 실행컨텍스트에서 언급했듯이 해당 유효범위에서 식별자를 찾지 못하면 점점 상위 ~ 전역으로 탐색한다. Scope Chain
var displayPrice; var apple = **&amp;#39;🍎&amp;#39;;** function displayApple(){ var price = 1000; console.</description>
    </item>
    
    <item>
      <title>자바스크립트 함수, 이것만은 꼭 기억하자</title>
      <link>https://jinyisland.kr/post/js-function/</link>
      <pubDate>Wed, 04 Aug 2021 23:34:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-function/</guid>
      <description>함수 자바스크립트의 함수는 객체로 취급 받는다. (일급객체)
따라서 객체처럼 리터럴 방식으로 선언할 수 있고, new 연산자로 선언할 수도 있다. (대부분.. 리터럴 방식을 선호한다.)
//new 연산자 선언 var sum = new Function(&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;return a+b&amp;#39;); sum(1, 3); //4 익명함수와 선언함수 익명 함수는 말 그대로 &amp;lsquo;이름을 갖지 않는&amp;rsquo; 함수이다.
보통 변수에 저장해서 선언 후 호출한다.
add(2, 3); //result : type error  var add = function (x, y) { //익명함수  return x + y; }; add(3, 7); //result : 10 선언 함수는 함수 선언 시 이름을 지명한다.</description>
    </item>
    
    <item>
      <title>자바스크립트에서의 데이터 타입</title>
      <link>https://jinyisland.kr/post/datatype/</link>
      <pubDate>Tue, 03 Aug 2021 21:38:58 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/datatype/</guid>
      <description>원시타입과 참조타입 자바스크립트에서는 원시타입과 참조타입이 존재한다. 원시타입 그 자체가 값인 데이터 타입을 말한다.
변수에 접근할 때 해당 변수에 저장된 실제 값을 조작한다.
기본 값의 유형을 확인하려면 typeof연산자를 사용해서 확인할 수 있다.
자바스크립트에서는 배열과 객체 모두 object로 취급한다는 사실을 꼭 잊지말자.
const typeNumeric = typeof 1; //number const typeBoolean = typeof true; //boolean const typeString = typeof &amp;#39;hello&amp;#39;; //string const typeFunction = typeof function () { return; }; //function const typeUndefined = typeof undefined; //undefined  const typeObject = typeof {}; //object const typeArray = typeof [&amp;#39;1&amp;#39;]; //object const typeNull = typeof null; //object 참조타입 원시 값과는 달리 해당 객체의 참조에 대해서 작업한다.</description>
    </item>
    
    <item>
      <title>자바스크립트는 어떻게 동작할까?</title>
      <link>https://jinyisland.kr/post/how-js-work/</link>
      <pubDate>Tue, 27 Jul 2021 23:47:42 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/how-js-work/</guid>
      <description>자바스크립트의 특징 나는 주로 자바스크립트를 이용해 개발을하는 것을 좋아한다.
내 기준 가장 자신있는 언어이기도 하고, 배우면서 흥미로움을 느낀 프로그래밍 언어 중 하나였다.
하지만 자바스크립트는 쓰면 쓸수록 헷갈리는 개념도 많고, 처음엔 만만하게 보였지만 깊이 들어갈수록 난해한..언어이기도 하다.. (아직도 어렵다 ㅠㅠ)😵
자바스크립트에 대한 핵심적인 내용을 짚고 넘어가고자 해당 시리즈를 포스팅하기로 마음 먹었다! 첫 번째는 자바스크립트는 어떻게 동작할까?
유연한 언어 자바스크립트에서의 타입 체크는 타 언어보다 굉장히 유연하고 느슨하다. 아래 예시를 보면 보통의 언어 같으면 컴파일 단계에서 들어오지 않은 값에 대해 오류를 내뿜어내지만, 자바스크립트에서는 일단 처리를 한다.</description>
    </item>
    
    <item>
      <title>[Vue] 외부 Vue 프로젝트 불러오기</title>
      <link>https://jinyisland.kr/post/vue-import/</link>
      <pubDate>Sun, 18 Jul 2021 23:09:02 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-import/</guid>
      <description>윈도우에서 작업한 Vue 프로젝트를 mac 환경에서 확인하려던 중 git clone 후 프로젝트를 실행해보니 아래와 같은 에러가 나왔다.
&amp;gt; vue-todo@0.1.0 serve /Users/sjchoi/Mydoc/02_Code/05_vue/vue-practice/vue-todo &amp;gt; vue-cli-service serve sh: vue-cli-service: command not found npm ERR! code ELIFECYCLE npm ERR! syscall spawn npm ERR! file sh npm ERR! errno ENOENT npm ERR! vue-todo@0.1.0 serve: `vue-cli-service serve` npm ERR! spawn ENOENT npm ERR! npm ERR! Failed at the vue-todo@0.1.0 serve script. npm ERR! This is probably not a problem with npm.</description>
    </item>
    
    <item>
      <title>[Vue] 컴포넌트에 대한 개념</title>
      <link>https://jinyisland.kr/post/vue-component/</link>
      <pubDate>Thu, 01 Jul 2021 21:27:40 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-component/</guid>
      <description>컴포넌트 개념 화면의 영역을 분리하여 개발하는 것, Vue에서 최상위 컴포넌트는 root이다.
컴포넌트 구성의 장점은 요소들을 재사용함으로써 개발 생산성이 향상되고, 컴포넌트들은 서로 관계가 형성된다.
전역 컴포넌트 주로 플러그인, 라이브러리 등 앱 전역에서 사용 할 공통 컴포넌트를 작성한다.
전역 컴포넌트를 생성하면 새 인스턴스를 생성할 때 마다 기본적으로 생성한다.
//컴포넌트 생성 Vue.component(&amp;#39;app-header&amp;#39;, { template: &amp;#39;&amp;lt;h1&amp;gt;header&amp;lt;/h1&amp;gt;&amp;#39; //component Template }); Vue.component(&amp;#39;app-content&amp;#39;, { template: &amp;#39;&amp;lt;p&amp;gt;This is Vue-Component Write&amp;lt;/p&amp;gt;&amp;#39; }); //인스턴스 생성 new Vue({ el: &amp;#39;#app&amp;#39; //selector }); 지역 컴포넌트 Vue 인스턴스 내에 직접 삽입하는 방식이다.</description>
    </item>
    
    <item>
      <title>[Vue] Vue 설치하기 및 프로젝트 구조</title>
      <link>https://jinyisland.kr/post/vue-start/</link>
      <pubDate>Wed, 30 Jun 2021 20:20:49 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/vue-start/</guid>
      <description>CLI? cli란 Command Line Interface, 즉 명령어 기반의 인터페이스 환경을 의미한다.
vue 프로젝트 도입시 전체적인 웹애플레이케이션을 관리하려면 지금 소개하는 cli패키지를 설치하면 되고,
별도의 페이지에서 국한적으로 사용하려면 cdn방식으로도 사용할 수 있다.
CDN 방식을 사용하려면 아래 소스를 참고하면 된다.
&amp;lt;head&amp;gt; &amp;lt;!-- Vue-CDN --&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- template --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;app-footer&amp;gt;&amp;lt;/app-footer&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; //vue 인스턴스 생성  new Vue({ el: &amp;#39;#app&amp;#39;, components: { &amp;#39;app-footer&amp;#39;: { template: &amp;#39;&amp;lt;footer&amp;gt;Footer!&amp;lt;/footer&amp;gt;&amp;#39; } } }); &amp;lt;/script&amp;gt; Vue 설치하기 먼저 npm (node package manager) 및 node가 설치되어있어야 한다.</description>
    </item>
    
  </channel>
</rss>

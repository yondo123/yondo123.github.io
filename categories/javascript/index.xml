<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on Jiny</title>
    <link>https://jinyisland.kr/categories/javascript/</link>
    <description>Recent content in JavaScript on Jiny</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Apr 2022 23:55:37 +0900</lastBuildDate><atom:link href="https://jinyisland.kr/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>multer 사용법</title>
      <link>https://jinyisland.kr/post/multer/</link>
      <pubDate>Thu, 21 Apr 2022 23:55:37 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/multer/</guid>
      <description>multer  multer 요청 타입이 multeipart/form-data인 경우 multer를 이용해 받을 수 있다.
설치하기 1npm i multer 사용방법 multer모듈을 임포트 해주고 미들웨어로 사용하기 위해 여러 설정을 해준다.
1const multer = require(&amp;#39;multer&amp;#39;); 2const path = require(&amp;#39;path&amp;#39;); 3 4// 디렉토리 없을 경우 생성해주는 예외 처리 5// (server listen 전 단계 이므로 동기식 코드로 해도 무방) 6try { 7 fs.readdirSync(&amp;#39;assets&amp;#39;); 8} catch (error) { 9 console.error(&amp;#39;not exist directory.&amp;#39;); 10 fs.mkdirSync(&amp;#39;assets&amp;#39;); 11} 12 13const upload = multer({ 14 // 파일 저장 위치 (disk , memory 선택) 15 storage: multer.</description>
    </item>
    
    <item>
      <title>Express 라우터 살펴보기</title>
      <link>https://jinyisland.kr/post/express-routing/</link>
      <pubDate>Thu, 14 Apr 2022 23:18:59 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/express-routing/</guid>
      <description>라우팅 express 공식 문서 에서는 라우팅을 아래와 같이 설명하고 있다.
 라우팅은 URI(또는 경로) 및 특정한 HTTP 요청 메소드(GET, POST 등)인 특정 엔드포인트에 대한 클라이언트 요청에 애플리케이션이 응답하는 방법을 결정하는 것을 말합니다.
 정리하자면 요청 URI 규칙에 맞게 특정한 요청이 오면, 이에 맞는 응답 핸들러를 결정하는 것이라 생각하면된다
기본 문법 기본 문법은 다음과 같다. API 메서드(Http Method, string)는 HTTP 메서드를 작성한다. (GET, POST, PUT, DELETE..) 첫 번째 인자는 요청 URI 경로, 두 번째 인자에는 응답 핸들러(Handler, function)를 받는다.</description>
    </item>
    
    <item>
      <title>Express 미들웨어 사용법</title>
      <link>https://jinyisland.kr/post/middleware/</link>
      <pubDate>Tue, 12 Apr 2022 21:17:46 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/middleware/</guid>
      <description>미들웨어 말 그대로 요청(Request)과 응답(Response) 사이 중간(middle)에서 핸들링해주는 익스프레스의 핵심 기능이다.
사용법 use메서드를 사용하고 요청 메서드 내부에서 미들웨어를 정의할 수 있다.
1//모든 요청에서 미들웨어 실행 2app.use((req, res, next)=&amp;gt; { 3	console.log(&amp;#39;middle ware execute&amp;#39;); 4	next(); 5}, (req, res) =&amp;gt; { 6	// code.. 7});; 8 9//특정 요청 또는 경로에서 미들웨어 실행 (next 인자는 생략 가능) 10app.get((&amp;#39;/&amp;#39;, (req, res, next)=&amp;gt;{ 11	console.log(&amp;#34;request get, &amp;#39;/&amp;#39;&amp;#34;); 12	next(); 13}, (req, res)=&amp;gt;{ 14	throw new Error(&amp;#39;error!</description>
    </item>
    
    <item>
      <title>자바스크립트 함수형 반복문</title>
      <link>https://jinyisland.kr/post/js-loop/</link>
      <pubDate>Wed, 06 Apr 2022 21:43:40 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-loop/</guid>
      <description>요즘 인프런을 통해 알고리즘 강의를 수강 중인데 개인적으로 많은 도움을 받고 있다. 단순히 알고리즘 문제를 친숙하게 다가가기 위해 강의를 끊은것인데.. 의외로 실무에서도 크게 도움이 될 것 같아 이번 기회에 포스팅을 했다.
함수형 반복문 사실 지금까지 반복문을 사용하는 방법은 크게 신경쓰지 않았다. 보통 레거시 코드에서는 for문을 많이 사용하는데(다른 언어에서도 많이 사용하고, 너무 친숙해졌다..) 이는 절대 낡거나 안좋은 코드라는 것은 절대 아니다!! 상황에 따라서 함수형으로 제공되는 반복문을 사용하는 경우가 효율적인 것도 있고 for를 사용하는 것이 더 효율적인 상황도 분명히 있다.</description>
    </item>
    
    <item>
      <title>Express 설치 및 실행해보기</title>
      <link>https://jinyisland.kr/post/express-start/</link>
      <pubDate>Tue, 29 Mar 2022 22:57:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/express-start/</guid>
      <description>개요 기존 http모듈로 서버를 구축 해서 간단한 요청과 응답 프로세스를 경험해보았는데 여타 언어들도 그렇듯이 프레임워크를 사용하면 더욱 효율적으로 작업을 할 수 있다. node.js 생태계에서는 압도적으로 express.js를 많이 사용한다.
설치하기 npm 환경에서 install 명령어를 통해 express를 설치한다.
1npm install express 기본 구조 기본적인 서버를 구축한 소스이다.
http 모듈로 구축했을 때 URL도 파싱해야하고, if문으로 분기처리하기 수고스러웠는데 상당히 깔끔해졌다.
각 라우터마다 요청, 응답 객체를 받아와 여러 형태로 받거나 전달할 수 있다.
1//app.js 2const express = require(&amp;#34;express&amp;#34;); 3const app = express(); 4 5//get 메서드 6app.</description>
    </item>
    
    <item>
      <title>Node.js 파일 시스템 접근하기</title>
      <link>https://jinyisland.kr/post/node-file/</link>
      <pubDate>Mon, 28 Feb 2022 22:05:52 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/node-file/</guid>
      <description>FileSystem node.js에서는 fs 모듈을 통해 파일 시스템에 접근할 수 있다. 현재 파일 기준으로 경로를 잡는것이 아닌 실행하는 node 콘솔 기준으로 경로를 바라본다는 특징이 있다. 파일 시스템에 접근할 때는 반드시 보안에 꼭 신경쓰는 것이 좋다. 또한 비동기 함수이므로 동시에 실행이 보장되지 않는다.
1## hello Node.js! readFile 파일을 읽어오는 메서드이다. 첫 번째 인자에 해당 파일의 상대경로, 두 번째 인자에 콜백 함수를 입력 받는다.
(실행하는 node 기준이므로 같은 디렉토리에 위치해야한다.)
1const fs = require(&amp;#39;fs&amp;#39;); 2 3fs.</description>
    </item>
    
    <item>
      <title>Node.js 자주 사용하는 모듈 정리</title>
      <link>https://jinyisland.kr/post/useful-modules/</link>
      <pubDate>Mon, 10 Jan 2022 23:19:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/useful-modules/</guid>
      <description>global 브라우저의 window와 같은 전역 객체 역할, 하지만 브라우저와 관련된 객체(document 등)들은 사용하지 못한다. global객체 역시 생략해서 사용 가능하다. 그리고 브라우저의 window객체와 마찬가지로 global에 값을 주입하면 프로젝트 내 모든 파일에서 전역 변수로 사용할 수 있다 . (하지만 이러한 패턴은 지양한다, module을 통해 관리하자)
1global.console.log(&amp;#34;hello Node!&amp;#34;); 2console.log(&amp;#34;hello Node!&amp;#34;); console 로그를 출력하는 객체, 흔히 사용하는 log, error 말고 신기한 것을 소개한다.
console.time 수행 시점에 time을 찍어 해당 코드를 수행한 시간을 알아낼 수 있다.</description>
    </item>
    
    <item>
      <title>npm에 대한 개념과 사용 방법</title>
      <link>https://jinyisland.kr/post/npm/</link>
      <pubDate>Mon, 10 Jan 2022 22:40:47 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/npm/</guid>
      <description>npm NodeNode Package Manager, 말 그대로 Node.js 환경에서 여러 모듈들을 패키지화하여 관리하는 저장소 같은 역할이다.
패키지를 직접 만들어 배포할 수 있고 다른 사람이 배포한 여러 패키지 모듈들을 설치해 프로젝트에 적용시킬 수도 있다.
npm 생성하기 npm 환경에서 제일 중요한 것은 패키지 관리이다. 패키지들은 package.json파일에서 일괄적으로 관리하는데 직접 json 파일로 생성해도 되고, 명령어를 입력해 생성해도 된다. 터미널에서 npm init명령어를 입력하면 자동적으로 package.json파일을 생성할 수 있다.
1npm init 2# &amp;gt; packagename : 프로젝트 이름 입력 3# &amp;gt; version : 프로젝트 버전 입력 (default : 1.</description>
    </item>
    
    <item>
      <title>힙의 개념과 힙 정렬 알고리즘</title>
      <link>https://jinyisland.kr/post/algorithm-heap/</link>
      <pubDate>Sat, 16 Oct 2021 23:24:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/algorithm-heap/</guid>
      <description>힙 정렬 완전 이진트리에서 파생된 heap 특성을 사용하여 정렬하는 알고리즘, 힙은 부모의 값이 자식의 값보다 항상 크거나 항상 작다라는 조건을 만족하는 완전이진트리 형태의 자료구조이다.
완전이진트리는 자식 노드를 왼쪽부터 채워나가는 형태의 자료구조이다. 힙의 개념 완전이진트리와의 차이점은 큰 값이 상위, 작은 값이 하위에 위치한 트리형 자료구조로써 부모-자식 관계가 일정해야한다. 작은 값이 부모가 되는 힙 형태를 min-heap(최소 힙), 큰 값이 부모가 되는 트리 구조를 max-heap(최대 힙)이라고 한다. 힙은 다음과 같은 관계를 가지고 있어야한다.</description>
    </item>
    
    <item>
      <title>Node.js HTTP모듈 실습</title>
      <link>https://jinyisland.kr/post/node-restapi/</link>
      <pubDate>Fri, 17 Sep 2021 23:48:56 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/node-restapi/</guid>
      <description>Node.js HTTP 모듈을 통해 간단히 요청보내고, 주고받는 초간단 API 서버를 만들어보았다.
Request createServer 콜백에서 request, response 인자를 받는데 request 객체에서 요청 정보들을 받을 수 있다.
1const http = require(&amp;#34;http&amp;#34;); 2 3http.createServer(async (request, response)=&amp;gt;{ 4	try{ 5	const method = request.method; 6	const url = request.url; 7	//step 1. 요청 메소드 구분 8	if(method == &amp;#34;GET&amp;#34;){ 9	//step 2. URL 구분 10	if(url == &amp;#34;/&amp;#34;){ 11	}else if(url == &amp;#34;/list&amp;#34;){ 12	} 13	}else if(method == &amp;#34;POST&amp;#34;){ 14	//code.</description>
    </item>
    
    <item>
      <title>탐색 알고리즘 (선형, 이진)</title>
      <link>https://jinyisland.kr/post/algorithm-search/</link>
      <pubDate>Tue, 14 Sep 2021 23:25:12 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/algorithm-search/</guid>
      <description>선형검색 배열에서 원하는 키 값 요소를 만날 때까지 순서대로 요소 검색, 값을 찾지 못하고 배열을 모두 순회하거나 값을 찾는다면 바로 종료한다.
1function linearSearch(key, arr) { 2 for (let index = 0; index &amp;lt; arr.length; index++) { 3 if (key === arr[index]) { 4 return true 5 } 6 } 7 return false; 8} 9 10linearSearch(2811, [2, 15, 24, 28, 304, 16, 7, 1]); //false 11linearSearch(16, [2, 15, 24, 28, 304, 16, 7, 1]); //true 이진검색 이미 정렬되어 있는 배열(전제 조건)에서 범위를 좁혀가며 값을 찾는 탐색법 선형 탐색보다 속도가 빠르긴하지만 정렬되어 있는 리스트에 적용할 수 있다.</description>
    </item>
    
    <item>
      <title>자바스크립트 모듈화</title>
      <link>https://jinyisland.kr/post/js-module/</link>
      <pubDate>Sat, 11 Sep 2021 23:36:33 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-module/</guid>
      <description>Module module객체를 통해 각각의 기능이나 js파일들을 쉽게 모듈화가 가능하다.
export 코드를 외부에 내보내고 싶다면 export문을 사용한다. 함수, 변수, 클래스 등을 내보낼 수 있다.
1//📁module/util.js 2const constants = { 3	message : &amp;#39;simple message&amp;#39;; 4} 5 6const requestUrl = &amp;#39;/xyz-url&amp;#39;; 7 8const private = { 9	privateKey : &amp;#39;1234&amp;#39; 10} 11 12export {constants, requestUrl}; //배열로도 export가 가능하다. (1~2개 모듈은 보통 객체형식으로 많이 사용) 각각의 모듈 대상에 export 예약어를 붙여 내보낼 수도 있다.</description>
    </item>
    
    <item>
      <title>Promise와 Async/await</title>
      <link>https://jinyisland.kr/post/promise-async-await/</link>
      <pubDate>Wed, 08 Sep 2021 23:18:33 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/promise-async-await/</guid>
      <description>Promise 1function callbackDelay(sec, callback) { 2 setTimeout(()=&amp;gt;{ 3 callback(&amp;#34;콜백 Delay&amp;gt;&amp;gt;&amp;#34;+new Date().toString()); 4 }, sec * 1000) 5} 6 7callbackDelay(1, (result)=&amp;gt;{ 8 console.log(1, result); 9 callbackDelay(1, (result)=&amp;gt;{ 10 console.log(2, result); 11 callbackDelay(1, (result)=&amp;gt;{ 12 console.log(3, result) 13 }) 14 }) 15}) 16/*result 171 콜백 Delay&amp;gt;&amp;gt;Sun Jun 07 2020 18:43:56 GMT+0900 (GMT+09:00) 18promise.js:26 192 콜백 Delay&amp;gt;&amp;gt;Sun Jun 07 2020 18:43:57 GMT+0900 (GMT+09:00) 20promise.js:28 213 콜백 Delay&amp;gt;&amp;gt;Sun Jun 07 2020 18:43:58 GMT+0900 (GMT+09:00) 22*/ 자바스크립트에서 비동기 동작을 할때 우리는 항상 해당 함수에 콜백 함수를 넣어줬다.</description>
    </item>
    
    <item>
      <title>비동기와 이벤트 루프</title>
      <link>https://jinyisland.kr/post/eventloop/</link>
      <pubDate>Tue, 07 Sep 2021 21:59:08 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/eventloop/</guid>
      <description>비동기 처리 1//대충 이런 구조의 코드.. 2function checkValue(){ 3	//로직검사.. 4} 5 6setTimeout(function(){ 7	checkValue(); 8}, 500); 9 10function getData(){ 11	//AJAX로 소스를 받아오는 코드.. 12}; 13 14getData(); 자바스크립트를 처음 접했을 때, setTimeout이 왜 순서대로 시행 안되지??.. (why 나중에 시행되는거야..🤔)해서비동기에 대한 개념을 숙지했다. 대충 콜백함수로 넘겨서 호출해 해결하고 비동기 프로세스에 대한 개념 자체를 더 배우려하지 않았다. 이번에 Node.js 스터디를 하면서 비동기 프로세스를 꼭 알아야 성능 향상에 도움이 된다는 사실을 알게되었고 책과 강의를 통해 내가 이해한 비동기 처리과정을 최대한 간략하게 정리해보았다.</description>
    </item>
    
    <item>
      <title>자바스크립트 화살표 함수</title>
      <link>https://jinyisland.kr/post/arrow-function/</link>
      <pubDate>Sun, 05 Sep 2021 19:45:01 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/arrow-function/</guid>
      <description>화살표 함수 기존 함수 표기법을 화살표(⇒)형태로 간단하게 표기하는 함수 표기법
기존 함수 표현식과의 차이 1//기존 함수 표현식 2function name(){ 3 //code.. 4} 5 6//화살표 함수 7() =&amp;gt; { 8	//code.. 9} 화살표 함수 특징 괄호 생략 매개변수가 1개라면 괄호()도 생략이 가능하다.
1const logMessage = message =&amp;gt; { console.log(message) } 2logMessage(&amp;#39;hello&amp;#39;); //&amp;#39;hello&amp;#39; Lexical this 일반 함수 표기에서는 this사용 시 동적으로 해당 함수를 실행한 객체로 바인딩되었다.
하지만 화살표 함수에서는 자신을 소유하고 있는 객체로 바인딩되는게 아니라 해당 화살표함수를 소유하고 있는 상위 환경의 this를 그대로 계승한다.</description>
    </item>
    
    <item>
      <title>자바스크립트 템플릿리터럴</title>
      <link>https://jinyisland.kr/post/template-literals/</link>
      <pubDate>Sun, 05 Sep 2021 19:36:27 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/template-literals/</guid>
      <description>Temlate literals 기존 문자열 결합 시 연산자(+)를 사용하였는데 백틱(`) 기호를 사용하여 쉽게 결합할 수 있다.
기존 연산자 사용 1const fruit = &amp;#39;apple&amp;#39;; 2const color = &amp;#39;red&amp;#39;; 3console.log(&amp;#39;My Favorite Fruit is&amp;#39; + fruit + &amp;#39;, color is &amp;#39; + color ); //&amp;#34;My Favorite Fruit isapple, color is red&amp;#34; 템플릿리터럴 사용 1const fruit = &amp;#39;apple&amp;#39;; 2const color = &amp;#39;red&amp;#39;; 3console.log(`My favorite Fruit is ${fruit}, color is ${color}`); 장점 보통 복잡한 문자열이거나 html 코드등을 직접 스크립트상에서 삽입할 때 쌍따옴표-홀따옴표등과 같이 사용하는 경우에 상당히 복잡했었다.</description>
    </item>
    
    <item>
      <title>let, const와 기존 var의 차이</title>
      <link>https://jinyisland.kr/post/let-const/</link>
      <pubDate>Mon, 30 Aug 2021 23:39:26 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/let-const/</guid>
      <description>요즘 공부하고 있는 vue.js 프레임워크를 사용하다보면 자연스럽게 es6 이상의 트렌디한 자바스크립트 문법이 눈에 띈다. 🧐
물론 vue 코드를 빠르게 짤 수 있는 스니펫 플러그인에서도 기본적으로 es6+ 문법으로 안내해주기도하고.. vue를 사용해서가 아니라 이렇게 트렌디한~자바스크립트에서는 어떤 문법이 있는지 차례차례 짚고 넘어가고자 한다. (물론 내 기준 현업 또는 개인적으로 많이 쓰는 문법 위주로~ㅎㅎ)
블록범위 먼저 let과 const를 제대로 이해하려면 블록범위를 제대로 알고넘어가야한다!
블록범위 내에서 let과 const를 사용하면 해당 변수를 재할당할 수 없도록 지정할 수 있다.</description>
    </item>
    
    <item>
      <title>자바스크립트 클로저</title>
      <link>https://jinyisland.kr/post/js-closure/</link>
      <pubDate>Tue, 10 Aug 2021 23:51:20 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-closure/</guid>
      <description>클로저 개념 클로저는 쉽게말해 함수 선언시 생성되는 유효 범위이다.
먼저 자바스크립트에서 클로저를 이해하려면 범위 지정(Lexical Scoping)을 이해하여야 한다.
아래 코드를 보자.
1var apple = &amp;#39;🍎&amp;#39;; 2 3function displayApple(){ 4	console.log(apple); 5} 6 7displayApple(); 8//result : 🍎 간단하게 사과를 출력해주는 함수다.
하지만, 정작 함수안에는 apple이라는 변수가 없는데도 불구하고 사과가 출력되었다.
지난번 실행컨텍스트에서 언급했듯이 해당 유효범위에서 식별자를 찾지 못하면 점점 상위 ~ 전역으로 탐색한다. Scope Chain
1var displayPrice; 2var apple = **&amp;#39;🍎&amp;#39;;** 3function displayApple(){ 4	var price = 1000; 5	console.</description>
    </item>
    
    <item>
      <title>자바스크립트 함수, 이것만은 꼭 기억하자</title>
      <link>https://jinyisland.kr/post/js-function/</link>
      <pubDate>Wed, 04 Aug 2021 23:34:14 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/js-function/</guid>
      <description>함수 자바스크립트의 함수는 객체로 취급 받는다. (일급객체)
따라서 객체처럼 리터럴 방식으로 선언할 수 있고, new 연산자로 선언할 수도 있다. (대부분.. 리터럴 방식을 선호한다.)
1//new 연산자 선언 2var sum = new Function(&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;return a+b&amp;#39;); 3sum(1,3) //4 익명함수와 선언함수 익명 함수는 말 그대로 &amp;lsquo;이름을 갖지 않는&amp;rsquo; 함수이다.
보통 변수에 저장해서 선언 후 호출한다.
1add(2,3) //result : type error 2 3var add = function(x,y){ //익명함수 4	return x+y; 5} 6 7add(3,7); //result : 10 선언 함수는 함수 선언 시 이름을 지명한다.</description>
    </item>
    
    <item>
      <title>자바스크립트에서의 데이터 타입</title>
      <link>https://jinyisland.kr/post/datatype/</link>
      <pubDate>Tue, 03 Aug 2021 21:38:58 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/datatype/</guid>
      <description>원시타입과 참조타입 자바스크립트에서는 원시타입과 참조타입이 존재한다. 원시타입 그 자체가 값인 데이터 타입을 말한다.
변수에 접근할 때 해당 변수에 저장된 실제 값을 조작한다.
기본 값의 유형을 확인하려면 typeof연산자를 사용해서 확인할 수 있다.
자바스크립트에서는 배열과 객체 모두 object로 취급한다는 사실을 꼭 잊지말자.
1const typeNumeric = typeof 1; //number 2const typeBoolean = typeof true; //boolean 3const typeString = typeof &amp;#39;hello&amp;#39;; //string 4const typeFunction = typeof function(){ return;} //function 5const typeUndefined = typeof undefined; //undefined 6 7const typeObject = typeof {}; //object 8const typeArray = typeof [&amp;#39;1&amp;#39;]; //object 9const typeNull = typeof null; //object 참조타입 원시 값과는 달리 해당 객체의 참조에 대해서 작업한다.</description>
    </item>
    
    <item>
      <title>자바스크립트는 어떻게 동작할까?</title>
      <link>https://jinyisland.kr/post/how-js-work/</link>
      <pubDate>Tue, 27 Jul 2021 23:47:42 +0900</pubDate>
      
      <guid>https://jinyisland.kr/post/how-js-work/</guid>
      <description>자바스크립트의 특징 나는 주로 자바스크립트를 이용해 개발을하는 것을 좋아한다.
내 기준 가장 자신있는 언어이기도 하고, 배우면서 흥미로움을 느낀 프로그래밍 언어 중 하나였다.
하지만 자바스크립트는 쓰면 쓸수록 헷갈리는 개념도 많고, 처음엔 만만하게 보였지만 깊이 들어갈수록 난해한..언어이기도 하다.. (아직도 어렵다 ㅠㅠ)😵
자바스크립트에 대한 핵심적인 내용을 짚고 넘어가고자 해당 시리즈를 포스팅하기로 마음 먹었다! 첫 번째는 자바스크립트는 어떻게 동작할까?
유연한 언어 자바스크립트에서의 타입 체크는 타 언어보다 굉장히 유연하고 느슨하다. 아래 예시를 보면 보통의 언어 같으면 컴파일 단계에서 들어오지 않은 값에 대해 오류를 내뿜어내지만, 자바스크립트에서는 일단 처리를 한다.</description>
    </item>
    
  </channel>
</rss>
